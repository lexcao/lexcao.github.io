---
title: "Introducing genapi: A Golang HTTP Client Code Generator"
date: 2025-03-03
tags: [Golang, Code Generation]
---

In this article, I'm excited to introduce genapi, a code generator for Golang HTTP clients. For comprehensive documentation and implementation details, you can explore the [genapi website](https://lexcao.io/genapi/) or check out our [GitHub repository](https://github.com/lexcao/genapi).

# From Manual to Automatic: Evolution of Golang HTTP Client

In Golang development, making HTTP API calls is a very common requirement. Through a weather API example, this article will demonstrate how HTTP client code evolves from manual writing to automatic generation. Let's look at this simple weather API:

```go
GET /api/weather?city=shanghai
Response:
{
    "temperature": 25,
    "humidity": 60,
    "condition": "sunny"
}
```

## Initial Manual Approach

Initially, we might write code directly like this:

```go
func getWeather(city string) (*Weather, error) {
    resp, err := http.Get("https://api.weather.com/api/weather?city=" + city)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    var weather Weather
    if err := json.NewDecoder(resp.Body).Decode(&weather); err != nil {
        return nil, err
    }
    
    return &weather, nil
}
```

This approach is straightforward but has several issues:
1. Hardcoded URLs in the code
2. Error-prone parameter concatenation
3. Duplicate error handling logic
4. Repetitive response parsing code

## Templated Requests

To address these issues, we begin abstracting and templatizing the code:

```go
type Client struct {
    baseURL string
    client  *http.Client
}

func (c *Client) doRequest(method, path string, query url.Values, result interface{}) error {
    u, _ := url.Parse(c.baseURL + path)
    u.RawQuery = query.Encode()
    
    req, err := http.NewRequest(method, u.String(), nil)
    if err != nil {
        return err
    }
    
    resp, err := c.client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    return json.NewDecoder(resp.Body).Decode(result)
}

func (c *Client) GetWeather(city string) (*Weather, error) {
    query := url.Values{}
    query.Set("city", city)
    
    var weather Weather
    err := c.doRequest("GET", "/api/weather", query, &weather)
    return &weather, err
}
```

These improvements bring several benefits:
1. Unified error handling mechanism
2. Safer parameter construction
3. Reusable request handling logic

However, we still need to manually write each API method.

## genapi: Annotation-Driven Code Generation

To further improve development efficiency, introducing genapi. Through simple annotations, we can automatically generate all API call code:

```go
package api

import "github.com/lexcao/genapi"

//go:generate go run github.com/lexcao/genapi/cmd/genapi -file $GOFILE

// WeatherAPI defines the weather service API
// @BaseURL("https://api.weather.com")
type WeatherAPI interface {
    genapi.Interface

    // @get("/api/weather")
    // @query("city", "{city}")
    GetWeather(ctx context.Context, city string) (*Weather, error)
}
```

By just defining the interface and adding annotations, genapi will automatically generate the complete client code using go generate:

```go
// CODE GENERATED BY genapi. DO NOT EDIT.
package api

import (
    "context"
    "github.com/lexcao/genapi"
    "net/url"
)

type implWeatherAPI struct {
    client genapi.HttpClient
}

// SetHttpClient implements genapi.Interface
func (i *implWeatherAPI) SetHttpClient(client genapi.HttpClient) {
    i.client = client
}

func (i *implWeatherAPI) GetWeather(ctx context.Context, city string) (*Weather, error) {
    resp, err := i.client.Do(&genapi.Request{
        Method: "get",
        Path:   "/api/weather",
        Queries: url.Values{
            "city": []string{
                city,
            },
        },
        Context: ctx,
    })
    return genapi.HandleResponse[*Weather](resp, err)
}

func init() {
    genapi.Register[WeatherAPI, *implWeatherAPI](
        genapi.Config{
            BaseURL: "https://api.weather.com",
        },
    )
}
```

### Using the Generated Code

```go
func main() {
    client := genapi.New[api.WeatherAPI]()

    weather, err := client.GetWeather(context.TODO(), "shanghai")
}
```

# Summary

Through annotation-driven approach, genapi enables developers to:
- Focus on interface definition, avoiding repetitive code
- Improve development efficiency and reduce maintenance costs
- Make code clearer and more reliable

