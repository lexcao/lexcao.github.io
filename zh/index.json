[{"content":"本文将为大家介绍 genapi，一个用于自动生成 Golang HTTP Client 的代码库。如果你对这个项目感兴趣，可以访问 genapi 官网 或 GitHub 仓库 获取更多技术细节。\n从手工到自动：Golang HTTP Client 的演进之路 在 Golang 开发中，调用 HTTP API 是一个非常常见的需求。本文将通过一个天气 API 的示例，介绍 HTTP Client 代码是如何从手工编写演进到自动生成的。让我们看看这个简单的天气 API：\nGET /api/weather?city=shanghai Response: { \u0026#34;temperature\u0026#34;: 25, \u0026#34;humidity\u0026#34;: 60, \u0026#34;condition\u0026#34;: \u0026#34;sunny\u0026#34; } 原始手工编写 最初，我们可能会直接编写如下代码：\nfunc getWeather(city string) (*Weather, error) { resp, err := http.Get(\u0026#34;https://api.weather.com/api/weather?city=\u0026#34; + city) if err != nil { return nil, err } defer resp.Body.Close() var weather Weather if err := json.NewDecoder(resp.Body).Decode(\u0026amp;weather); err != nil { return nil, err } return \u0026amp;weather, nil } 这种方式简单直接，但存在以下问题：\nURL 硬编码在代码中 参数拼接容易产生错误 错误处理逻辑重复 响应解析代码重复 模板化请求 为了解决上述问题，我们开始对代码进行抽象和模板化改造：\ntype Client struct { baseURL string client *http.Client } func (c *Client) doRequest(method, path string, query url.Values, result interface{}) error { u, _ := url.Parse(c.baseURL + path) u.RawQuery = query.Encode() req, err := http.NewRequest(method, u.String(), nil) if err != nil { return err } resp, err := c.client.Do(req) if err != nil { return err } defer resp.Body.Close() return json.NewDecoder(resp.Body).Decode(result) } func (c *Client) GetWeather(city string) (*Weather, error) { query := url.Values{} query.Set(\u0026#34;city\u0026#34;, city) var weather Weather err := c.doRequest(\u0026#34;GET\u0026#34;, \u0026#34;/api/weather\u0026#34;, query, \u0026amp;weather) return \u0026amp;weather, err } 这样的改进带来了以下好处：\n统一的错误处理机制 更安全的参数构建方式 可复用的请求处理逻辑 然而，我们仍然需要手动编写每个 API 方法。\ngenapi：注解驱动的代码生成 为了进一步提高开发效率，引入 genapi。通过简单的注解，我们可以自动生成所有的 API 调用代码：\npackage api import \u0026#34;github.com/lexcao/genapi\u0026#34; //go:generate go run github.com/lexcao/genapi/cmd/genapi -file $GOFILE // WeatherAPI 定义了天气服务的 API // @BaseURL(\u0026#34;https://api.weather.com\u0026#34;) type WeatherAPI interface { genapi.Interface // @get(\u0026#34;/api/weather\u0026#34;) // @query(\u0026#34;city\u0026#34;, \u0026#34;{city}\u0026#34;) GetWeather(ctx context.Context, city string) (*Weather, error) } 只需要定义接口和添加注解，使用 go generate genapi 就会自动生成完整的客户端代码：\n// CODE GENERATED BY genapi. DO NOT EDIT. package api import ( \u0026#34;context\u0026#34; \u0026#34;github.com/lexcao/genapi\u0026#34; \u0026#34;net/url\u0026#34; ) type implWeatherAPI struct { client genapi.HttpClient } // SetHttpClient implments genapi.Interface func (i *implWeatherAPI) SetHttpClient(client genapi.HttpClient) { i.client = client } func (i *implWeatherAPI) GetWeather(ctx context.Context, city string) (*Weather, error) { resp, err := i.client.Do(\u0026amp;genapi.Request{ Method: \u0026#34;get\u0026#34;, Path: \u0026#34;/api/weather\u0026#34;, Queries: url.Values{ \u0026#34;city\u0026#34;: []string{ city, }, }, Context: ctx, }) return genapi.HandleResponse[*Weather](resp, err) } func init() { genapi.Register[WeatherAPI, *implWeatherAPI]( genapi.Config{ BaseURL: \u0026#34;https://api.weather.com\u0026#34;, }, ) } 生成后的代码这样使用 func main() { client := genapi.New[api.WeatherAPI]() weather, err := client.GetWeather(context.TODO(), \u0026#34;shanghai\u0026#34;) } 总结 genapi 通过注解驱动的方式，让开发者可以：\n专注于接口定义，避免编写重复代码 提高开发效率，降低维护成本 使代码更加清晰可靠 ","permalink":"https://lexcao.io/zh/posts/genapi/","summary":"\u003cp\u003e本文将为大家介绍 genapi，一个用于自动生成 Golang HTTP Client 的代码库。如果你对这个项目感兴趣，可以访问 \u003ca href=\"https://lexcao.io/genapi/\"\u003egenapi 官网\u003c/a\u003e 或 \u003ca href=\"https://github.com/lexcao/genapi\"\u003eGitHub 仓库\u003c/a\u003e 获取更多技术细节。\u003c/p\u003e\n\u003ch1 id=\"从手工到自动golang-http-client-的演进之路\"\u003e从手工到自动：Golang HTTP Client 的演进之路\u003c/h1\u003e\n\u003cp\u003e在 Golang 开发中，调用 HTTP API 是一个非常常见的需求。本文将通过一个天气 API 的示例，介绍 HTTP Client 代码是如何从手工编写演进到自动生成的。让我们看看这个简单的天气 API：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eGET\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eapi\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eweather\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e?\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ecity\u003c/span\u003e=\u003cspan style=\"color:#a6e22e\"\u003eshanghai\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eResponse\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;temperature\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e25\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;humidity\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e60\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;condition\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;sunny\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"原始手工编写\"\u003e原始手工编写\u003c/h2\u003e\n\u003cp\u003e最初，我们可能会直接编写如下代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egetWeather\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecity\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e) (\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eWeather\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eresp\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ehttp\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eGet\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;https://api.weather.com/api/weather?city=\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecity\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edefer\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresp\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eBody\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eClose\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eweather\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eWeather\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ejson\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eNewDecoder\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eresp\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eBody\u003c/span\u003e).\u003cspan style=\"color:#a6e22e\"\u003eDecode\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eweather\u003c/span\u003e); \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eweather\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这种方式简单直接，但存在以下问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eURL 硬编码在代码中\u003c/li\u003e\n\u003cli\u003e参数拼接容易产生错误\u003c/li\u003e\n\u003cli\u003e错误处理逻辑重复\u003c/li\u003e\n\u003cli\u003e响应解析代码重复\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"模板化请求\"\u003e模板化请求\u003c/h2\u003e\n\u003cp\u003e为了解决上述问题，我们开始对代码进行抽象和模板化改造：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eClient\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ebaseURL\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eclient\u003c/span\u003e  \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003ehttp\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eClient\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eClient\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003edoRequest\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003emethod\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003epath\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003equery\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eurl\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eValues\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eresult\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e{}) \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eu\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003e_\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eurl\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eParse\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ebaseURL\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epath\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eu\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eRawQuery\u003c/span\u003e = \u003cspan style=\"color:#a6e22e\"\u003equery\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eEncode\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ereq\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ehttp\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eNewRequest\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003emethod\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eu\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eString\u003c/span\u003e(), \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eresp\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eclient\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eDo\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ereq\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edefer\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eresp\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eBody\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eClose\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ejson\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eNewDecoder\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eresp\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eBody\u003c/span\u003e).\u003cspan style=\"color:#a6e22e\"\u003eDecode\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eresult\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e (\u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eClient\u003c/span\u003e) \u003cspan style=\"color:#a6e22e\"\u003eGetWeather\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ecity\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e) (\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eWeather\u003c/span\u003e, \u003cspan style=\"color:#66d9ef\"\u003eerror\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003equery\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eurl\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eValues\u003c/span\u003e{}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003equery\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSet\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;city\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ecity\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eweather\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eWeather\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ec\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003edoRequest\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;GET\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;/api/weather\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003equery\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eweather\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eweather\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这样的改进带来了以下好处：\u003c/p\u003e","title":"介绍 genapi：一个 Golang HTTP Client 生成代码库"},{"content":"翻译自 The Double-Entry Counting Method\n介绍 本文是一份关于复式记账的简要介绍，从计算机科学家的角度撰写。它试图以尽可能简单的方法解释基础记账，简化会计中通常涉及到的某些特殊性。它也代表了 Beancount 的工作方式，并且对所有使用纯文本记账的用户都应该适用。\n请注意，我不是会计师，在编写此文档过程中，我可能使用与传统会计培训教授略有不同或不常见的术语。我给自己授权创造一些新的、甚至是不寻常的东西，以便将这些想法尽可能简单明了地解释给那些对它们不熟悉的人。\n我认为每个高中生都应该在高中阶段学习复式记账法，因为这是一项极其有用的组织技能，并且我希望这篇文章可以帮助将其知识传播到专业圈以外的领域。\n复式记账的基础 复式记账法只是一种简单的计数方法，只有一些简单的规则。\n让我们从定义账户的概念开始。账户是一种可以容纳物品的东西，就像一个袋子。它用于计算和累积物品。让我们画一条水平箭头来直观地表示随着时间推移账户中不断变化的内容：\n左侧，是描述过去，而右侧则是不断增长的时间：现在、未来等。\n现在，让我们假设账户只能包含一种东西，例如美元。所有的账户都以零美元的空内容开始。我们将称账户中单位数量为账户的 余额 （Balance）。请注意，它代表了特定时间点上其内容的情况。我会使用一个数字在帐户时间轴上方绘制余额：\n账户的内容会随着时间而变化。为了改变账户的内容，我们必须向其添加一些东西。我们将这个添加称为对账户的记账，我会在该账户的时间轴上画一个带圈数字来表示这种变化，例如：向该账户中添加 100 美元：\n现在，我们可以在记账后绘制更新后的账户余额，并在其后面加上另一个小数字：\n账户加上 100 美元后，余额现在为 100 美元。\n我们也可以从账户中减去一定金额。例如，我们可以减去 25 美元，这样账户余额就变成了 75 美元：\n如果我们减去的金额超过账户余额，账户余额也可能变为负数。例如，如果我们从该账户中取出 200 美元，则余额现在变为 -125 美元：\n账户中包含负数是完全正常的。请记住，我们所做的只是计数。很快我们会看到，有些账户在它们的时间轴上将保持负余额。\n报表 （Statement） 值得注意的是，我在前一节中写下的时间线记账与机构为每个客户维护并通常通过邮件发送的纸质账户报表类似：\n时间 描述 金额 余额 2016-10-02 … 100.00 1100.00 2016-10-05 .. -25.00 1075.00 2016-10-06 .. -200.00 875.00 最终结余 875.00 有时候金额栏会被分成两个，一个显示正数，另一个显示负数：\n时间 描述 扣款 （Debit） 入账 （Credit） 余额 （Balance） 2016-10-02 … 100.00 1100.00 2016-10-05 .. 25.00 1075.00 2016-10-06 .. 200.00 875.00 最终结余 875.00 在这里，“扣款 （Debit）” 表示 “从你的账户中扣除”，而 “入账 （Credit）” 表示 “存入你的账户”。有时会使用词语 “取款 （Withdrawals）” 和 “存款 （Deposits）”。这完全取决于上下文：对于支票和储蓄账户，通常会有两种类型的记账，但对于信用卡账户来说，通常只显示正数，然后偶尔进行月度付款，因此使用单列格式。 【译者注：这里 Debit 和 Credit 可以翻译为 借方 （Debit） 和 贷方 （Credit），这里为了更好的理解金钱的流向，使用带有方向意味的词】\n无论如何，“余额” 栏始终显示账户在金额记入后的结余。有时，对账单按时间倒序呈现。\n单式记账 在这个故事中，这个账户属于某个人。我们将称呼此人为账户所有者。该账户可以用来代表现实世界中的一个账户，例如，想象一下我们使用它来代表银行里所有者支票账户的内容。因此，我们将通过给它命名来标记该帐户，在本例中为 “支票 （Checking）”：\n想象一下，某个时刻，这个账户的余额为 1,000 美元，就像我在图上画的那样。现在，如果所有者从这个账户中花费了 79 美元，我们会用以下方式表示：\n此外，如果支出是在 餐厅 （Restaurant） 用餐产生的，我们可以使用一个类别标记来指示这笔记账的用途。比如说，“餐厅”，就像这样：\n现在，如果我们有很多这样的记账，我们可以编写一个计算机程序来累积每个类别的所有更改，并为它们中的每一个计算总和。例如，这将告诉我们总共在餐馆花费了多少钱。这被称为单式记账法。\n但我们不会这样做，我们有更好的方法。请再耐心等待几个章节。\n复式记账 一个所有者可能有多个账户。我将通过在同一张图上绘制许多类似的账户时间线来表示这一点。与以前一样它们带有唯一的名称标签。假设所有者有与之前相同的 “支票 （Checking）” 账户，并且现在还有一个 “餐厅 （Restaurant）” 账户，可以用于累积在餐厅消费的所有用餐开销。它看起来像这样：\n现在，我们可以不像之前那样将记账归类为 “餐厅类别”，而是创建一个匹配的记账在 “餐厅” 账户上记录我们花费了多少钱用于用餐，金额为 79 美元：\n“餐厅” 账户和其他账户一样，也有一个累积余额，因此我们可以了解到我们在 “餐厅” 总共花费了多少。这与计算支票账户中的变化完全对称。\n现在，我们可以通过创建一种称为 “交易 （Transaction）” 的对象来将这两个记账关联起来，从而形成一种父级框。\n请注意，我们还将 “在 Uncle Boons 吃晚餐” 与此交易关联起来。一笔交易也有一个日期，它的所有记账都记录在该日期发生。我们称之为交易日期。\n现在我们可以介绍复式记账系统的基本规则：\n一笔交易的所有账目之和必须等于零。 The sum of all the postings of a transaction must equal zero. 记住这一点，因为这是复式记账法的基础和最重要的特征。有着重要的后果，我将在本文稍后讨论。\n在我们的例子中，我们从支票账户扣除 79 美元，并将其 “转移” 到餐厅账户。(79) + (-79) = 0。 为了强调这一点，我在交易的记账下面画一个小求和线，就像这样：\n许多账户 可能会有许多这样的交易，涉及许多不同的账户。例如，如果账户所有者第二天用信用卡支付了午餐费用，则可以通过创建一个 “信用卡 （Credit card）” 账户来表示，并具有相应的交易来跟踪现实世界中的信用卡余额：\n在这个例子中，所有者在一家名为 “Eataly” 的餐厅花费了 35 美元。所有者的信用卡之前的余额是 -450 美元；支出后，新余额为 -485 美元。\n对于每个真实世界的账户，所有者都可以像我们一样创建一个记账账户。此外，对于每种支出类别，所有者还会创建一个记账账户。在这个系统中，可以创建无限数量的账户。\n请注意，示例中的余额是负数；这不是错误。信用卡账户的余额通常为负数：它们代表你欠银行的金额，银行在信用上向你提供了借款。当你的信用卡公司跟踪你的支出时，从他们自己的角度写出对账单，并将其表示为正数。对于你来说，这些都是最终需要支付的金额。但在我们的记账系统中，在所有者的角度下表示数字，在他看来，这是他欠下的而不是拥有的钱。而他有的是一顿饭（“餐厅” 正数）。\n多次记账 最后，交易可能有超过两个的记账；事实上，它们可以有任意数量的记账。唯一重要的是它们金额之和为零（根据上述复式记账规则）。\n例如，让我们看看如果所有者在 12 月份发了工资会发生什么：\n这个例子中他的总工资记录为 -2,905 美元（稍后我会解释符号）。其中 905 美元用于缴税。他的 “净” 工资是剩下的 2,000 美元，存入了他的“支票账户”，导致该账户余额为 2,921 美元（之前的余额为 921 + 2,000 = 2,921）。此交易有三个记账：(+2000) + (-2905) + (+ 905) = 0。遵守复式记账规则。\n现在，你可能会问：为什么他的工资记录为负数？这里的推理与上面的信用卡类似，尽管可能更微妙一些。这些账户存在是为了从所有者的角度跟踪所有金额。所有者提供工作，并以此换取金钱和税收（正数）。所提供的工作以美元单位计价。它 “离开” 了所有者（想象一下，所有者口袋里存放着潜在的工作，在每天上班时将潜在的工作交给公司）。 所有者付出了价值 2905 美元的劳动力。我们想要追踪给出了多少劳动力，并且使用 “薪水” 账户来完成。那就是他总薪水。\n请注意，为了保持简单，我们已经简化了这个工资支出交易。更真实的薪水记录会有更多的账户；我们将分别核算州税和联邦税额，以及社会保障和医疗保险支付、扣除、通过工作支付的保险费和在该期间内累计的休假时间。但它不会更加复杂：所有金额都可以从他的工资单中转换成一个具有更多记账的单一交易。结构仍然相似。\n账户类型 现在让我们转向所有者可以拥有的不同类型的账户。\n余额或差额。首先，账户之间最重要的区别在于我们是否关心特定时间点的余额，还是只关心一段时间内的差异。例如，某人支票或储蓄账户的余额是一个有意义的数字，所有者和相应银行都会关注它。同样地，某人信用卡账户上欠款总额也很重要。对于房屋贷款剩余还款金额也是如此。\n另一方面，某人自出生以来的餐厅支出总额并不特别感兴趣。对于这个账户，我们可能关心的是在特定时间段内发生的餐厅支出金额。例如，“上个月你在餐馆花了多少钱？”或者上季度、去年等。同样地，某人几年前开始在公司工作以来所获得的总薪资收入并不重要。但我们会关心一个税务年度内所赚取的总收入，因为它用于向税务部门报告自己的收入。\n在某一时间点上余额有意义的账户称为资产负债表账户。这类账户分为两种类型：\n“资产 （Assets）” 和 “负债 （Liabilities）”。\n另外一些账户，也就是那些余额并不特别重要但我们有兴趣计算一段时间内变化的账户被称为\n损益表账户。同样地，它们分为两种：“收入 （Income）” 和 “支出 （Expenses）”。\n普通符号。其次，我们考虑账户余额的常规标记。复式记账法绝大多数账户的余额往往具有始终为正或始终为负的符号（尽管如前所述，一个账户的余额可能会改变符号）。这就是我们将区分上述几对帐户的方式：\n对于资产负债表账户，资产通常具有正余额，而负债通常具有负余额。\n对于损益表账户，支出通常具有正余额，而收入通常具有负余额。\n总结为以下表格：\n余额：正（+） 余额：负（-） 在某一时间点上余额数额很重要（资产负债表） 资产Assets 负债Liabilities 随着时间的推移余额变化很重要（损益表） 支出Expenses 收入Income 让我们讨论每种类型的账户并提供一些案例，这样它就不会太抽象。\n资产 （Assets +） 资产账户代表所有者拥有的东西。一个典型的例子是银行账户。另一个例子是“现金 （Cash） ”账户，它记录你钱包里有多少钱。投资也是资产（在这种情况下，它们的单位不是美元，而是某些共同基金或股票的一定数量份额）。最后，如果你拥有一所房屋，则该房屋本身被视为一项资产（其市场价值随时间波动）。\n负债 （Liabilities -） 负债账户代表所有者所欠的东西。最常见的例子是信用卡。同样，银行提供的对账单会显示正数，但从你自己的角度来看，它们是负数。贷款也是一种负债账户。例如，如果你在房屋上抵押了一笔抵押贷款，则这是你欠下的钱，并通过一个带有负金额的帐户来跟踪。随着每个月偿还按揭付款，这个数字会增加（即其绝对值随时间变小而变小，例如 -120,000 \u0026gt; -117,345）。\n支出 （Expenses +） 支出账户代表你已经收到的某些东西，可能是通过交换其他物品来购买的。这种类型的账户似乎很自然：食物、饮料、服装、租金、航班、酒店和大多数其他通常支配收入所花费的类别。然而，税款也通常由一个支出账户跟踪：当你获得一些工资收入时，源头扣除的税款金额会立即记录为一笔支出。把它看作是支付你在整年中享受到的政府服务。\n收入 （Income -） 收入账户用于计算你为了获得其他东西（通常是资产或费用）而放弃的某些东西的价值。对于大多数有工作的人来说，这就是他们时间的价值（薪水收入）。具体来说，在这里我们谈论的是总收入。例如，如果你每年赚取 12 万美元的薪水，那个数字就是 12 万美元，而不是支付税款后剩余的金额。其他类型的收入包括从投资中获得的股息或债券利息支出等。还有一些奇怪的事情可以被记录为收入，比如从信用卡返现或某人送给你礼物等所得到回报价值。\n在 Beancount 中，所有的账户名称都必须与之前描述过的账户类型之一相关联。由于一个账户的类型在其生命周期内永远不会改变，因此我们将其类型作为前缀，并按照惯例将其作为帐户名称的一部分。例如，餐厅的合格帐户名称将是 Expenses:Restaurant。对于银行支票账户，合格帐户名称将是 Assets:Checking。\n除此之外，你可以为你的账户选择任何喜欢的名称。你可以创建尽可能多的账户，并且正如我们稍后将看到的那样，你可以按层次结构组织它们。截至本文撰写时，我使用了超过 700 个账户来跟踪我的个人交易。\n现在让我们回顾一下我们的例子，并添加更多账户：\n假设还有更多的交易：\n… 甚至更多：\n最后，我们可以通过在账户名称前加上类型来为这些账户中的每一个标记出四种不同的账户类型：\n一个追踪个人交易的真实账本可能每年包含数千笔交易。但原则仍然简单且相同：在一段时间内将记账应用于账户，并必须将其归属到交易中，在此交易中，所有记账的总和为零。\n当你为一组账户记账时，实质上是在描述所有帐户随时间发生的所有记账，受规则约束。你正在创建这些记账的数据库。你正在 “记账”，即传统意义上所有交易的账本。有些人称之为 “维护日志”。\n我们现在将把注意力转向从这些数据中获取有用信息，总结账本中的信息。\n试算平衡表 （Trail Balance） 以我们上一个例子为例：我们可以轻松地重新排列所有账户，使得所有资产账户出现在顶部，然后是所有负债账户、收入账户和最后是支出账户。我们只是改变了顺序而没有修改交易结构，以便将每种类型的帐户分组在一起：\n我们重新排列了账户，资产账户位于顶部分组，然后是负债账户，接着是一些权益 （Equity）账户（我们刚刚引入这个账户，更多内容将在后面讨论），然后是收入和最后底部的支出。\n如果我们将所有账户的记账汇总，并仅呈现账户名称及在右侧的最终余额，我们就可以得到一份报告，称为 “试算平衡表 （Trial balance）”。\n这仅仅反映了特定时间点上每个账户的余额。由于每个账户最初都是零余额，并且每笔交易本身也有一个零余额，因此我们知道所有这些余额的总和必须等于零 1。这是我们限制每次记账都必须作为一笔交易的结果，以及确保每笔交易都有相互抵消的记账所导致的。\n损益表 （Income Statement） 从交易列表中提取的一种常见信息是特定时间段内收入账户变化的摘要。这告诉我们在此期间赚了多少钱和花了多少钱，差额告诉我们产生了多少利润（或亏损）。称为 “净收入 （Net income）”。\n为了生成这个摘要，我们只需关注收入和支出类型的账户余额，仅汇总特定期间的交易，并将收入余额绘制在左侧，支出余额绘制在右侧：\n重要提示：这里的收入数字是负数，支出数字是正数。因此，如果你赚的比花费多（一个好结果），最终的收入 + 支出余额总和将为负数。像任何其他收入一样，净收入有一个负数意味着相应数量的资产和/或负债是正数（这对你有利）。\n一个损益表告诉我们在特定时间段内发生了什么变化。公司通常每季度向投资者和公众（如果它们是上市公司）报告这些信息，以分享他们能够赚取多少利润。个人通常会在其年度纳税申报中报告此类信息。\n清算收入 （Clearing Income） 注意在损益表中，只有特定时间间隔内的交易被汇总。这使得我们可以计算出一年内所有收入的总和。如果我们将自账户创建以来的所有交易相加，就可以得到自账户创建以来所获得的全部收入。\n实现同样效果的更好方法是将收入和支出账户的余额清零。Beancount 将此基本转换称为 “清算 （Clearing）2“。它通过以下方式进行：\n从时间开始到报告期开始计算这些账户的余额。例如，如果你在 2000 年创建了你的账户，并且想要为 2016 年生成一份收入报表，那么你需要将 2000 年至 2016 年 1 月 1 日之间的余额汇总。\n将交易插入以清空这些余额并将它们转移到不是收入也不是支出的其他帐户。例如，如果餐厅支出账户在那 16 年中总计为 85,321 美元，则会插入一笔金额为 -85,321 的交易到餐厅，并向 “上期收益 （Previous earnings）” 添加 +85,321 美元。这些交易日期应为 2016 年 1 月 1 日。包括此交易，在该日期该账户的总和将为零。这就是我们想要的。\n所有收入账户插入的交易如下图绿色所示。现在将整个交易相加到总账末尾，只会得出 2016 年期间的变化，因为当时余额为零：\n这就是 bean-query shell 中的 CLEAR 操作的语义。\n（请注意，对于损益表账户实现相同目的的另一种方法是仅针对清算日期后的交易进行金额分离和计数；但是，联合报告损益表账户和资产负债表账户将导致资产负债表账户出现错误余额。）\n股权 （Equity） 接收先前累计收入的帐户称为 “上期收益 （Previous earnings） ”。它位于第五种也是最后一种类型的账户中：股权 （Equity）。我们之前没有讨论过这种类型的账户，因为它们通常只用于转移金额以建立报告，并且所有者通常不会对这些类型账户的更改进行记账；软件会自动执行此操作，例如在结算净收入时。\n“股权” 账户类型用于保存所有过去活动所涉及的净收入总结。这样做的目的是，如果我们现在将资产、负债和股权账户列在一起，因为收入和支出账户已经清零，所有这些余额的总和应该恰好等于零。而对所有股权账户求和明确告诉我们，在实体中我们持有多少份额，换句话说，如果你用资产来支付所有负债，企业还剩下多少，价值是多少。\n请注意，股权账户的正常符号为负数。这并没有特别的含义，只是它们用于抵消资产和负债，如果所有者有任何价值，则该数字应为负数。（负股权意味着一些积极净值。）\n这些是在 Beancount 中使用的一些不同的权益账户：\n上期收益 （Previous Earnings）或留存收益 （Retained Earnings）。这是一个账户，用于保存从时间开始到报告期开始的总收入和支出余额。这就是我们在上一节中提到的账户。\n当前收益 （Current Earnings），也称为净收入 （Net Income）。这是一个账户，用于包含报告期间发生的收入和支出余额之和。在报告期结束时，“清算”收入和支出账户后填写。\n期初余额 （Opening Balances）。一种股权账户，抵消用于初始化账户的存款。当我们截断过去的交易历史记录，但也需要确保一个帐户的余额以特定金额开始其历史时，就会使用此类帐户。\n再次强调：你不需要定义或使用这些账户，因为它们是为了总结交易而创建的。通常情况下，这些账户由上述清算过程填写，或者通过 Pad 指令填写到 “期初余额” 股权账户中，以记录过去的汇总余额。它们由软件自动创建和填充。在接下来的章节中我们将看到如何使用它们。\n资产负债表 （Balance Sheet） 另一种摘要是列出所有账户的所有者资产和债务清单。这回答了一个问题：“钱在哪里？”理论上，我们可以只关注资产和负债账户，并将其编制成报告：\n然而，在实践中，还有一个紧密相关的问题会出现，并且通常同时回答：“一旦所有债务都偿清，我们剩下多少钱？”这被称为净资产价值 （Net worth）【译者注：简称净值】。\n如果收入和支出账户已经清零，并且它们的余额已转移到股权账户，则净值应等于所有股权账户的总和。因此，在编制资产负债表时，习惯上要清除净收益，然后显示股权账户的余额。报告如下：\n请注意，资产负债表可以在任何时间点绘制，只需截断特定日期后的交易列表即可。资产负债表显示某个日期的余额快照；而利润表显示两个日期之间这些余额的差异。\n总结 将过去的交易历史总结为一个等效存款是很有用的。例如，如果我们对 2016 年某个账户的交易感兴趣，该账户在 2016 年 1 月 1 日时余额为 450 美元，则可以删除所有以前的交易，并用一笔单独的交易替换它们，在 2015 年 12 月 31 日存入 450 美元并从其他地方取出。\n那个地方将是股权账户的期初余额。首先，我们可以为所有资产和负债账户（请参见蓝色交易）执行此操作：\n然后我们删除所有在开户日期之前的交易，以获得一个截断的交易列表：\n当我们专注于特定时间间隔的交易时，这是一个有用的操作。\n（这是一些实现细节：这些操作与 Beancount 的设计有关。为了避免使用参数进行所有报告操作，它的所有报告程序都被简化，替代为在整个交易流上运行；通过这种方式，我们将交易列表转换为仅包含要报告的数据。在本例中，汇总只是一个接受完整交易集并返回等效截断流的转换。然后，可以从此交易流中生成不包括过去交易的记账。从程序设计的角度来看，这是很有吸引力的，因为程序的唯一状态是交易流，而且它永远不会直接被修改。这很简单和健壮。）\n期间报告 （Period Reporting） 现在我们知道，通过清算和仅查看收入和支出账户可以制作一份一段时间内的变动报告（损益表）。 我们还知道，可以进行结算以在任何时间点生成资产、负债和所有者权益的快照（资产负债表）。\n更一般地说，我们有兴趣检查一个特定的时间段。这意味着需要一个收入报表，还需要两个资产负债表：期初资产负债表和期末资产负债表。\n为了做到这一点，我们采用以下转换：\n开户 （Open）。我们首先在期初清算净收入，将所有以前的收入余额转移至股权上期收益账户。然后我们总结到期初。我们称清算 + 总结的组合为 “开户”。\n结帐 （Close）。我们还会截断报告期结束后的所有交易。我们称这个操作为 “结账”。\n这是 bean-query shell 3 的 “OPEN” 和 “CLOSE” 操作的含义。最终的交易集应该如下所示。\n“结帐” 包括两个步骤。首先，我们会移除所有在结束日期之后的交易：\n我们可以处理这一笔交易流来生成该期间的损益表。\n然后，在所需报告的结束日期再次进行结算，但这次我们将净收入结算到 Equity:Earnings:Current 账户：\n从这些交易中，我们在期末制作资产负债表。\n这概括了使用 Beancount 准备交易流以生成报告的操作，以及对这些类型报告的基本介绍。\n账户表 新用户经常会想知道他们在账户名称中应该使用多少细节。例如，是否应该在账户名称本身中包含收款人，就像这些示例一样？\nExpenses:Phone:Mobile:VerizonWireless Assets:AccountsReceivable:Clients:AcmeInc 或者应该使用更简单的名称，而依靠“收款人”、“标签”或其他元数据来分组记账？\nExpenses:Phone Assets:AccountsReceivable 答案是取决于你。这是一个任意的选择。这是个品味问题。我个人喜欢滥用账户名并创建长而具有描述性的名称，其他人则更喜欢保持简单，并使用标签来分组他们的记账。有时候甚至不需要过滤记账的子分组。没有正确答案，这取决于你想做什么。\n需要记住的一点是，账户名称隐含地定义了一个层次结构。某些报告代码会解释 “:” 分隔符以创建内存树，并允许你折叠节点的子帐户并计算父级上的聚合值。将其视为一种额外的分组方式。\n国家-机构 约定 我想出了一个对我的资产、负债和收入账户非常有效的约定，即以该账户所在国家的代码为根，后跟相应机构的简短字符串。在此之下，是该机构中特定账户的唯一名称。就像这样：\n\u0026lt;type\u0026gt; : \u0026lt;country\u0026gt; : \u0026lt;institution\u0026gt; : \u0026lt;account\u0026gt; 例如：可以选择将支票账户命名为 Assets:US:BofA:Checking ，其中 “BofA” 代表 “Bank of America“（美国银行）。信用卡账户可以包括特定类型的卡名称作为账户名称，比如 Liabilities:US:Amex:Platinum ，如果你有多张卡片，则这样做很有用。\n我发现对于支出账户来说，使用这种方案并不合理，因为它们往往代表着通用类别。对于这些账户，按照类别分组似乎更有意义，例如使用 Expenses:Food:Restaurant 而不是仅仅使用 Expenses:Restaurant。\n无论如何，Beancount 除了根账户外不强制执行任何规定；这只是一个建议，这个约定在软件中没有编码。你有很大的自由来尝试实验，并且可以通过处理文本文件轻松更改所有名称。请参阅食谱（Cookbook）以获取更多实用指南。\n贷方和借方 （Credits \u0026amp; Debits） 目前为止，我们还没有讨论 “借方 （Credits）” 和 “贷方 （Debits）” 的概念。这是有意的：Beancount 基本上摒弃了这些概念，因为它使其他所有事情变得更简单。我认为仅需学习收入、负债和权益账户的符号通常是负数，并以相同方式处理所有账户比使用借方和贷方术语并对不同类别的账户进行不同处理要简单得多。无论如何，本节将解释这些内容。\n正如我在之前的章节中指出的那样，我们认为收入、负债和权益账户通常具有负余额。这听起来可能很奇怪；毕竟，没有人会把他们的总薪水看作是一个负数，当然你的信用卡账单或抵押贷款报表也会报告正数。这是因为在我们的复式记账系统中，我们认为所有账户都从持有人的角度进行持有。我们使用与此角度一致的符号，因为它使得对帐户内容进行所有操作变得简单：它们只是简单地加法，并且所有帐户都被同等对待。\n相比之下，会计师传统上将其账户的所有余额保持为正数，并根据应用于哪种类型的账户而以不同方式处理对这些账户的过帐。要应用于每个账户的符号完全由其类型决定：资产和费用账户是借方(debit)账户，而负债、权益和收入账户是贷方 （Credit） 账户并需要进行符号调整。此外，在一个帐户上记账正金额称为“借记【译者注：可以理解为扣款】”，从一个帐户中删除则称为“贷记【译者注：可以理解为入账】”。例如，请参阅此外部文档，几乎让我头痛欲裂，而这个最近的主题有更多细节。这种处理过程使一切变得比必须复杂得多。\n这种方法的问题在于，对交易中各个记账金额进行求和不再是一个简单的加法。例如，假设你正在创建一笔新交易，并向两个资产账户、一个支出账户和一个收入账户记帐，系统告诉你有 9.95 美元的差错。你盯着记录看了半天；哪个记账太小了？还是其中一个记账太大了？此外，也许需要添加新的记账，但它应该记到借方账户还是贷方账户呢？这需要进行繁琐的心理运算。一些双重会计软件试图通过为借方和贷方分别创建列，并允许用户仅在与每个记帐类型相对应的列中输入金额来处理此类问题。这可以在视觉上提供帮助，但为什么不直接使用符号呢？\n此外，当你查看会计公式时，还必须考虑它们的符号。这使得对它们进行转换变得很麻烦，并将本质上是对记账进行简单求和的操作变成了一个复杂混乱、难以理解的过程。\n在纯文本会计中，我们宁愿摆脱这种不方便的负数。我们只使用加法，并学会记住负债、权益和收入账户通常具有负余额。虽然这很不寻常，但更容易理解。如果需要查看仅包含正数的传统报告，则可以在报告代码中触发该操作4，反转符号以将其呈现在输出中。\n会计恒等式 根据前面的部分，我们可以轻松地用有符号的术语表达会计方程。如果，\nA = 所有资产记账之和 L = 所有负债记账之和 X = 所有支出记账之和 I = 所有收入记账之和 E = 所有股权记账之和 我们可以这样：\nA + L + E + X + I = 0 这是由于以下事实导致的：\nsum(all postings) = 0 所有记账的总和 = 0 这是因为每笔交易都被 Beancount 强制保证总和为零：\nfor all transactions t, sum(postings of t) = 0 对于所有的交易 t，t 的所有账目之和等于 0 此外，收入和支出记账的总和是净收入 （NI）：\nNI = X + I 如果我们通过将收入清算到股权留存收益账户来反映总净收入影响，调整股权，则可以得到更新后的股权价值（E\u0026rsquo;）：\nE’ = E + NI = E + X + I 我们有一个简化的会计公式：\nA + L + E\u0026#39; = 0 如果我们调整借方和贷方的符号（参见前一节），并且所有金额都是正数，那么这就变成了熟悉的会计恒等式：\nAssets - Liabilities = Equity 正如你所看到的，总是把数字加起来要容易得多。\n纯文本记账 好的，现在我们理解了这种方法及其在理论上能为我们做些什么。复式记账系统的目的是允许你将发生在各种真实账户中的交易复制到一个单一、统一的系统中，在一个共同的表示下，并从这些数据中提取各种视图和报告。现在让我们把注意力转向如何实践记录这些数据。\n本文介绍了 Beancount，其目的是 “使用文本文件进行复式记账”。Beancount 实现了一个解析器，用于解析简单语法以记录交易和记账。例如交易的语法看起来像这样：\n2016-12-06 * \u0026#34;Biang!\u0026#34; \u0026#34;Dinner\u0026#34; Liabilities:CreditCard -47.23 USD Expenses:Restaurants 你可以在一个文件中写入许多这样的声明，Beancount 将读取它并在内存中创建相应的数据结构。\n验证 （Verification）。在解析完交易后，Beancount 还会验证复式记账法则：它检查所有交易的记账总和是否为零。如果你犯了错误并记录了一个非零余额的交易，则会显示错误。\n余额断言 （Balance Assertions）。Beancount 允许你复制从外部账户声明的余额，例如月度对账单上写的余额。它会处理这些信息并检查输入交易产生的余额是否与声明的余额相匹配。这有助于你轻松地发现和纠正错误。\n插件 （Plugins）。Beancount 允许你构建可以自动化和/或处理输入文件中的交易流的程序。你可以通过编写直接处理交易流的代码来构建自定义功能。\n查询和报告（Querying \u0026amp; Reporting）。它提供了工具来处理交易流，以生成我们在本文中早期讨论过的各种报告。\n还有一些细节，例如 Beancount 允许你跟踪成本基础和进行货币转换，但这就是它的本质。\n表格视角 邮件列表上用户几乎总是提出的关于如何计算或跟踪某些值的问题，其实可以很容易地解决：只需将数据视为一长串行，其中一些需要进行过滤和聚合。如果你考虑到我们最终所做的就是推导这些记账的总和，并且交易和记账的属性允许我们过滤记账的子集，那么它总是变得非常简单。在几乎所有情况下，答案都是找到某种方式来消除对记账进行选择时可能存在歧义性，例如通记账户名称、附加标签、使用某些元数据等。考虑将此数据表示为表格可能会有启发作用。\n假设你有两个表：一个包含每个交易的字段，例如日期和描述，另一个包含每个记账的字段，例如账户、金额和货币，以及对其父交易的引用。表示数据最简单的方法是连接 （Join）这两个表，在每个记账中复制父交易的值。\n比如，这个 Beancount 输入：\n2016-12-04 * \u0026#34;Christmas gift\u0026#34; Liabilities:CreditCard -153.45 USD Expenses:Gifts 2016-12-06 * \u0026#34;Biang!\u0026#34; \u0026#34;Dinner\u0026#34; Liabilities:CreditCard -47.23 USD Expenses:Restaurants 2016-12-07 * \u0026#34;Pouring Ribbons\u0026#34; \u0026#34;Drinks with friends\u0026#34; Assets:Cash -25.00 USD Expenses:Tips 4.00 USD Expenses:Alcohol 可以像这样呈现成一个表格：\nDate Fl Payee Narration Account Number Ccy 2016-12-04 * Christmas gift Liabilities:CreditCard -153.45 USD 2016-12-04 * Christmas gift Expenses:Gifts 153.45 USD 2016-12-06 * Biang! Dinner Liabilities:CreditCard -47.23 USD 2016-12-06 * Biang! Dinner Expenses:Restaurants 47.23 USD 2016-12-07 * Pouring Ribbons Drinks with friends Assets:Cash -25.00 USD 2016-12-07 * Pouring Ribbons Drinks with friends Expenses:Tips 4.00 USD 2016-12-07 * Pouring Ribbons Drinks with friends Expenses:Alcohol 21.00 USD 请注意，每个记账都会复制交易字段的值。这就像常规数据库连接操作一样。记账字段从 “Account” 列开始。（还要注意，此示例表格是简化的；实际上有更多的字段。）\n如果你有一个像这样的连接表，你可以对其进行过滤并汇总任意分组的记账金额。这正是 bean-query 工具允许你执行的操作：你可以在数据上运行与内存表等效的 SQL 查询，并列出如下值：\nSELECT date, payee, number WHERE account = \u0026#34;Liabilities:CreditCard\u0026#34;; 或者像这样聚合持仓：\nSELECT account, sum(position) GROUP BY account; 这个简单的命令会生成试算平衡表。\n请注意，表格表示并不会本质上限制记账总和为零。如果你在 WHERE 子句中始终选择每个匹配交易的所有记账，则可以确保所有记账的最终总和为零。否则，总和可能是其他任何值。这是需要记住的一些事情。\n如果你熟悉 SQL 数据库，你可能会问为什么 Beancount 不直接处理数据以填充现有的数据库系统，这样用户就可以使用那些数据库工具。这其中有两个主要原因：\n报告操作。 为了生成收入报表和资产负债表，需要使用先前描述的清除、打开和关闭操作对交易列表进行预处理。这些操作在数据库查询中实现并不容易，并且依赖于报告本身，理想情况下不需要修改输入数据。我们必须将记账数据加载到内存中，然后运行一些代码。通过解析输入文件，我们已经在执行此操作；数据库步骤是多余的。\n聚和持仓。 虽然在本文档中我们还没有讨论过，但账户的内容可能包含不同类型的商品以及附带成本基础的持仓。这些持仓如何聚合在一起需要实现自定义数据类型，因为它遵循有关持仓如何相互抵消的某些规则（详见《库存工作原理》）。如果要超出仅使用单个货币并忽略成本基础的情况下，在 SQL 数据库中构建这些操作将非常困难。\n这就是为什么 Beancount 提供了一个自定义工具来直接处理和查询其数据的原因：它提供了自己的 SQL 客户端实现，让你可以指定开放和关闭日期，并利用自定义“库存”数据结构创建记账持仓总数。该工具支持 Beancount 核心类型的列：Amount (金额)、Position (持仓) 和 Inventory (仓库) 对象。\n（无论如何，如果你还不信服，Beancount 提供了一种将其内容导出到常规 SQL 数据库系统的工具。如果你愿意，请随意尝试并自行实验。）\n请不要关注这些大数字中的数字，它们是随机生成的，不反映实际情况。我们只对这些图表的结构感兴趣。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n请注意，这与“清算交易”一词无关，后者意味着承认或标记某些交易已经被簿记员查看并检查其正确性。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n请注意，操作与 Beancount 提供的 Open 和 Close 指令无关。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n目前在 Beancount 中还没有提供此功能，但实现起来非常简单。我们只需要倒转负债、收入和权益账户余额即可。最终将提供此功能。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://lexcao.io/zh/posts/double-entry-counting-method/","summary":"\u003cp\u003e翻译自 \u003ca href=\"https://beancount.github.io/docs/the_double_entry_counting_method.html\"\u003e\u003cem\u003eThe Double-Entry Counting Method\u003c/em\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"介绍\"\u003e介绍\u003c/h1\u003e\n\u003cp\u003e本文是一份关于复式记账的简要介绍，从计算机科学家的角度撰写。它试图以尽可能简单的方法解释基础记账，简化会计中通常涉及到的某些特殊性。它也代表了 \u003ca href=\"http://furius.ca/beancount/\"\u003eBeancount\u003c/a\u003e 的工作方式，并且对所有使用纯文本记账的用户都应该适用。\u003c/p\u003e\n\u003cp\u003e请注意，我不是会计师，在编写此文档过程中，我可能使用与传统会计培训教授略有不同或不常见的术语。我给自己授权创造一些新的、甚至是不寻常的东西，以便将这些想法尽可能简单明了地解释给那些对它们不熟悉的人。\u003c/p\u003e\n\u003cp\u003e我认为每个高中生都应该在高中阶段学习复式记账法，因为这是一项极其有用的组织技能，并且我希望这篇文章可以帮助将其知识传播到专业圈以外的领域。\u003c/p\u003e\n\u003ch1 id=\"复式记账的基础\"\u003e复式记账的基础\u003c/h1\u003e\n\u003cp\u003e复式记账法只是一种简单的计数方法，只有一些简单的规则。\u003c/p\u003e\n\u003cp\u003e让我们从定义账户的概念开始。账户是一种可以容纳物品的东西，就像一个袋子。它用于计算和累积物品。让我们画一条水平箭头来直观地表示随着时间推移账户中不断变化的内容：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://beancount.github.io/docs/the_double_entry_counting_method/media/2f37aa3938d599d4783ca9b74965026fba0a3b50.png#center\" alt=\"Untitled\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e左侧，是描述过去，而右侧则是不断增长的时间：现在、未来等。\u003c/p\u003e\n\u003cp\u003e现在，让我们假设账户只能包含一种东西，例如美元。所有的账户都以零美元的空内容开始。我们将称账户中单位数量为账户的 \u003cstrong\u003e余额 （Balance）\u003c/strong\u003e。请注意，它代表了特定时间点上其内容的情况。我会使用一个数字在帐户时间轴上方绘制余额：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://beancount.github.io/docs/the_double_entry_counting_method/media/54633827be99c315dc937778221752b848411ca9.png#center\" alt=\"Untitled\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e账户的内容会随着时间而变化。为了改变账户的内容，我们必须向其添加一些东西。我们将这个添加称为对账户的记账，我会在该账户的时间轴上画一个带圈数字来表示这种变化，例如：向该账户中添加 100 美元：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://beancount.github.io/docs/the_double_entry_counting_method/media/004bc3354eb84bf554a8e5080a21f8d16fc29d82.png#center\" alt=\"Untitled\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e现在，我们可以在记账后绘制更新后的账户余额，并在其后面加上另一个小数字：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://beancount.github.io/docs/the_double_entry_counting_method/media/6281f96c3465982c6bf48fccb302b40f90890311.png#center\" alt=\"Untitled\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e账户加上 100 美元后，余额现在为 100 美元。\u003c/p\u003e\n\u003cp\u003e我们也可以从账户中减去一定金额。例如，我们可以减去 25 美元，这样账户余额就变成了 75 美元：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://beancount.github.io/docs/the_double_entry_counting_method/media/1672e121ec80f8fcdb158bb497e05e6dc809dee5.png#center\" alt=\"Untitled\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e如果我们减去的金额超过账户余额，账户余额也可能变为负数。例如，如果我们从该账户中取出 200 美元，则余额现在变为 -125 美元：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://beancount.github.io/docs/the_double_entry_counting_method/media/862c0b57a35631a52eead2cf8cdd7b5f2a1aa106.png#center\" alt=\"Untitled\"  /\u003e\n\u003c/p\u003e\n\u003cp\u003e账户中包含负数是完全正常的。请记住，我们所做的只是计数。很快我们会看到，有些账户在它们的时间轴上将保持负余额。\u003c/p\u003e\n\u003ch2 id=\"报表-statement\"\u003e报表 （Statement）\u003c/h2\u003e\n\u003cp\u003e值得注意的是，我在前一节中写下的时间线记账与机构为每个客户维护并通常通过邮件发送的纸质账户报表类似：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e时间\u003c/th\u003e\n          \u003cth\u003e描述\u003c/th\u003e\n          \u003cth\u003e金额\u003c/th\u003e\n          \u003cth\u003e余额\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2016-10-02\u003c/td\u003e\n          \u003ctd\u003e…\u003c/td\u003e\n          \u003ctd\u003e100.00\u003c/td\u003e\n          \u003ctd\u003e1100.00\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2016-10-05\u003c/td\u003e\n          \u003ctd\u003e..\u003c/td\u003e\n          \u003ctd\u003e-25.00\u003c/td\u003e\n          \u003ctd\u003e1075.00\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e2016-10-06\u003c/td\u003e\n          \u003ctd\u003e..\u003c/td\u003e\n          \u003ctd\u003e-200.00\u003c/td\u003e\n          \u003ctd\u003e875.00\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e最终结余\u003c/td\u003e\n          \u003ctd\u003e875.00\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e有时候金额栏会被分成两个，一个显示正数，另一个显示负数：\u003c/p\u003e","title":"「翻译」复式记账法 (The Double-Entry Counting Method)"},{"content":"背景 本文是 Spring Data JPA 多条件连表查询 文章的最佳实践总结。\n解决什么问题？ 使用 Spring Data JPA 需要针对多条件进行连表查询的场景不使用原生 SQL 或者 HQL 的时候，仅仅通过 JpaSpecificationExecutor 构造 Specification 动态条件语句来实现类型安全的多条件查询。\n说明 相关上下文背景请前往 前文 了解。 这里再提一下接下来示例会用到的场景：\n三个实体：作者、书、书评。其中，作者与书是一对多的关系，书与书评是一对一的关系（当然书评与读者的评价是一对多的关系，这里省去，仅用一对一来进行演示即可）。\n假设有这样的后台查询条件：作者名称、书的发布时间、书评的评分。（这里每个实体取一个字段进行连表查询演示，其他字段同理）。返回书籍列表以及相关表字段。\n【本文所有代码在此】\n最佳实践 需要 SELECT 查询的字段，通过单独的 Java Bean 进行映射 利用 JPA 的自动实体映射结果集 @EntityGraph 注解标注返回实体需要 Fetch 的字段 无需再手动针对连表进行 fetch，解决 N+1 问题 JOIN ON 查询条件使用 join().on() 拼接 Join\u0026lt;Object, Object\u0026gt; author = root.join(\u0026#34;author\u0026#34;); author.on(cb.equal(author.get(\u0026#34;name\u0026#34;), param.getAuthorName())); WHERE 查询条件使用 query.where() 拼接 query.where(cb.equal(root.get(\u0026#34;publishTime\u0026#34;), param.getBookPublishTime())); 代码示例 针对 Repository 需要 override 已有 findAll 方法，使用 @EntityGraph 注解 使用 @EntityGraph 注解，标注额外属性需要 fetch // BookJoinRepository.java @Repository public interface BookJoinRepository extends JpaRepository\u0026lt;BookJoin, String\u0026gt;, JpaSpecificationExecutor\u0026lt;BookJoin\u0026gt; { @Override @EntityGraph(attributePaths = { \u0026#34;author\u0026#34;, \u0026#34;review\u0026#34; }) Page\u0026lt;BookJoin\u0026gt; findAll(Specification\u0026lt;BookJoin\u0026gt; spec, Pageable pageable); } 针对 Specification WHERE 查询条件使用 query.where() 拼接 JOIN ON 查询条件使用 join().on() 拼接 static Specification\u0026lt;BookJoin\u0026gt; multiQuery_04(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { if (null != param.getBookPublishTime()) { query.where(cb.equal(root.get(\u0026#34;publishTime\u0026#34;), param.getBookPublishTime())); } if (null != param.getAuthorName()) { Join\u0026lt;Object, Object\u0026gt; author = root.join(\u0026#34;author\u0026#34;); author.on(cb.equal(author.get(\u0026#34;name\u0026#34;), param.getAuthorName())); } if (null != param.getReviewScore()) { Join\u0026lt;Object, Object\u0026gt; review = root.join(\u0026#34;review\u0026#34;); review.on(cb.equal(review.get(\u0026#34;score\u0026#34;), param.getReviewScore())); } return query.getRestriction(); }; } 结果 SQL 语句 select bookjoin0_.id as id1_1_0_, bookjoin_a1_.id as id1_0_1_, bookjoin_r2_.id as id1_2_2_, bookjoin0_.author_id as author_i3_1_0_, bookjoin0_.publish_time as publish_2_1_0_, bookjoin0_.review_id as review_i4_1_0_, bookjoin_a1_.name as name2_0_1_, bookjoin_r2_.score as score2_2_2_ from book bookjoin0_ inner join author bookjoin_a1_ on bookjoin0_.author_id = bookjoin_a1_.id and (bookjoin_a1_.name = ?) inner join review bookjoin_r2_ on bookjoin0_.review_id = bookjoin_r2_.id and (bookjoin_r2_.score = ?) where bookjoin0_.publish_time = ? limit ? 当然，这里案例使用的是 INNER JOIN，对于 LEFT JOIN 也是生效的。\nJoin\u0026lt;Object, Object\u0026gt; author = root.join(\u0026#34;author\u0026#34;, JoinType.LEFT); author.on(cb.equal(author.get(\u0026#34;name\u0026#34;), param.getAuthorName())); // left outer join author bookjoin_a1_ on // bookjoin0_.author_id = bookjoin_a1_.id // and (bookjoin_a1_.name = ?) 链接 Spring Data JPA 多条件连表查询 Add annotation which will automatically add join fetch to query ","permalink":"https://lexcao.io/zh/posts/spring-data-jpa-join-table-best-practice/","summary":"\u003ch1 id=\"背景\"\u003e背景\u003c/h1\u003e\n\u003cp\u003e本文是 \u003ca href=\"/zh/posts/spring-data-jpa-join-table\"\u003eSpring Data JPA 多条件连表查询\u003c/a\u003e 文章的最佳实践总结。\u003c/p\u003e\n\u003ch3 id=\"解决什么问题\"\u003e解决什么问题？\u003c/h3\u003e\n\u003cp\u003e使用 Spring Data JPA 需要针对多条件进行连表查询的场景不使用原生 SQL 或者 HQL 的时候，仅仅通过 JpaSpecificationExecutor\u003cT\u003e 构造 Specification\u003cT\u003e 动态条件语句来实现类型安全的多条件查询。\u003c/p\u003e\n\u003ch3 id=\"说明\"\u003e说明\u003c/h3\u003e\n\u003cp\u003e相关上下文背景请前往 \u003ca href=\"/zh/posts/spring-data-jpa-join-table\"\u003e前文\u003c/a\u003e 了解。\n这里再提一下接下来示例会用到的场景：\u003c/p\u003e\n\u003cp\u003e三个实体：作者、书、书评。其中，作者与书是一对多的关系，书与书评是一对一的关系（当然书评与读者的评价是一对多的关系，这里省去，仅用一对一来进行演示即可）。\u003c/p\u003e\n\u003cp\u003e假设有这样的后台查询条件：作者名称、书的发布时间、书评的评分。（这里每个实体取一个字段进行连表查询演示，其他字段同理）。返回书籍列表以及相关表字段。\u003c/p\u003e\n\u003cp\u003e【\u003ca href=\"https://github.com/lexcao/spring-data-jpa-join-table\"\u003e本文所有代码在此\u003c/a\u003e】\u003c/p\u003e\n\u003ch1 id=\"最佳实践\"\u003e最佳实践\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e需要 \u003ccode\u003eSELECT\u003c/code\u003e 查询的字段，通过单独的 Java Bean 进行映射\n\u003cul\u003e\n\u003cli\u003e利用 JPA 的自动实体映射结果集\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@EntityGraph\u003c/code\u003e 注解标注返回实体需要 Fetch 的字段\n\u003cul\u003e\n\u003cli\u003e无需再手动针对连表进行 \u003ccode\u003efetch\u003c/code\u003e，解决 N+1 问题\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eJOIN ON 查询条件使用 \u003ccode\u003ejoin().on()\u003c/code\u003e 拼接\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eJoin\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eObject, Object\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e author \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e root.\u003cspan style=\"color:#a6e22e\"\u003ejoin\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;author\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eauthor.\u003cspan style=\"color:#a6e22e\"\u003eon\u003c/span\u003e(cb.\u003cspan style=\"color:#a6e22e\"\u003eequal\u003c/span\u003e(author.\u003cspan style=\"color:#a6e22e\"\u003eget\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e), param.\u003cspan style=\"color:#a6e22e\"\u003egetAuthorName\u003c/span\u003e()));\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003eWHERE 查询条件使用 \u003ccode\u003equery.where()\u003c/code\u003e 拼接\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003equery.\u003cspan style=\"color:#a6e22e\"\u003ewhere\u003c/span\u003e(cb.\u003cspan style=\"color:#a6e22e\"\u003eequal\u003c/span\u003e(root.\u003cspan style=\"color:#a6e22e\"\u003eget\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;publishTime\u0026#34;\u003c/span\u003e), param.\u003cspan style=\"color:#a6e22e\"\u003egetBookPublishTime\u003c/span\u003e()));\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"代码示例\"\u003e代码示例\u003c/h1\u003e\n\u003ch2 id=\"针对-repository\"\u003e针对 Repository\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e需要 \u003ccode\u003eoverride\u003c/code\u003e 已有 \u003ccode\u003efindAll\u003c/code\u003e 方法，使用 \u003ccode\u003e@EntityGraph\u003c/code\u003e 注解\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003e@EntityGraph\u003c/code\u003e 注解，标注额外属性需要 fetch\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// BookJoinRepository.java\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e@Repository\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eBookJoinRepository\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eextends\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    JpaRepository\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eBookJoin, String\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e, JpaSpecificationExecutor\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eBookJoin\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003e@Override\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003e@EntityGraph\u003c/span\u003e(attributePaths \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e { \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;author\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;review\u0026#34;\u003c/span\u003e })\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Page\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eBookJoin\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efindAll\u003c/span\u003e(Specification\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eBookJoin\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e spec, Pageable pageable);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"针对-specification\"\u003e针对 Specification\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eWHERE 查询条件使用 \u003ccode\u003equery.where()\u003c/code\u003e 拼接\u003c/li\u003e\n\u003cli\u003eJOIN ON 查询条件使用 \u003ccode\u003ejoin().on()\u003c/code\u003e 拼接\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003estatic\u003c/span\u003e Specification\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eBookJoin\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emultiQuery_04\u003c/span\u003e(BookJoinQuery param) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e (root, query, cb) \u003cspan style=\"color:#f92672\"\u003e-\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003enull\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e param.\u003cspan style=\"color:#a6e22e\"\u003egetBookPublishTime\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            query.\u003cspan style=\"color:#a6e22e\"\u003ewhere\u003c/span\u003e(cb.\u003cspan style=\"color:#a6e22e\"\u003eequal\u003c/span\u003e(root.\u003cspan style=\"color:#a6e22e\"\u003eget\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;publishTime\u0026#34;\u003c/span\u003e), param.\u003cspan style=\"color:#a6e22e\"\u003egetBookPublishTime\u003c/span\u003e()));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003enull\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e param.\u003cspan style=\"color:#a6e22e\"\u003egetAuthorName\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            Join\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eObject, Object\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e author \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e root.\u003cspan style=\"color:#a6e22e\"\u003ejoin\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;author\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            author.\u003cspan style=\"color:#a6e22e\"\u003eon\u003c/span\u003e(cb.\u003cspan style=\"color:#a6e22e\"\u003eequal\u003c/span\u003e(author.\u003cspan style=\"color:#a6e22e\"\u003eget\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e), param.\u003cspan style=\"color:#a6e22e\"\u003egetAuthorName\u003c/span\u003e()));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003enull\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e param.\u003cspan style=\"color:#a6e22e\"\u003egetReviewScore\u003c/span\u003e()) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            Join\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eObject, Object\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e review \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e root.\u003cspan style=\"color:#a6e22e\"\u003ejoin\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;review\u0026#34;\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            review.\u003cspan style=\"color:#a6e22e\"\u003eon\u003c/span\u003e(cb.\u003cspan style=\"color:#a6e22e\"\u003eequal\u003c/span\u003e(review.\u003cspan style=\"color:#a6e22e\"\u003eget\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;score\u0026#34;\u003c/span\u003e), param.\u003cspan style=\"color:#a6e22e\"\u003egetReviewScore\u003c/span\u003e()));\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e query.\u003cspan style=\"color:#a6e22e\"\u003egetRestriction\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    };\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"结果-sql-语句\"\u003e结果 SQL 语句\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eselect\u003c/span\u003e bookjoin0_.id           \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e id1_1_0_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       bookjoin_a1_.id         \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e id1_0_1_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       bookjoin_r2_.id         \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e id1_2_2_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       bookjoin0_.author_id    \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e author_i3_1_0_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       bookjoin0_.publish_time \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e publish_2_1_0_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       bookjoin0_.review_id    \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e review_i4_1_0_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       bookjoin_a1_.name       \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e name2_0_1_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       bookjoin_r2_.score      \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e score2_2_2_\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efrom\u003c/span\u003e book bookjoin0_\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#66d9ef\"\u003einner\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ejoin\u003c/span\u003e author bookjoin_a1_ \u003cspan style=\"color:#66d9ef\"\u003eon\u003c/span\u003e bookjoin0_.author_id \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e bookjoin_a1_.id \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                      \u003cspan style=\"color:#66d9ef\"\u003eand\u003c/span\u003e (bookjoin_a1_.name \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       \u003cspan style=\"color:#66d9ef\"\u003einner\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ejoin\u003c/span\u003e review bookjoin_r2_ \u003cspan style=\"color:#66d9ef\"\u003eon\u003c/span\u003e bookjoin0_.review_id \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e bookjoin_r2_.id \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                      \u003cspan style=\"color:#66d9ef\"\u003eand\u003c/span\u003e (bookjoin_r2_.score \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ewhere\u003c/span\u003e bookjoin0_.publish_time \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003elimit\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e?\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当然，这里案例使用的是 \u003ccode\u003eINNER JOIN\u003c/code\u003e，对于 \u003ccode\u003eLEFT JOIN\u003c/code\u003e 也是生效的。\u003c/p\u003e","title":"Spring Data JPA 多条件连表查询最佳实践"},{"content":"痛点 项目中使用 Spring Data JPA 作为 ORM 框架的时候，实体映射非常方便。Spring Data Repository 的顶层抽象完全解决单实体的查询，面对单实体的复杂查询，也能使用 JpaSpecificationExecutor\u0026lt;T\u0026gt; 构造 Specification\u0026lt;T\u0026gt; 轻松应对。\n而对于后台管理报表查询需求来说，需要进行连表多条件动态查询的时候，就显得无从下手。因为它并不像 MyBatis 一样能够在 XML 文件中写出动态 SQL 语句。\n尽管可以使用 EntityManager 动态拼接原生 SQL 语句，但是该方法返回值为 ResultSet ，也就是说查出来的实体映射关系需要手动映射（😢这样不太优雅，已经定义出实体，还需要自己去映射）。\n所以，本文的目的是，在现有实体关系的基础上，结合 Specification\u0026lt;T\u0026gt; 记录下 Spring Data JPA 多条件动态连表查询操作，以及其中的踩坑和优化。\n想要直接看结论的，请看这篇 Spring Data JPA 动态多条件连表查询最佳实践。\n基础操作 那么，让我们开始进入代码操作。【本文所有代码在此】\n前置说明 相关依赖 Java 11 SpringBoot 2.4.2 build.gradle\nplugins { id \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;2.4.2\u0026#39; id \u0026#39;io.spring.dependency-management\u0026#39; version \u0026#39;1.0.11.RELEASE\u0026#39; id \u0026#39;java\u0026#39; } dependencies { implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39; compileOnly \u0026#39;org.projectlombok:lombok\u0026#39; runtimeOnly \u0026#39;mysql:mysql-connector-java\u0026#39; annotationProcessor \u0026#39;org.projectlombok:lombok\u0026#39; testImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39; testRuntimeOnly \u0026#39;com.h2database:h2\u0026#39; } maven.xml\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 模拟场景 三个实体：作者、书、书评。其中，作者与书是一对多的关系，书与书评是一对一的关系（当然书评与读者的评价是一对多的关系，这里省去，仅用一对一来进行演示即可）。\n假设有这样的后台查询条件：作者名称、书的发布时间、书评的评分。（这里每个实体取一个字段进行连表查询演示，其他字段同理）。返回书籍列表以及相关表字段。\n实体关系 表结构 CREATE TABLE `author` ( `id` VARCHAR(255) PRIMARY KEY, `name` VARCHAR(255) ); CREATE TABLE `book` ( `id` VARCHAR(255) PRIMARY KEY, `publish_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP, `author_id` VARCHAR(255), `review_id` VARCHAR(255) ); CREATE TABLE `review` ( `id` VARCHAR(255) PRIMARY KEY, `score` INT ); -- 数据初始化 INSERT INTO `author` (`id`, `name`) VALUES (\u0026#39;A_1\u0026#39;, \u0026#39;Author_1\u0026#39;), (\u0026#39;A_2\u0026#39;, \u0026#39;Author_2\u0026#39;), (\u0026#39;A_3\u0026#39;, \u0026#39;Author_3\u0026#39;), (\u0026#39;A_4\u0026#39;, \u0026#39;Author_4\u0026#39;), (\u0026#39;A_5\u0026#39;, \u0026#39;Author_5\u0026#39;); INSERT INTO `review` (`id`, `score`) VALUES (\u0026#39;R_1\u0026#39;, 20), (\u0026#39;R_2\u0026#39;, 30), (\u0026#39;R_3\u0026#39;, 40), (\u0026#39;R_4\u0026#39;, 50), (\u0026#39;R_5\u0026#39;, 60), (\u0026#39;R_6\u0026#39;, 70), (\u0026#39;R_7\u0026#39;, 80), (\u0026#39;R_8\u0026#39;, 90); INSERT INTO `book` (`id`, `author_id`, `review_id`) VALUES (\u0026#39;B_1\u0026#39;, \u0026#39;A_1\u0026#39;, \u0026#39;R_1\u0026#39;), (\u0026#39;B_2\u0026#39;, \u0026#39;A_2\u0026#39;, \u0026#39;R_2\u0026#39;), (\u0026#39;B_3\u0026#39;, \u0026#39;A_3\u0026#39;, \u0026#39;R_3\u0026#39;), (\u0026#39;B_4\u0026#39;, \u0026#39;A_4\u0026#39;, \u0026#39;R_4\u0026#39;), (\u0026#39;B_5\u0026#39;, \u0026#39;A_5\u0026#39;, \u0026#39;R_5\u0026#39;), (\u0026#39;B_6\u0026#39;, \u0026#39;A_2\u0026#39;, \u0026#39;R_6\u0026#39;), (\u0026#39;B_7\u0026#39;, \u0026#39;A_2\u0026#39;, \u0026#39;R_7\u0026#39;), (\u0026#39;B_8\u0026#39;, \u0026#39;A_3\u0026#39;, \u0026#39;R_8\u0026#39;); JPA 实体关系 使用 Java persistence API 构建如下实体关系，其他业务字段省略。\n@Data @Table @Entity public class Author { @Id private String id; private String name; } @Data @Table @Entity public class Book { @Id private String id; @Column(name = \u0026#34;publish_time\u0026#34;) private LocalDateTime publishTime; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;author_id\u0026#34;, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)) private Author author; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;review_id\u0026#34;, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)) private Review review; } @Data @Table @Entity public class Review { @Id private String id; } 相关解释：\n@Data Lombok 注解，自动生成 getter、setter、hashcode、equals @Table @Entity @Id @Column @JoinColumn 均为 persistence API @ManyToOne 实体映射关系 多对一 @OneToOne 实体映射关系 一对一 在实际业务中，连表的时候不一定是查询多个实体的全部字段，为了不影响原有实体关系的正常映射，这里单独声明一个类 BookJoin 来映射查询条件返回。优雅的实现 Spring Data JPA 连表操作，这样做的好处是：\n只有 SELECT 查询出来的字段，才需要在实体里面声明出来 JOIN ON 后面的条件，需要在实体里面声明出来 再根据 Specification 中的 query.join 来进行 JOIN 以下是连表实体 BookJoin.java 文件\n@Data @Entity @Table(name = \u0026#34;book\u0026#34;) public class BookJoin { @Id private String id; @Column(name = \u0026#34;publish_time\u0026#34;) private LocalDateTime publishTime; @ManyToOne @JoinColumn(name = \u0026#34;author_id\u0026#34;, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)) private Author author; @OneToOne @JoinColumn(name = \u0026#34;review_id\u0026#34;, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)) private Review review; @Data @Entity @Table(name = \u0026#34;author\u0026#34;) public static class Author { @Id private String id; private String name; } @Data @Entity @Table(name = \u0026#34;review\u0026#34;) public static class Review { @Id private String id; private Integer score; } } 构建测试环境 为了演示多条件查询结果，这里使用 JUnit 来进行单元测试\nSpringBoot x JUnit 单元测试更详细的内容，请看另一篇博客\n/** * given: * empty query * then: * paged data */ @Test void multiQuery() { var spec = BookJoinSpec.multiQuery(emptyQuery()); var page = PageRequest.of(0, 5); queryBySpecMethod(spec, page); } private Page\u0026lt;BookJoin\u0026gt; queryBySpecMethod(Specification\u0026lt;BookJoin\u0026gt; spec, PageRequest pageRequest) { var books = repo.findAll(spec, pageRequest); assertThat(books.getNumberOfElements()).isGreaterThan(0); books.getContent().forEach(it -\u0026gt; { assertThat(it).isNotNull(); // 访问结果集的属性，验证是否懒加载 assertThat(it.getAuthor().getName()).isNotNull(); assertThat(it.getReview().getScore()).isNotNull(); } ); return books; } 连表操作 如何进行声明式连表查询，这里讲演示各种写法的不同， 以及各个参数所起的作用，最后会给出一个最终版本作为最佳实践参考。\n01 版本 static Specification\u0026lt;BookJoin\u0026gt; multiQuery_01(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { var predicates = new LinkedList\u0026lt;Predicate\u0026gt;(); root.join(\u0026#34;author\u0026#34;); root.join(\u0026#34;review\u0026#34;); // ... }; } 通过以上的单元测试，打印出的 SQL 如下\nHibernate: SELECT `bookjoin0_`.`id` AS `id1_1_`, `bookjoin0_`.`author_id` AS `author_i3_1_`, `bookjoin0_`.`publish_time` AS `publish_2_1_`, `bookjoin0_`.`review_id` AS `review_i4_1_` FROM `book` `bookjoin0_` INNER JOIN `author` `bookjoin_a1_` ON `bookjoin0_`.`author_id` = `bookjoin_a1_`.`id` INNER JOIN `review` `bookjoin_r2_` ON `bookjoin0_`.`review_id` = `bookjoin_r2_`.`id` WHERE 1 = 1 LIMIT ? OFFSET ? Hibernate: SELECT `bookjoin_a0_`.`id` AS `id1_0_0_`, `bookjoin_a0_`.`name` AS `name2_0_0_` FROM `author` `bookjoin_a0_` WHERE `bookjoin_a0_`.`id` = ? Hibernate: SELECT `bookjoin_r0_`.`id` AS `id1_2_0_`, `bookjoin_r0_`.`score` AS `score2_2_0_` FROM `review` `bookjoin_r0_` WHERE `bookjoin_r0_`.`id` = ? Hibernate: SELECT `bookjoin_r0_`.`id` AS `id1_2_0_`, `bookjoin_r0_`.`score` AS `score2_2_0_` FROM `review` `bookjoin_r0_` WHERE `bookjoin_r0_`.`id` = ? Hibernate: SELECT `bookjoin_a0_`.`id` AS `id1_0_0_`, `bookjoin_a0_`.`name` AS `name2_0_0_` FROM `author` `bookjoin_a0_` WHERE `bookjoin_a0_`.`id` = ? Hibernate: SELECT `bookjoin_r0_`.`id` AS `id1_2_0_`, `bookjoin_r0_`.`score` AS `score2_2_0_` FROM `review` `bookjoin_r0_` WHERE `bookjoin_r0_`.`id` = ? 可以看到：\n数据总共查出来 3 条，结果执行的 SQL 语句有 7 条 分别是：1 条连表查询，3 条 author 表的单查询，3 条 review 表的单查询 02 版本 - 使用 fetch 优化 使用 fetch 替代 join\njoin 仅连表查询，返回的主实体的所有属性，可以理解为 SELECT book.* fetch 连表查询 + 快加载，返回连表所有实体的属性，可以理解为 SELECT * static Specification\u0026lt;BookJoin\u0026gt; multiQuery_02(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { // ... root.fetch(\u0026#34;author\u0026#34;); root.fetch(\u0026#34;review\u0026#34;); // ... }; } 通过以上的单元测试，打印出的 SQL 如下\nHibernate: SELECT `bookjoin0_`.`id` AS `id1_1_0_`, `bookjoin_a1_`.`id` AS `id1_0_1_`, `bookjoin_r2_`.`id` AS `id1_2_2_`, `bookjoin0_`.`author_id` AS `author_i3_1_0_`, `bookjoin0_`.`publish_time` AS `publish_2_1_0_`, `bookjoin0_`.`review_id` AS `review_i4_1_0_`, `bookjoin_a1_`.`name` AS `name2_0_1_`, `bookjoin_r2_`.`score` AS `score2_2_2_` FROM `book` `bookjoin0_` INNER JOIN `author` `bookjoin_a1_` ON `bookjoin0_`.`author_id` = `bookjoin_a1_`.`id` INNER JOIN `review` `bookjoin_r2_` ON `bookjoin0_`.`review_id` = `bookjoin_r2_`.`id` WHERE 1 = 1 LIMIT ? OFFSET ? 可以看到：\n执行的 SQL 只有 1 条 SELECT 中的字段包括连表的字段 踩坑 - 分页问题 创建一个新的单元测试，直接使用 fetch 分页报错\n@Test void multiQuery_02() { var spec = BookJoinSpec.multiQuery_02(emptyQuery()); var page = PageRequest.of(0, 5); assertThatThrownBy(() -\u0026gt; queryBySpecMethod(spec, page)) .hasCauseInstanceOf(QueryException.class); } 当使用 fetch 再进行分页的时候，会报以下错误\nCaused by: org.hibernate.QueryException: query specified join fetching, but the owner of the fetched association was not present in the select list. 原因分析：\n实际报错出现在 count 语句，错误信息表示该 count 语句返回值没有找到具体的映射属性 解决方法：\n针对分页的 count 查询语句单独做处理，代码如下 static Specification\u0026lt;BookJoin\u0026gt; multiQuery_02_fix(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { // ... if (Long.class.equals(query.getResultType()) || long.class.equals(query.getResultType())) { root.join(\u0026#34;author\u0026#34;); root.join(\u0026#34;review\u0026#34;); } else { root.fetch(\u0026#34;author\u0026#34;); root.fetch(\u0026#34;review\u0026#34;); } // ... }; } 注意 可能疑问「上面 BookJoin 实体里面声明关系不是 fetch = FetchType.LAZY ，没有指明是懒加载，为什么连表查询的时候还是没有加载出来」。\n原因是 JPA 里面 join 机制处理，原理大致是这样的：\n根据 join 和 fetch 生成不同的 JpaQL 语句，差别在于 join 与 join fetch -- fetch 生成的 JpaQL 语句 select generatedAlias0 from BookJoin as generatedAlias0 inner join fetch generatedAlias0.author as generatedAlias1 inner join fetch generatedAlias0.review as generatedAlias2 where 1=1 -- join 生成的 JpaQL 语句 select generatedAlias0 from BookJoin as generatedAlias0 inner join generatedAlias0.author as generatedAlias1 inner join generatedAlias0.review as generatedAlias2 where 1=1 JpaQL 语句根据 join fetch 转换为 HQL 再转换为最终的 SQL 语句，通过 QueryTranslatorImpl 类，在 doCompile 方法看到完整转换过程，部分代码如下 // QueryTranslatorImpl // doCompile -\u0026gt; analyze -\u0026gt; HqlSqlBaseWalker.statement -\u0026gt; selectStatement // selectClause -\u0026gt; fromClause -\u0026gt; fromElementList -\u0026gt; fromElement -\u0026gt; joinElement // HqlSqlWalker.java createFromJoinElement #367 // DotNode 此处设置 fetch DotNode dot = (DotNode) path; JoinType hibernateJoinType = JoinProcessor.toHibernateJoinType( joinType ); dot.setJoinType( hibernateJoinType ); // Tell the dot node about the join type. dot.setFetch( fetch ); // Generate an explicit join for the root dot node. The implied joins will be collected and passed up // to the root dot node. dot.resolve( true, false, alias == null ? null : alias.getText() ); // 解析阶段 // selectStatement -\u0026gt; query -\u0026gt; processQuery // 上面的报错在此处 SelectClause.java #212 if ( !fromElementsForLoad.contains( origin ) \u0026amp;\u0026amp; !fromElementsForLoad.contains( fromElement.getFetchOrigin() ) ) throw new QueryException( \u0026#34;query specified join fetching, but the owner \u0026#34; + \u0026#34;of the fetched association was not present in the select list \u0026#34; + \u0026#34;[\u0026#34; + fromElement.getDisplayText() + \u0026#34;]\u0026#34; ); } 03 版本 - 加上 WHERE 条件筛选 创建一个新的单元测试，筛选一下 Join 条件\n@Test void multiQuery_03() { var query = BookJoinQuery.builder() .authorName(\u0026#34;Author_2\u0026#34;) .build(); var spec = BookJoinSpec.multiQuery_03(query); var page = PageRequest.of(0, 5); var result = queryBySpecMethod(spec, page); var givenAuthor = result.getContent().get(0).getAuthor(); assertThat(givenAuthor.getName()).isEqualTo(\u0026#34;Author_2\u0026#34;); } 具体的连表查询条件如下\nstatic Specification\u0026lt;BookJoin\u0026gt; multiQuery_03(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { var predicates = new LinkedList\u0026lt;Predicate\u0026gt;(); if (Long.class.equals(query.getResultType()) || long.class.equals(query.getResultType())) { root.join(\u0026#34;author\u0026#34;); root.join(\u0026#34;review\u0026#34;); } else { root.fetch(\u0026#34;author\u0026#34;); root.fetch(\u0026#34;review\u0026#34;); } if (null != param.getBookPublishTime()) { predicates.add(cb.equal(root.get(\u0026#34;publishTime\u0026#34;), param.getBookPublishTime())); } if (null != param.getAuthorName()) { predicates.add(cb.equal(root.get(\u0026#34;author\u0026#34;).get(\u0026#34;name\u0026#34;), param.getAuthorName())); } if (null != param.getReviewScore()) { predicates.add(cb.equal(root.get(\u0026#34;review\u0026#34;).get(\u0026#34;score\u0026#34;), param.getReviewScore())); } query.where(predicates.toArray(new Predicate[0])); return query.getRestriction(); }; } 生成的查询语句如下，可以看到查询条件是拼接在 WHERE 部分\nselect bookjoin0_.id as id1_1_0_, bookjoin_a1_.id as id1_0_1_, bookjoin_r2_.id as id1_2_2_, bookjoin0_.author_id as author_i3_1_0_, bookjoin0_.publish_time as publish_2_1_0_, bookjoin0_.review_id as review_i4_1_0_, bookjoin_a1_.name as name2_0_1_, bookjoin_r2_.score as score2_2_2_ from book bookjoin0_ inner join author bookjoin_a1_ on bookjoin0_.author_id = bookjoin_a1_.id inner join review bookjoin_r2_ on bookjoin0_.review_id = bookjoin_r2_.id where bookjoin_a1_.name = ? limit ? 如果我想要针对 join 的表进行 on 条件查询，应该怎么做呢？ 下面来看下 04 版本。\n04 版本 - 加上 JOIN ON 条件筛选 创建一个新的单元测试\n@Test void multiQuery_04() { var query = BookJoinQuery.builder() .authorName(\u0026#34;Author_2\u0026#34;) .reviewScore(70) .build(); var spec = BookJoinSpec.multiQuery_04(query); var page = PageRequest.of(0, 5); var bookJoin = queryBySpecMethod(spec, page).getContent().get(0); assertThat(bookJoin.getAuthor().getName()).isEqualTo(\u0026#34;Author_2\u0026#34;); assertThat(bookJoin.getReview().getScore()).isEqualTo(70); } 首先直接对 join 条件进行 on 查询\nstatic Specification\u0026lt;BookJoin\u0026gt; multiQuery_04(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { if (null != param.getBookPublishTime()) { query.where(cb.equal(root.get(\u0026#34;publishTime\u0026#34;), param.getBookPublishTime())); } if (null != param.getAuthorName()) { Join\u0026lt;Object, Object\u0026gt; author = root.join(\u0026#34;author\u0026#34;); author.on(cb.equal(author.get(\u0026#34;name\u0026#34;), param.getAuthorName())); } if (null != param.getReviewScore()) { Join\u0026lt;Object, Object\u0026gt; review = root.join(\u0026#34;review\u0026#34;); review.on(cb.equal(review.get(\u0026#34;score\u0026#34;), param.getReviewScore())); } return query.getRestriction(); }; } 此时生成的 SQL 语句如下，能够成功拼接 JOIN ON 条件但是出现 N + 1 问题，\nselect bookjoin0_.id as id1_1_, bookjoin0_.author_id as author_i3_1_, bookjoin0_.publish_time as publish_2_1_, bookjoin0_.review_id as review_i4_1_ from book bookjoin0_ inner join author bookjoin_a1_ on bookjoin0_.author_id = bookjoin_a1_.id and (bookjoin_a1_.name = ?) inner join review bookjoin_r2_ on bookjoin0_.review_id = bookjoin_r2_.id and (bookjoin_r2_.score = ?) limit ? select bookjoin_a0_.id as id1_0_0_, bookjoin_a0_.name as name2_0_0_ from author bookjoin_a0_ where bookjoin_a0_.id = ? select bookjoin_r0_.id as id1_2_0_, bookjoin_r0_.score as score2_2_0_ from review bookjoin_r0_ where bookjoin_r0_.id = ? 此时如果我们改用 fetch 的话，又不能进行 on 条件筛选，该怎么处理呢？\n这里的解决方案是引入一个新的注解 @EntityGraph，修改我们的查询方法\n主动声明查询方法返回的 Entity 明确需要进行 Fetch 的属性有哪些 @Override @EntityGraph(attributePaths = { \u0026#34;author\u0026#34;, \u0026#34;review\u0026#34; }) Page\u0026lt;BookJoin\u0026gt; findAll(Specification\u0026lt;BookJoin\u0026gt; spec, Pageable pageable); 再看一下生成的语句，很好，自动帮忙 fetch 出来了，并且也解决了 02 版本的分页查询问题\nselect bookjoin0_.id as id1_1_0_, bookjoin_a1_.id as id1_0_1_, bookjoin_r2_.id as id1_2_2_, bookjoin0_.author_id as author_i3_1_0_, bookjoin0_.publish_time as publish_2_1_0_, bookjoin0_.review_id as review_i4_1_0_, bookjoin_a1_.name as name2_0_1_, bookjoin_r2_.score as score2_2_2_ from book bookjoin0_ inner join author bookjoin_a1_ on bookjoin0_.author_id = bookjoin_a1_.id and (bookjoin_a1_.name = ?) inner join review bookjoin_r2_ on bookjoin0_.review_id = bookjoin_r2_.id and (bookjoin_r2_.score = ?) limit ? 注意 上面使用的示例是针对【强一对一关系】所以使用默认的连接类型 INNER JOIN\n当然也可以使用左外连接（右外连接不支持）\nroot.join(\u0026#34;author\u0026#34;, JoinType.LEFT); root.fetch(\u0026#34;author\u0026#34;, JoinType.LEFT); 扩展阅读 Advanced Spring Data JPA - Specifications and Querydsl REST Query Language with Spring Data JPA Specifications Spring Data JPA Specification DSL for Kotlin 🔗 链接 Github source Spring Data JPA使用Specification 👀总结 使用 SpringJPA 来写动态多条件连表查询，通过代码来控制 SQL 语句，需要对 JPA 以及 Hibernate 相关 API 相对熟练才可以写出优质的 SQL 语句生成。 和 MyBatis 可以直接拼接 SQL 的相比，各有应用场景。 整体来说用代码来写 JPA 的动态查询，对于习惯 SQL 语句的人来说，还是感觉隔了一层。 对于这样的分页连表查询，个人感觉还是 MyBatis 舒服一点，简单。 ","permalink":"https://lexcao.io/zh/posts/spring-data-jpa-join-table/","summary":"\u003ch1 id=\"痛点\"\u003e痛点\u003c/h1\u003e\n\u003cp\u003e项目中使用 Spring Data JPA 作为 ORM 框架的时候，实体映射非常方便。Spring Data Repository 的顶层抽象完全解决单实体的查询，面对单实体的复杂查询，也能使用 \u003ccode\u003eJpaSpecificationExecutor\u0026lt;T\u0026gt;\u003c/code\u003e 构造 \u003ccode\u003eSpecification\u0026lt;T\u0026gt;\u003c/code\u003e 轻松应对。\u003c/p\u003e\n\u003cp\u003e而对于后台管理报表查询需求来说，需要进行连表多条件动态查询的时候，就显得无从下手。因为它并不像 MyBatis 一样能够在 XML 文件中写出动态 SQL 语句。\u003c/p\u003e\n\u003cp\u003e尽管可以使用 \u003ccode\u003eEntityManager\u003c/code\u003e 动态拼接原生 SQL 语句，但是该方法返回值为 \u003ccode\u003eResultSet\u003c/code\u003e ，也就是说查出来的实体映射关系需要手动映射（😢这样不太优雅，已经定义出实体，还需要自己去映射）。\u003c/p\u003e\n\u003cp\u003e所以，本文的目的是，在现有实体关系的基础上，结合 \u003ccode\u003eSpecification\u0026lt;T\u0026gt;\u003c/code\u003e 记录下 Spring Data JPA 多条件动态连表查询操作，以及其中的踩坑和优化。\u003c/p\u003e\n\u003cp\u003e想要直接看结论的，请看这篇 \u003ca href=\"/zh/posts/spring-data-jpa-join-table-best-practice\"\u003eSpring Data JPA 动态多条件连表查询最佳实践\u003c/a\u003e。\u003c/p\u003e\n\u003ch1 id=\"基础操作\"\u003e基础操作\u003c/h1\u003e\n\u003cp\u003e那么，让我们开始进入代码操作。【\u003ca href=\"https://github.com/lexcao/spring-data-jpa-join-table\"\u003e本文所有代码在此\u003c/a\u003e】\u003c/p\u003e\n\u003ch2 id=\"前置说明\"\u003e前置说明\u003c/h2\u003e\n\u003ch3 id=\"相关依赖\"\u003e相关依赖\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eJava 11\u003c/li\u003e\n\u003cli\u003eSpringBoot 2.4.2\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ebuild.gradle\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-groovy\" data-lang=\"groovy\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eplugins \u003cspan style=\"color:#f92672\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    id \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;org.springframework.boot\u0026#39;\u003c/span\u003e version \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;2.4.2\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    id \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;io.spring.dependency-management\u0026#39;\u003c/span\u003e version \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;1.0.11.RELEASE\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    id \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;java\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edependencies \u003cspan style=\"color:#f92672\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    implementation \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    compileOnly \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;org.projectlombok:lombok\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    runtimeOnly \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;mysql:mysql-connector-java\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    annotationProcessor \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;org.projectlombok:lombok\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    testImplementation \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    testRuntimeOnly \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;com.h2database:h2\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003emaven.xml\u003c/p\u003e","title":"Spring Data JPA 多条件连表查询 (2022 更新)"},{"content":"什么 我想写一篇关于我如何学习Rust的博客。\n请原谅我在 2022 年才开始学习这个伟大的编程语言。\n为了在实践中学习Rust，我构建了一个全栈待办应用。\n你可以在 这里 尝试。相关源码可以在 GitHub 上找到。\n现在，我准备写一下它是如何构建的。\n如何 首先，和大家一样，我也是从 The Book 中学习 Rust。这是一本不应该跳过入门学习 Rust 的好书。\n在学习了一些基本的语法之后，我尝试从零开始使用 Rust 构建一个全栈应用，这是一个使用 Rust tokio 的后端服务和一个使用 Rust WASM（Web Assembly）的前端页面。\n我将分别对这两部分做一个简单的介绍。\n后端 后台服务是一个的简单的 REST API。使用 actix-web 作为网络框架。\n我将写另一篇博客，介绍我如何使用 TDD 开发 Rust 后台服务。 被 Rust 编译器和 Borrow Checker 教育是一次特别的体验。 对于部署，我使用 Supabase 作为 Postgres 服务，使用 Railway 来运行后台服务 docker 镜像。\n前端 前端页面有在线和离线数据源，在线是从后台服务器获取数据，而离线是在本地存储。并且有一个按钮来切换它们。\n前台由 Rust WASM 和 yew 框架驱动，这是一个类似 React 基于组件构建 Web 应用框架。\n如果你熟悉 JSX，你可以在使用 Yew 时感到很自在。 在 Rust 中编写类似 React 的代码体验良好，而且真的很有趣。 但有一些不同之处我想与大家分享，晚点会写一篇博客来谈这个问题，所以敬请关注。 部署的话，是放在 Vercel 上进行托管，用 GitHub Action 来实现自动部署。\n结果 全栈 Rust 的好处之一是共享代码。通过使用 Cargo workspace 功能后端和前端可以共享这个公共包。其中包含了两边都可以使用的 requests 和 models。后端代码在集成测试的时候进行了测试，所以前端代码可以直接使用它而不需要额外测试和编码。\n整个开发体验的话就是所有 Rust 代码和一些少量 CSS。整体感觉不错。\n非常感谢 Rust 编译器，它是学习 Rust 的一位好老师。\n相关引用 源码 Rust The Book WASM actix-web yew Vercel Railway Supabase ","permalink":"https://lexcao.io/zh/posts/learn-rust-fullstack/","summary":"\u003ch1 id=\"什么\"\u003e什么\u003c/h1\u003e\n\u003cp\u003e我想写一篇关于我如何学习Rust的博客。\u003c/p\u003e\n\u003cp\u003e请原谅我在 2022 年才开始学习这个伟大的编程语言。\u003c/p\u003e\n\u003cp\u003e为了在实践中学习Rust，我构建了一个全栈待办应用。\u003c/p\u003e\n\u003cp\u003e你可以在 \u003ca href=\"https://todos.lexcao.io/\"\u003e这里\u003c/a\u003e 尝试。相关源码可以在 \u003ca href=\"https://github.com/lexcao/rust_fullstack_todo\"\u003eGitHub\u003c/a\u003e 上找到。\u003c/p\u003e\n\u003cp\u003e现在，我准备写一下它是如何构建的。\u003c/p\u003e\n\u003ch1 id=\"如何\"\u003e如何\u003c/h1\u003e\n\u003cp\u003e首先，和大家一样，我也是从 \u003ca href=\"https://doc.rust-lang.org/book/\"\u003eThe Book\u003c/a\u003e 中学习 Rust。这是一本不应该跳过入门学习 Rust 的好书。\u003c/p\u003e\n\u003cp\u003e在学习了一些基本的语法之后，我尝试从零开始使用 Rust 构建一个全栈应用，这是一个使用 Rust tokio 的后端服务和一个使用 \u003ca href=\"https://rustwasm.github.io/docs/book/\"\u003eRust WASM（Web Assembly）\u003c/a\u003e的前端页面。\u003c/p\u003e\n\u003cp\u003e我将分别对这两部分做一个简单的介绍。\u003c/p\u003e\n\u003ch3 id=\"后端\"\u003e后端\u003c/h3\u003e\n\u003cp\u003e后台服务是一个的简单的 REST API。使用 \u003ca href=\"https://github.com/actix/actix-web\"\u003e\u003ccode\u003eactix-web\u003c/code\u003e\u003c/a\u003e 作为网络框架。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我将写另一篇博客，介绍我如何使用 TDD 开发 Rust 后台服务。\u003c/li\u003e\n\u003cli\u003e被 Rust 编译器和 Borrow Checker 教育是一次特别的体验。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于部署，我使用 \u003ca href=\"https://supabase.com/\"\u003eSupabase\u003c/a\u003e 作为 Postgres 服务，使用 \u003ca href=\"https://railway.app/\"\u003eRailway\u003c/a\u003e 来运行后台服务 docker 镜像。\u003c/p\u003e\n\u003ch3 id=\"前端\"\u003e前端\u003c/h3\u003e\n\u003cp\u003e前端页面有在线和离线数据源，在线是从后台服务器获取数据，而离线是在本地存储。并且有一个按钮来切换它们。\u003c/p\u003e\n\u003cp\u003e前台由 Rust WASM 和 \u003ca href=\"https://github.com/yewstack/yew\"\u003e\u003ccode\u003eyew\u003c/code\u003e\u003c/a\u003e 框架驱动，这是一个类似 React 基于组件构建 Web 应用框架。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果你熟悉 JSX，你可以在使用 Yew 时感到很自在。\u003c/li\u003e\n\u003cli\u003e在 Rust 中编写类似 React 的代码体验良好，而且真的很有趣。\u003c/li\u003e\n\u003cli\u003e但有一些不同之处我想与大家分享，晚点会写一篇博客来谈这个问题，所以敬请关注。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e部署的话，是放在 \u003ca href=\"https://vercel.com/\"\u003eVercel\u003c/a\u003e 上进行托管，用 GitHub Action 来实现自动部署。\u003c/p\u003e","title":"通过构建全栈待办应用学习 Rust"},{"content":"通过使用 Kotlin / Java 中 Junit5 和 Mockito 测试框架，在预约功能中演示 TDD 开发流程。\nTDD 介绍 TDD（Test-Driven Development） 是一种开发流程，中文是「测试驱动开发」。用一句白话形容，就是「先写测试再开发」。先写测试除了能确保测试程式的撰写，还有一个好处：有助于在开发初期厘清程式介面如何设计。详细理论知识可以前往 Wiki 了解，这里不再过多介绍。\n测试驱动开发 Test Driven Development TDD 开发流程（5步） 术语说明：\n红灯 - Failure - 测试用例失败 绿灯 - Success - 测试用例成功 重构 - Refactor - 重构功能代码 具体步骤：\n选定一个功能，编写测试用例 执行测试，得到【红灯】 编写满足测试用例的功能代码 再次执行，得到【绿灯】 【重构】代码 小结：\n对于每一个功能，在【红灯】-【绿灯】-【重构】间来回循环往复，不断得到完善。\n前置工作 代码说明 使用 Kotlin 语言（会有相对应的 Java 代码） 使用到的测试框架 Running: JUnit5 Mock: MockK / Mockito Assertion: Kotest / AssertJ 只涉及 TDD 的具体流程，不涉及单元测试如何编写（可以看 SpringBoot 单元测试各层） 功能介绍 假设一个用户预约的场景。\n用户可以创建一个预约 同一个时间点，只有一个用户可以下单成功 使用到的库 kotlin plugins { java id(\u0026#34;io.freefair.lombok\u0026#34;) version \u0026#34;6.0.0-m2\u0026#34; kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;1.5.0-RC\u0026#34; } group = \u0026#34;io.github.lexcao\u0026#34; version = \u0026#34;1.0-SNAPSHOT\u0026#34; repositories { mavenCentral() } dependencies { implementation(kotlin(\u0026#34;stdlib\u0026#34;)) // for Java mocking and assertion testImplementation(\u0026#34;org.mockito:mockito-core:3.9.0\u0026#34;) testImplementation(\u0026#34;org.assertj:assertj-core:3.19.0\u0026#34;) // for Kotlin mocking and assertion testImplementation(\u0026#34;io.mockk:mockk:1.11.0\u0026#34;) testImplementation(\u0026#34;io.kotest:kotest-assertions-core:4.4.3\u0026#34;) testImplementation(\u0026#34;org.junit.jupiter:junit-jupiter-api:5.6.0\u0026#34;) testRuntimeOnly(\u0026#34;org.junit.jupiter:junit-jupiter-engine\u0026#34;) } tasks { test { useJUnitPlatform() } } ReservationService 前置 提前创建以下空文件，避免代码无法运行\nReservation.java ReservationService.java ReservationRepository.java Red - 01 - 编写单元测试 执行单元测试，显示【红灯】，代码分支：\nkotlin-red-01 java-red-01 kotlin @TestInstance(TestInstance.Lifecycle.PER_CLASS) internal class ReservationServiceImplTest { private val service: ReservationService = ReservationServiceImpl() @Nested inner class MakeReservation { private val time: LocalDateTime = LocalDateTime.of(2021, 5, 1, 21, 30) @Test fun shouldSuccess() { // given val reservation = Reservation(name = \u0026#34;Tom\u0026#34;, time = time) // actual val reserved: Reservation = service.makeReservation(reservation) // expect reserved shouldBe reservation } } } Green - 01 - 编写实现 执行单元测试，显示【绿灯】，代码分支：\nkotlin-green-01 java-green-01 kotlin class ReservationServiceImpl : ReservationService { override fun makeReservation(reservation: Reservation): Reservation { return reservation } } Red - 02 - 加入功能 - 完善单元测试 （注意：持久化层目前不需要关心，在这里使用 mock 相关功能）\n加入持久化逻辑，完善代码，显示【红灯】，代码分支：\nkotlin-red-02 java-red-02 kotlin private val mockRepository: ReservationRepository = mockk() private val service: ReservationService = ReservationServiceImpl(mockRepository) @AfterEach fun clear() { clearAllMocks() } @Test fun shouldSuccess() { // given every { mockRepository.save(any()) } returns reservation // verify verifySequence { mockRepository.save(reservation) } // ... } Green - 02 - 编写实现 - 完善功能 代码分支：\nkotlin-green-02 java-green-02 kotlin override fun makeReservation(reservation: Reservation): Reservation { return repository.save(reservation) } Red - 03 - 边界测试 当同一时间内已有预约的情况下，代码分支：\nkotlin-red-03 java-red-03 kotlin @Test fun shouldSuccess() { // given ... every { mockRepository.findByTime(time) } returns null // verify ... mockRepository.findByTime(time) } @Test fun shouldFailure() { // given val reservation = Reservation(name = \u0026#34;Tom\u0026#34;, time = time) every { mockRepository.findByTime(time) } returns reservation // actual shouldThrow\u0026lt;ReservationTimeNotAvailable\u0026gt; { service.makeReservation(reservation) } // verify verifySequence { mockRepository.findByTime(time) mockRepository.save(reservation) wasNot Called } } Green - 03 - 完善边界检查 kotlin override fun makeReservation(reservation: Reservation): Reservation { val mayBeReserved = repository.findByTime(reservation.time) if (mayBeReserved != null) { throw ReservationTimeNotAvailable } return repository.save(reservation) } Refactor - 简单的小重构 别忘了，重构完之后，运行一遍单元测试，【绿灯】。代码分支：\nkotlin-refactor override fun makeReservation(reservation: Reservation): Reservation { repository.findByTime(reservation.time)?.run { throw ReservationTimeNotAvailable } return repository.save(reservation) } 小结 一个简单的小功能通过 TDD 开发流程就此开发完成。\n完整代码\n🔗 参考链接 测试驱动开发 Test Driven Development TDD 開發五步驟，帶你實戰 Test Driven Development 範例 自動軟體測試-tdd-與-bdd spring-boot-testing testing-web-layer ","permalink":"https://lexcao.io/zh/posts/kotlin-java-tdd-example/","summary":"\u003cp\u003e通过使用 Kotlin / Java 中 Junit5 和 Mockito 测试框架，在预约功能中演示 TDD 开发流程。\u003c/p\u003e\n\u003ch1 id=\"tdd-介绍\"\u003eTDD 介绍\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003eTDD（Test-Driven Development）\u003c/strong\u003e\n是一种开发流程，中文是「测试驱动开发」。用一句白话形容，就是「先写测试再开发」。先写测试除了能确保测试程式的撰写，还有一个好处：有助于在开发初期厘清程式介面如何设计。详细理论知识可以前往 Wiki 了解，这里不再过多介绍。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91\"\u003e测试驱动开发\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Test-driven_development\"\u003eTest Driven Development\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tdd-开发流程5步\"\u003eTDD 开发流程（5步）\u003c/h2\u003e\n\u003cp\u003e术语说明：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e红灯 - Failure - 测试用例失败\u003c/li\u003e\n\u003cli\u003e绿灯 - Success - 测试用例成功\u003c/li\u003e\n\u003cli\u003e重构 - Refactor - 重构功能代码\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e具体步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e选定一个功能，编写测试用例\u003c/li\u003e\n\u003cli\u003e执行测试，得到【红灯】\u003c/li\u003e\n\u003cli\u003e编写满足测试用例的功能代码\u003c/li\u003e\n\u003cli\u003e再次执行，得到【绿灯】\u003c/li\u003e\n\u003cli\u003e【重构】代码\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e小结：\u003c/p\u003e\n\u003cp\u003e对于每一个功能，在【红灯】-【绿灯】-【重构】间来回循环往复，不断得到完善。\u003c/p\u003e\n\u003ch1 id=\"前置工作\"\u003e前置工作\u003c/h1\u003e\n\u003ch2 id=\"代码说明\"\u003e代码说明\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e使用 Kotlin 语言（会有相对应的 Java 代码）\u003c/li\u003e\n\u003cli\u003e使用到的测试框架\n\u003cul\u003e\n\u003cli\u003eRunning: \u003ccode\u003eJUnit5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eMock:  \u003ccode\u003eMockK\u003c/code\u003e / \u003ccode\u003eMockito\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eAssertion: \u003ccode\u003eKotest\u003c/code\u003e / \u003ccode\u003eAssertJ\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e只涉及 TDD 的具体流程，不涉及单元测试如何编写（可以看 SpringBoot 单元测试各层）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"功能介绍\"\u003e功能介绍\u003c/h2\u003e\n\u003cp\u003e假设一个用户预约的场景。\u003c/p\u003e","title":"Kotlin/Java TDD 开发流程记录"},{"content":"最近遇到一个平时没怎么关注的 Kotlin 相等问题，决定记录一下探究过程。\n事由 以下代码片段 Kotlin 版本 1.3.72。\n还原问题代码，已去除业务逻辑部分，仅保留关键代码，片段如下：\n// 有一个状态枚举 enum class MyState { OK, CANCELED } // 某个处理函数会返回 nullable MyState fun processing(): MyState? { // 假设当前某种情况下返回 取消 这个状态 return MyState.CANCELED } // 在处理状态时 fun handleState() { // 此时编译器推断出类型为 State? val state = processing() if (state == CANCELED) { // 当处理 CANCELED 以下代码没有执行 println(\u0026#34;Handle \u0026lt;CANCELED\u0026gt; state\u0026#34;) } } 当处理 CANCELED 代码没有执行，原因在于***「import」***。\nimport javax.print.attribute.standard.JobState.CANCELED // 此处使用静态导入引入了一个其他包中同名的一个静态变量，该变量声明如下 // public static final JobState CANCELED = new JobState (7); 解决方法：\n// 删除上面的静态引包，换成我们的 MyState if (state == MyState.CANCELED) { ... } 👏拍拍手，这个 BUG 改起来真容易。又可以愉快地摸鱼了呢。\n😠等等，作为静态语言面对如此诡异地类型不匹配为什么能够通过编译？\n🤔思考 ❓问题点：\n🤐 Kotlin 枚举类对比 Java 的一个静态变量，直觉上感觉类型不匹配的情况，为什么能够通过编译？ ❓❓❓头上的问号变多了：\nKotlin 中其他类型会出现这种类似的情况吗？ Kotlin 编译器具体怎么处理枚举类型的？ Java 会出现这种情况吗？（应该不会） 在 Stack Overflow 和 YouTrack 搜了一圈，没有找到想要的信息。 可能是搜索关键字不对😢。\n为了探个究竟，通过以下实验研究 Kotlin 编译器类型不匹配行为。\n「点击跳转到结果部分」\n🔬实验 第一步 实验预期 先看下各自的相等（equality）语法说明：\nJava 中，\n== 比较的是两个对象的引用，也就是内存地址。内存地址相同的前提是两个对象必须是同一种类型； equals() 比较的是两个对象的内容。 Kotlin 中，\nIn Kotlin there are two types of equality: Structural equality (a check for equals()).\na == b =\u0026gt; a?.equals(b) ?: (b === null) Referential equality (two references point to the same object);\na === b =\u0026gt; a and b point to the same object \u0026mdash; kotlin equality\n以下是简单翻译：\nKotlin 中有两种类型的相等：\n结构相等（对 equals() 的检查）\na == b =\u0026gt; a?.equals(b) ?: (b === null) 引用相等（两个引用指向同一对象）\na === b =\u0026gt; a 和 b 指向同一对像 简单来说，\nJava 中的 == 对应 Kotlin ===； Kotlin 中的 == 包含 Java equals 和 ==。 先设置一个预期：\nJava 中的相等，\nequals() 成功通过编译，程序正常运行； 方法入参是 Object，不同类型相比不会报错。 == 不能编译； 引用相同前提需要对象相同。 Kotlin 中的相等，\n=== 不能编译； 与 Java 的 == 行为一致，引用相同前提需要对象相同。 == 不能编译； a?.equals(b) ?: (b === null) 这里 equals 入参是 Any? 能够通过编译，但是后面会对比对象引用，凭直觉来看，有对比引用的话，如果类型不一致，不能编译。 第二步 收集变量 通过上面复现出的问题梳理出以下变量：\nvariable values 条件判断语句 Kotlin: if / when | Java: if / switch 表达式对象 Kotlin: class / enum class / object Java: class / enum / static field 表达式声明 K - K / J - J / J - K 第三步 初步筛选 对于条件判断语句，\nKotlin 的 if 和 when 的行为一致，所以这里可以只使用 if； Java 中 switch 仅支持 enum / String / primitive ，再加上对于 enum 有严格类型校验（语法层面，当 switch(enum) case 语句就处于该 enum 的上下文，只能使用该 enum 中定义的值。不考虑，同样只使用 if。 if (condition) {} 对于相等判断，\nJava 使用 == 和 equals()； Kotlin 仅使用 == （=== 行为与 Java 中 == 一致，故省略）。 对于表达式对象，每个实验对象定义 a / b ，b 用于同类型时备用。\n表达式对象 Java Kotlin class MyJavaClassA / MyJavaClassB MyKotlinClassA / MyKotlinClassB enum RetentionPolicy / ElementType AnnotationRetention / AnnotationTarget object / static JobState / JobStateReason MyKotlinObjectA / MyKotlinObjectB public class MyJavaClassA {} // MyJavaClassA.java public class MyJavaClassB {} // MyJavaClassB.java class MyKotlinClassA // MyKotlinClassA.kt class MyKotlinClassB // MyKotlinClassB.kt object MyKotlinObject // MyKotlinObjectA object MyKotlinObject // MyKotlinObjectB // RetentionPolicy : java.lang.annotation.RetentionPolicy // ElementType : java.lang.annotation.ElementType // AnnotationRetention : kotlin.annotation.AnnotationRetention // AnnotationTarget : kotlin.annotation.AnnotationTarget // JobState : javax.print.attribute.standard.JobState // JobStateReason : javax.print.attribute.standard.JobStateReason 对于表达式声明，还需要新增一个 Kotlin 中 nullable 类型\n// 总共有以下几类 J - J K - K K? - K? J - K J - K? K - K? 第四步 验证框架 // java 验证代码 public class JavaGenerated { void if_JavaClass_To_JavaClass(MyJavaClassB a) { if (a.equals(new MyJavaClassA())) { } else if (a == new MyJavaClassA()) { } } } // kotlin 验证代码 class KotlinGenerated { fun if_JavaClass_To_JavaClass(a: MyJavaClassB) { if (a == MyJavaClassA()) { } } } 第五步 编码验证 有了上面的模版之后，就可以根据变量开始编码验证。\n面对多种的变量组合的情况，手动编写大量的模版代码非常的劳累。\n所以利用工具，使用 JavaPoet 和 KotlinPoet 来生成代码。\n(花了一天来写自动生成代码逻辑，完成后感到一阵空虚，为什么要花那么多的时间折腾，手动复制粘贴早写完了。)\n😭这里大致说以下生成的思路：\n1. 分别枚举出需要测试的三种类型，JavaCase 和 KotlinCase 2. JavaCase 和 KotlinCase 中相两两组合 得到 java-kotlin 3. 根据 java-kotlin 再次组合 5 种情况 * J 2 J * J 2 K * K 2 K * K? 2 K * K? 2 J 4. 根据 java-kotlin-pairs 生成对应的 KotlinIf 和 JavaIf 方法 5. 根据方法，通过 JavaPoet 和 KotlinPoet 代码 生成后的代码挺多的，感兴趣的去看，这两个文件：\nJavaGenerated.java KotlinGenerated.kt 第六步 观察结果 环境如下\nJava Version 1.8.0_172 Kotlin Version 1.3.72 IDEA Version 2020.1 这里结果大致分为两类：\n[error] ，不能编译。编译器告警，在 IDEA 中红色波浪线标出； [warning] ，能够编译。IDEA 告警，以黄色背景高亮。 JavaGenerated.java 完全符合预期，\n== 不能编译； equals() 能够编译，另外 IDEA 给出友好提醒。 type == equals Class [error] Operator \u0026lsquo;==\u0026rsquo; cannot be applied [warning] inconvertible types Static [error] Operator \u0026lsquo;==\u0026rsquo; cannot be applied [warning] inconvertible types Enum [error] Operator \u0026lsquo;==\u0026rsquo; cannot be applied [warning] condition is always false KotlinGenerated.kt 部分符合预期，\n=== 不能编译； == 对于 Kotlin 的 Class / Static 不能编译。 type == Class [error] EQUALITY_NOT_APPLICABLE,Operator \u0026lsquo;==\u0026rsquo; cannot be applied Static [error] EQUALITY_NOT_APPLICABLE,Operator \u0026lsquo;==\u0026rsquo; cannot be applied Enum [warning] INCOMPATIBLE_ENUM_COMPARISON,Comparison of incompatible enums is always unsuccessful 不符合预期，\nJava Class / Static 可以编译； Enum 可以编译。 下面是相关代码：\nfun if_JavaClass_To_JavaClass(a: MyJavaClassB) { if (a == MyJavaClassA()) { } } fun if_JavaStatic_To_JavaStatic(a: JobStateReason) { if (a == JobState.CANCELED) { } } fun if_NullableKotlinEnum_To_JavaStatic(a: AnnotationRetention?) { if (a == JobState.CANCELED) { } } 以上情况可以归纳为：\nJava 对象类型(Class/Static)，能通过编译； JavaClass_To_JavaClass JavaStatic_To_JavaStatic 可空的 Kotlin 枚举类型对应 Java 静态类型，能通过编译； NullableKotlinEnum_To_JavaStatic 大致梳理出以下疑问点： 2. Class / Static 的对比为什么比 Java 的 equals 更严格？ 3. 为什么 Enum 的对比可以通过编译，没有像上面那么严格？ 4. 使用两个不同的 Java 的对象对比，为什么可以通过编译？ 5. nullable 的枚举类为什么可以与 Java 的静态类型对比？\n第七步 探究原因 再回顾一下 Kotlin 官方文档中对相等（equality）的定义：\na == b =\u0026gt; a?.equals(b) ?: (b === null) a === b =\u0026gt; a and b point to the same object 1. Class / Static 的对比为什么比 Java 的 equals 更严格？ （目前没有想清楚原因）TODO ：这里应该去看 Kotlin 编译器在处理 EQUALITY_NOT_APPLICABLE 这个报错。\n2. 为什么 Enum 的对比可以通过编译，没有像上面那么严格？ 在 Java 中 enum 其实是语法糖，最终会被编译为范型类。\nabstract class Enum\u0026lt;E extends Enum\u0026lt;E\u0026gt;\u0026gt; { ... } Kotlin 不例外，enum class 也是语法糖，最终会被编译为范型类。\nabstract class Enum\u0026lt;E : Enum\u0026lt;E\u0026gt;\u0026gt; { ... } 当两个枚举对比的时候，相当与是同一个类的不同范型，所以能够通过编译，不会出现类型不匹配问题。\n这里，IDEA 告警 INCOMPATIBLE_ENUM_COMPARISON 给出友好提示。\n3. 使用两个不同的 Java 的对象对比，为什么可以通过编译？ Kotlin 中有严格的 Nullable / Notnull 语法。\n当与 Java 的类进行互相调用时，由于 Java 中的 Null 信息不确定，编译器无法推断出 Java 类的具体 Null 信息(默认视为 Nullable)。 可以在 IDEA 的智能类型推断中看到 ! 的标识。 （在 Java 中显式使用 JetBrains 提供的 @Nullable / @NotNull 这两个注解，可以让 Kotlin 编译器正确推断出 Null 信息） 【TODO，提供 IDEA 截图更好】\n所以两个 Nullable 类型的进行比较的时候，会走到 b === null 这个判断，不会报错，能够编译。\n4. Kotlin nullable 的枚举类为什么可以与 Java 的静态类型对比？ 进行上述前置探索，终于到这次问题的终点。结合上面的结论，总结如下：\n枚举类编译后是同一个 Enum 类； Java 的静态类型 Null 信息未知； 两个 Nullable 类型进行对比，会走到 b === null 判断，不会报错，能够编译。 // 给 Java 的类明确的 Null 信息 // IDEA 出现友好警告 [INCOMPATIBLE_ENUM_COMPARISON] fun if_NullableKotlinEnum_To_JavaStatic(a: AnnotationRetention?) { // 使用 !! 告诉编译器，明确 Null 信息是 Notnull if (a == JobState.CANCELED!!) { // [INCOMPATIBLE_ENUM_COMPARISON] Comparison of incompatible enums // \u0026#39;AnnotationRetention?\u0026#39; and \u0026#39;JobState\u0026#39; is always unsuccessful } } 👀总结 整个探求真相的过程还是很有趣的； 最后知道真相后，还是自己太菜了，基础知识没有完全掌握； 深入探究了 Kotlin 和 Java 的相等和枚举相关的内容； 下一步：趁着这股好奇心，去了解 Kotlin 编译器的相等类型判断源码。 🔗相关链接 GitHub Source Code Kotlin Equality Docs JavaPoet KotlinPoet JavaGenerated.java KotlinGenerated.kt ","permalink":"https://lexcao.io/zh/posts/kotlin-equality-diving/","summary":"\u003cp\u003e最近遇到一个平时没怎么关注的 Kotlin 相等问题，决定记录一下探究过程。\u003c/p\u003e\n\u003ch1 id=\"事由\"\u003e事由\u003c/h1\u003e\n\u003cp\u003e以下代码片段 Kotlin 版本 \u003ccode\u003e1.3.72\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e还原问题代码，已去除业务逻辑部分，仅保留关键代码，片段如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-kotlin\" data-lang=\"kotlin\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 有一个状态枚举\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eenum\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMyState\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    OK, CANCELED\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 某个处理函数会返回 nullable MyState\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003efun\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eprocessing\u003c/span\u003e(): MyState? {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#75715e\"\u003e// 假设当前某种情况下返回 取消 这个状态\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eMyState\u003c/span\u003e.CANCELED\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 在处理状态时\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003efun\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ehandleState\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#75715e\"\u003e// 此时编译器推断出类型为 State?\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e    \u003cspan style=\"color:#66d9ef\"\u003eval\u003c/span\u003e state = processing()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (state \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e CANCELED) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e// 当处理 CANCELED 以下代码没有执行\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e        println(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Handle \u0026lt;CANCELED\u0026gt; state\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当处理 CANCELED 代码没有执行，原因在于***「import」***。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e javax.print.attribute.standard.JobState.CANCELED\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// 此处使用静态导入引入了一个其他包中同名的一个静态变量，该变量声明如下\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// public static final JobState CANCELED = new JobState (7);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e解决方法：\u003c/p\u003e","title":"Kotlin 奇怪的相等现象探究"},{"content":"背景 Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词\n持久化对象，即实体 PO(Persistent Object) 传输对象 DTO(Data Transfer Object) 业务对象 BO(Business Object) 展示对象 VO(View Object) 等等…… 这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程： 1. 接收请求体 CreateOrderRequest 2. 根据 OrderQuery 构造查询对象查询订单 3. 构造 OrderEntity 进行持久化操作 4. 构造 OrderBO 进行下游消费 5. 返回响应体 CreateOrderResponse 可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。\n在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。 所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。\n注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现\n是什么 通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。 主要有两个注解：\n@Konvertable 生成裁剪的实体以及对应的转换方法 @Konvert 单独针对某个类生成转换方法 废话不多说来看怎么使用。\n怎么用 1. 引入依赖 // for build.gradle.kts repositories { maven(\u0026#34;https://jitpack.io\u0026#34;) } dependencies { kapt(\u0026#34;com.github.lexcao:konverter:master-SNAPSHOT\u0026#34;) implementation(\u0026#34;com.github.lexcao:konverter-annotation:master-SNAPSHOT\u0026#34;) } // for build.gradle repositories { maven { url \u0026#39;https://jitpack.io\u0026#39; } } dependencies { kapt \u0026#39;com.github.lexcao:konverter:master-SNAPSHOT\u0026#39; implementation \u0026#39;com.github.lexcao:konverter-annotation:master-SNAPSHOT\u0026#39; } 2. 在需要转换的类上加上注解 @Konvertable( To(name = \u0026#34;LoginDTO\u0026#34;, pick = [\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;]), To(name = \u0026#34;UserListDTO\u0026#34;, omit = [\u0026#34;password\u0026#34;]) ) @Konvert(to = UserVO::class) data class UserEntity( val id: Long, @Konvert.Field(\u0026#34;name\u0026#34;) val username: String, val password: String, @Konvert.By(GenderEnumConverter::class) val gender: Int ) 3. 生成的代码如下： // @Konvertable /** * Auto generated code by @Konvertable */ data class LoginDTO( val username: String, val password: String ) /** * Auto generated code by @Konvertable */ data class UserListDTO( val id: Long, val username: String, val gender: Int ) /** * Auto generated code by @Konvert */ fun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String = this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password) /** * Auto generated code by @Konvert */ fun LoginDTO.toUserEntity( id: Long = 0L, username: String = this@toUserEntity.username, password: String = this@toUserEntity.password, gender: Int = 0 ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun UserEntity.toUserListDTO( id: Long = this@toUserListDTO.id, username: String = this@toUserListDTO.username, gender: Int = this@toUserListDTO.gender ): UserListDTO = UserListDTO(id=id,username=username,gender=gender) /** * Auto generated code by @Konvert */ fun UserListDTO.toUserEntity( id: Long = this@toUserEntity.id, username: String = this@toUserEntity.username, password: String = \u0026#34;\u0026#34;, gender: Int = this@toUserEntity.gender ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun UserEntity.toRegisterDTO( username: String = this@toRegisterDTO.username, password: String = this@toRegisterDTO.password, gender: Int = this@toRegisterDTO.gender ): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun RegisterDTO.toUserEntity( id: Long = 0L, username: String = this@toUserEntity.username, password: String = this@toUserEntity.password, gender: Int = this@toUserEntity.gender ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) // @Konvert // 转换为如下对象 data class UserVO( val id: String, val name: String, val gender: GenderEnum ) enum class GenderEnum { MALE, FEMALE; } object GenderEnumConverter : Konvert.KonvertBy\u0026lt;Int, GenderEnum\u0026gt; { override fun Int.forward(): GenderEnum { return GenderEnum.values()[this] } override fun GenderEnum.backward(): Int { return this.ordinal } } // 生成的代码 ** * Auto generated code by @Konvert */ fun UserEntity.toUserVO( id: String = this@toUserVO.id.toString(), name: String = this@toUserVO.username, gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() } ): UserVO = UserVO(id=id,name=name,gender=gender) /** * Auto generated code by @Konvert */ fun UserVO.toUserEntity( id: Long = this@toUserEntity.id.toLong(), username: String = this@toUserEntity.name, password: String = \u0026#34;\u0026#34;, gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() } ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) 相关 API 说明 转换规则\n如果转换至 String 类型，原类型不匹配时会调用 toString() 如果转换至基础数据类型，转换字段缺失时会使用默认类型 如果转换至允许为 null 类型，原类型不匹配时会使用默认值 null 如果转换至引用类型（String 除外）或者找不到映射需要在转换方法显式赋值 下一步 代码重构，新增测试用例 支持引用类型默认值 支持嵌套对象 支持 Java 已知 BUG 修复 支持映射失败字段获取原类型的构造函数参数默认值，或者成员变量默认值（目前 Kotlin KAPT 已支持获取成员变量默认值，暂不支持获取函数参数默认值） 已知 BUG 相同 name 在 @Konvertable 冲突 @Konvertable 参数合法性校验以及友好报错 KonvertBy 目前使用 Class 报错或者使用 Companion 报错 最后 Konverter 源码在 GitHub\n相关的样例代码 GitHub\n","permalink":"https://lexcao.io/zh/posts/konverter/","summary":"\u003ch1 id=\"背景\"\u003e背景\u003c/h1\u003e\n\u003cp\u003eWeb 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e持久化对象，即实体 PO(\u003cem\u003ePersistent Object\u003c/em\u003e)\u003c/li\u003e\n\u003cli\u003e传输对象 DTO(\u003cem\u003eData Transfer Object\u003c/em\u003e)\u003c/li\u003e\n\u003cli\u003e业务对象 BO(\u003cem\u003eBusiness Object\u003c/em\u003e)\u003c/li\u003e\n\u003cli\u003e展示对象 VO(\u003cem\u003eView Object\u003c/em\u003e)\u003c/li\u003e\n\u003cli\u003e等等……\n这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1. 接收请求体 CreateOrderRequest\n2. 根据 OrderQuery 构造查询对象查询订单\n3. 构造 OrderEntity 进行持久化操作\n4. 构造 OrderBO 进行下游消费\n5. 返回响应体 CreateOrderResponse\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。\u003c/p\u003e\n\u003cp\u003e在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。\n所以 \u003ccode\u003eKonverter\u003c/code\u003e 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"是什么\"\u003e是什么\u003c/h1\u003e\n\u003cp\u003e通过 \u003ca href=\"https://kotlinlang.org/docs/reference/kapt.html]\"\u003e\u003cem\u003eKAPT(Kotlin Annotation Processing Tool\u003c/em\u003e\u003c/a\u003e 注解处理以及 \u003ca href=\"https://github.com/square/kotlinpoet\"\u003e\u003cem\u003eKotlin Poet\u003c/em\u003e\u003c/a\u003e 代码生成，实现自动生成对实体的相关裁剪的对象。\n主要有两个注解：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e@Konvertable\u003c/code\u003e 生成裁剪的实体以及对应的转换方法\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e@Konvert\u003c/code\u003e 单独针对某个类生成转换方法\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e废话不多说来看怎么使用。\u003c/p\u003e\n\u003ch1 id=\"怎么用\"\u003e怎么用\u003c/h1\u003e\n\u003ch2 id=\"1-引入依赖\"\u003e1. 引入依赖\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// for build.gradle.kts\nrepositories {\n    maven(\u0026#34;https://jitpack.io\u0026#34;)\n}\n\ndependencies {\n    kapt(\u0026#34;com.github.lexcao:konverter:master-SNAPSHOT\u0026#34;)\n    implementation(\u0026#34;com.github.lexcao:konverter-annotation:master-SNAPSHOT\u0026#34;)\n}\n\n// for build.gradle\nrepositories {\n    maven { url \u0026#39;https://jitpack.io\u0026#39; }\n}\n\ndependencies {\n    kapt \u0026#39;com.github.lexcao:konverter:master-SNAPSHOT\u0026#39;\n    implementation \u0026#39;com.github.lexcao:konverter-annotation:master-SNAPSHOT\u0026#39;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"2-在需要转换的类上加上注解\"\u003e2. 在需要转换的类上加上注解\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e@Konvertable(\n    To(name = \u0026#34;LoginDTO\u0026#34;, pick = [\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;]),\n    To(name = \u0026#34;UserListDTO\u0026#34;, omit = [\u0026#34;password\u0026#34;])\n)\n@Konvert(to = UserVO::class)\ndata class UserEntity(\n    val id: Long,\n    @Konvert.Field(\u0026#34;name\u0026#34;)\n    val username: String,\n    val password: String,\n    @Konvert.By(GenderEnumConverter::class)\n    val gender: Int\n)\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"3-生成的代码如下\"\u003e3. 生成的代码如下：\u003c/h2\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// @Konvertable\n/**\n *  Auto generated code by @Konvertable\n */\ndata class LoginDTO(\n  val username: String,\n  val password: String\n)\n\n/**\n *  Auto generated code by @Konvertable\n */\ndata class UserListDTO(\n  val id: Long,\n  val username: String,\n  val gender: Int\n)\n\n/**\n *  Auto generated code by @Konvert\n */\nfun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String =\n    this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password)\n\n/**\n *  Auto generated code by @Konvert\n */\nfun LoginDTO.toUserEntity(\n  id: Long = 0L,\n  username: String = this@toUserEntity.username,\n  password: String = this@toUserEntity.password,\n  gender: Int = 0\n): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)\n\n/**\n *  Auto generated code by @Konvert\n */\nfun UserEntity.toUserListDTO(\n  id: Long = this@toUserListDTO.id,\n  username: String = this@toUserListDTO.username,\n  gender: Int = this@toUserListDTO.gender\n): UserListDTO = UserListDTO(id=id,username=username,gender=gender)\n\n/**\n *  Auto generated code by @Konvert\n */\nfun UserListDTO.toUserEntity(\n  id: Long = this@toUserEntity.id,\n  username: String = this@toUserEntity.username,\n  password: String = \u0026#34;\u0026#34;,\n  gender: Int = this@toUserEntity.gender\n): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)\n\n/**\n *  Auto generated code by @Konvert\n */\nfun UserEntity.toRegisterDTO(\n  username: String = this@toRegisterDTO.username,\n  password: String = this@toRegisterDTO.password,\n  gender: Int = this@toRegisterDTO.gender\n): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender)\n\n/**\n *  Auto generated code by @Konvert\n */\nfun RegisterDTO.toUserEntity(\n  id: Long = 0L,\n  username: String = this@toUserEntity.username,\n  password: String = this@toUserEntity.password,\n  gender: Int = this@toUserEntity.gender\n): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)\n\u003c/code\u003e\u003c/pre\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e// @Konvert\n// 转换为如下对象\ndata class UserVO(\n    val id: String,\n    val name: String,\n    val gender: GenderEnum\n)\n\nenum class GenderEnum {\n    MALE, FEMALE;\n}\n\nobject GenderEnumConverter : Konvert.KonvertBy\u0026lt;Int, GenderEnum\u0026gt; {\n    override fun Int.forward(): GenderEnum {\n        return GenderEnum.values()[this]\n    }\n\n    override fun GenderEnum.backward(): Int {\n        return this.ordinal\n    }\n}\n\n// 生成的代码\n**\n *  Auto generated code by @Konvert\n */\nfun UserEntity.toUserVO(\n  id: String = this@toUserVO.id.toString(),\n  name: String = this@toUserVO.username,\n  gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() }\n): UserVO = UserVO(id=id,name=name,gender=gender)\n\n/**\n *  Auto generated code by @Konvert\n */\nfun UserVO.toUserEntity(\n  id: Long = this@toUserEntity.id.toLong(),\n  username: String = this@toUserEntity.name,\n  password: String = \u0026#34;\u0026#34;,\n  gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() }\n): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"相关-api-说明\"\u003e相关 API 说明\u003c/h2\u003e\n\u003cp\u003e转换规则\u003c/p\u003e","title":"使用 KAPT 生成 Kotlin Data Class 转换器"},{"content":"背景 某次发版之后，线上服务低概率出现某台实例接口响应超时，具体表现为：\n/health 接口超时报警； 线程死锁，Tomcat 线程池吃满； 服务完全无响应。 保留下当前 heap dump 和 thread stack 后，临时重启服务器恢复正常。\n# heap dump $ jmap -dump:format=b,file=dump.hprof [pid] # thread stack jstack [pid] \u0026gt; stack.txt 接下来简单记录一下排查结果。 （此文为回忆所写，当时排查的思考细节和过程已省略）\n排查 heap dump 使用工具 Eclipse + MAT\n安装 # 安装 eclipse $ brew cask install eclipse-java # 安装 eclipse MAT $ brew cask install mat # 是的，这个就是 eclipse-mat 相关连接 Eclipse\nEclipse MAT\n使用 把 heap dump 文件 dump.hprof 导入到 MAT。\n发现有一个名称为 Spring-Async-Scheduler 异步队列占用特别大。【TODO 图片】\n这里排查方向有了：异步调用相关。\nthread stack 使用工具 直接作为 txt 打开，或者使用 IDEA 自带的线程栈分析。\n使用 打开 IDEA 菜单栏 Analyze \u0026gt; Analyze Stack Trace or Thread Dump； 复制 thread.txt 内容到窗口区； 官方说明 IDEA Analyze Stacktrace ； 如果是同一个项目的调用栈，IDEA 支持跳转到具体的方法，强烈推荐👍。 【TODO 图片】 排查 通过 IDEA 中友好的线程栈信息可见，【TODO 截图】\nTomcat-NIO 全部 200 个线程都在等待，没有线程继续处理后续的请求；\nSpring-Async 全部 4 个线程也在等待；\n\u0026#34;async-1\u0026#34; #151 prio=5 os_prio=0 tid=0x00007f18001a1000 nid=0x94 waiting on condition [0x00007f17be9ea000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for \u0026lt;0x00000000e176e988\u0026gt; (a java.util.concurrent.CompletableFuture$Signaller) \u0026#34;async-2\u0026#34; #152 prio=5 os_prio=0 tid=0x00007f18001a4800 nid=0x95 waiting on condition [0x00007f17be8e9000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for \u0026lt;0x00000000e177c3c8\u0026gt; (a java.util.concurrent.CompletableFuture$Signaller) \u0026#34;async-3\u0026#34; #153 prio=5 os_prio=0 tid=0x00007f18001dc800 nid=0x96 waiting on condition [0x00007f17be7e8000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for \u0026lt;0x00000000e1794a08\u0026gt; (a java.util.concurrent.CompletableFuture$Signaller) \u0026#34;async-4\u0026#34; #160 prio=5 os_prio=0 tid=0x00007f182002d800 nid=0x9d waiting on condition [0x00007f17be0e1000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for \u0026lt;0x00000000e176e958\u0026gt; (a java.util.concurrent.CompletableFuture$Signaller) 为什么 Spring-Async-Pool 线程池只有 4 个线程 查看 @EnablePooledAsync \u0026gt; AsyncAutoConfigurer \u0026gt; PooledAsyncProperties\n// 默认配置如下 // 核心线程池大小 var corePoolSize: Int = Runtime.getRuntime().availableProcessors() // 最大线程池大小 var maxPoolSize: Int = Math.max(Runtime.getRuntime().availableProcessors() shl 2, 64) // 队列容量 var queueCapacity: Int = 500_00 这个自动配置类是平台组提供的通用组件，默认是使用 CPU 核数。\n已知服务器配置为 4 核，所以核心线程池数量为 4。\n🤔思考 4 个异步线程队列等待，Tomcat 的 200 个线程也在等待。\n会不会是异步调用中出现循环等待造成死锁？ （需要看一下这次版本上线新增的异步调用代码） 有没有可能在异步调用途中发生异常？ 可以根据 Tomcat 中已经阻塞的线程看下具体是哪些接口引起？ 查看代码 新上线的异步代码嫌疑最大，这里定位到一个调用异步方法，已删除业务逻辑，提取出以下代码结构：\n@GetMapping(\u0026#34;/test\u0026#34;) fun test() { val future = async { fetch(listOf(1,2,3)) } future.await() // #2 } fun fetch(ids: List\u0026lt;Long\u0026gt;): DTO { return async { doFetch() }.await() // #1 } 简单说一下上面代码的调用，async 内调用 fetch() 方法，而里面嵌套了一个 async 调用。\n这里调用方可能并不知道 fetch() 函数里面已经开启了一个异步调用，出现异步嵌套调用的现象。 下面分析一下「异步内调用异步」为什么会出现相互等待导致线程死锁。\n已知当前声明的 Async-Pool 线程池线程数为 4 个：\n并发请求出现，同时出现 4个以上 #1 在等待 #1 处产生的异步调用进入 Asnyc-Pool-Queue 中排队 #2 处等待 #1 中的返回 #1 在等待其子任务 #2 在等待 #1 但是队中等待的只有 #2，#1 的子任务还在排队中 出现相互等待的情况，导致无限等下去了 这里简单模拟了一下异步队列里面的任务情况 1. 当前队列为空 \u0026gt; async-pool - [] \u0026gt; async-pool-queue - [] 2. 一个请求进来 \u0026gt; async-pool - [#2, #1] \u0026gt; async-pool-queue - [] 3. 多个请求顺序进来 - 理想情况 \u0026gt; async-pool - [#2, #1, #2, #1] \u0026gt; async-pool-queue - [#2, #1] ---- 以下是异常情况 4. 当多个请求并发进来 - 实际上 \u0026gt; async-pool - [#2, #2, #2, #2] \u0026gt; async-pool-queue - [#1, #1, #1, #1, #1] --\u0026gt; 此处触发无限等待 结论 异步里面嵌套异步的情况，如果两个异步使用同一个异步队列，在并发情况下会出现异步线程相互等待导致死锁问题。\n解决方案：\n使用同一个线程池的异步线程禁止嵌套调用； 如果需要异步嵌套异步调用，两个异步需要拥有不同的异步队列。 参考链接 Eclipse Eclipse MAT JStack IDEA Analyze Stacktrace ","permalink":"https://lexcao.io/zh/posts/async-within-async/","summary":"\u003ch1 id=\"背景\"\u003e背景\u003c/h1\u003e\n\u003cp\u003e某次发版之后，线上服务低概率出现某台实例接口响应超时，具体表现为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e/health\u003c/code\u003e 接口超时报警；\u003c/li\u003e\n\u003cli\u003e线程死锁，Tomcat 线程池吃满；\u003c/li\u003e\n\u003cli\u003e服务完全无响应。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e保留下当前 heap dump 和 thread stack 后，临时重启服务器恢复正常。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# heap dump\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ jmap -dump:format\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eb,file\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003edump.hprof \u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003epid\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# thread stack\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejstack \u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003epid\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e \u0026gt; stack.txt\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e接下来简单记录一下排查结果。\n\u003cbr/\u003e（此文为回忆所写，当时排查的思考细节和过程已省略）\u003c/p\u003e\n\u003ch1 id=\"排查\"\u003e排查\u003c/h1\u003e\n\u003ch2 id=\"heap-dump\"\u003eheap dump\u003c/h2\u003e\n\u003ch3 id=\"使用工具\"\u003e使用工具\u003c/h3\u003e\n\u003cp\u003eEclipse + MAT\u003c/p\u003e\n\u003ch3 id=\"安装\"\u003e安装\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 安装 eclipse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ brew cask install eclipse-java\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 安装 eclipse MAT\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ brew cask install mat \u003cspan style=\"color:#75715e\"\u003e# 是的，这个就是 eclipse-mat\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"相关连接\"\u003e相关连接\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://projects.eclipse.org/projects/eclipse\"\u003e\u003cem\u003e\u003cstrong\u003eEclipse\u003c/strong\u003e\u003c/em\u003e\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.eclipse.org/mat/\"\u003e\u003cem\u003e\u003cstrong\u003eEclipse MAT\u003c/strong\u003e\u003c/em\u003e\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"使用\"\u003e使用\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e把 \u003ccode\u003eheap dump\u003c/code\u003e 文件 \u003ccode\u003edump.hprof\u003c/code\u003e 导入到 MAT。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e发现有一个名称为 \u003ccode\u003eSpring-Async-Scheduler\u003c/code\u003e 异步队列占用特别大。【TODO 图片】\u003c/p\u003e","title":"一次线程死锁排查记录"},{"content":"Reactive Streams Reactive Streams 在 Netflix 、Pivotal 和 Lightbend 工程师于 2013 年底发起这项计划。\nReactive Streams 是一项提议，为无阻塞背压的异步流提供一个标准。这包括针对运行时环境（JVM 和 JavaScript）以及网络协议上的工作。\n你可以在 Reactive Streams 官网网站阅读这个原始规范。\n你也可以在 这里 阅读它的中文翻译。\n无阻塞背压的异步流处理 Reactive Streams 由以下组成：\n异步； 流式； 无阻塞； 背压（回压）。 以下是 Java 接口，你可以在 GitHub 阅读更详细内容。\npublic interface Publisher\u0026lt;T\u0026gt; { public void subscribe(Subscriber\u0026lt;? super T\u0026gt; s); } public interface Subscriber\u0026lt;T\u0026gt; { public void onSubscribe(Subscription s); public void onNext(T t); public void onError(Throwable t); public void onComplete(); } public interface Subscription { public void request(long n); public void cancel(); } public interface Processor\u0026lt;T, R\u0026gt; extends Subscriber\u0026lt;T\u0026gt;, Publisher\u0026lt;R\u0026gt; { } Reactive Extensions 用于可观察流的异步编程 API。\nReactiveX 是来自观察者模式、迭代器模式以及函数式编程的最佳创意组合。\n\u0026ndash; Reactive Extensions\nProject Reactor Reactor 是第四代 Reactive 函数库，基于 Reactive Streams 规范 在 JVM 上构建无阻塞应用。\n可组合性和可读性 以丰富的操作符方法操作数据流 订阅之前没有任何反应 背压或者消费者具有通知生产者生产速率过高能力 并发上的高级抽象 \u0026ndash; From Imperative to Reactive Programming\n功能：\n完全无阻塞； 集成 Java API： Completable Future Stream Duration Flux 和 Mono Flux：一个 Reactive Streams 发布者，具有 rx 操作符，它发出 0 到 N 个元素，然后完成。 Mono：一个 Reactive Streams 发布者，具有 rx 操作符，发出 一个 元素成功完成，或者一个异常。 实现了 Reactive Streams 规范。 你可以在 GitHub 阅读更多细节。\n当然，你可以根据这个 快速上手 Rx API 来学习基础的接口。\n这里有个 帮助你如何选择操作符\nReactor Netty Reactor Netty 基于 Netty 框架，提供无阻塞和背压就绪的 TCP/HTTP/UDP 客户端和服务端。\n\u0026ndash; Reactor Netty\nSpring Reactor WebFlux Reactive 技术栈的网络框架，Spring WebFlux，在 5.0版本后期加入。它是完全无阻塞，支持 Reactive Streams 背压，并且在 Netty、Undertow 以及 Servlet .3.1+ 等服务器上运行。\n\u0026ndash; Spring WebFlux\nRSocket 基于 Reactive Sreams 背压的一个二进制协议\n功能：\n双向的 多路复用 基于消息（message driven） 二进制协议 交互模型：\n请求-响应（ 1 对 1 ） 发送 - 忘却 （ 1 对 0 UDP） 请求 - 流式（ 1 对多，发布 / 订阅） 请求 - 通道 （多对多） 通信协议\nWebSocket TCP UDP 总结 Reactive Streams 是一个规范。\nProject Reactor 是基于规范的 JVM 实现。\nSpring WebFlux 是 Spring 框架集成 Project Reactor。\nRSocket 是基于规范二进制协议实现。\n参考链接 Reactive Streams Reactive Streams JVM Reactive Extensions Project Reactor Reactor Core 快速上手 Rx API 帮助你如何选择操作符 Reactor Netty Spring WebFlux ","permalink":"https://lexcao.io/zh/posts/reactive-overview/","summary":"\u003ch1 id=\"reactive-streams\"\u003eReactive Streams\u003c/h1\u003e\n\u003cp\u003eReactive Streams 在 \u003ca href=\"https://en.wikipedia.org/wiki/Netflix\"\u003e\u003cem\u003eNetflix\u003c/em\u003e\u003c/a\u003e 、\u003ca href=\"https://en.wikipedia.org/wiki/Pivotal_Software\"\u003e\u003cem\u003ePivotal\u003c/em\u003e\u003c/a\u003e 和 \u003ca href=\"https://en.wikipedia.org/wiki/Lightbend\"\u003e\u003cem\u003eLightbend\u003c/em\u003e\u003c/a\u003e 工程师于 2013 年底发起这项计划。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eReactive Streams 是一项提议，为无阻塞背压的异步流提供一个标准。这包括针对运行时环境（JVM 和 JavaScript）以及网络协议上的工作。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e你可以在 \u003ca href=\"https://www.reactive-streams.org/\"\u003e\u003cem\u003eReactive Streams\u003c/em\u003e\u003c/a\u003e 官网网站阅读这个原始规范。\u003c/p\u003e\n\u003cp\u003e你也可以在 \u003ca href=\"https://lexcao.github.io/zh/posts/reactive-streams\"\u003e\u003cem\u003e这里\u003c/em\u003e\u003c/a\u003e 阅读它的中文翻译。\u003c/p\u003e\n\u003ch5 id=\"无阻塞背压的异步流处理\"\u003e\u003cstrong\u003e无阻塞背压的异步流处理\u003c/strong\u003e\u003c/h5\u003e\n\u003cp\u003eReactive Streams 由以下组成：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e异步；\u003c/li\u003e\n\u003cli\u003e流式；\u003c/li\u003e\n\u003cli\u003e无阻塞；\u003c/li\u003e\n\u003cli\u003e背压（回压）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e以下是 Java 接口，你可以在 \u003ca href=\"https://github.com/reactive-streams/reactive-streams-jvm\"\u003e\u003cem\u003eGitHub\u003c/em\u003e\u003c/a\u003e 阅读更详细内容。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePublisher\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esubscribe\u003c/span\u003e(Subscriber\u003cspan style=\"color:#f92672\"\u003e\u0026lt;?\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003esuper\u003c/span\u003e T\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e s);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSubscriber\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonSubscribe\u003c/span\u003e(Subscription s);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonNext\u003c/span\u003e(T t);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonError\u003c/span\u003e(Throwable t);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eonComplete\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSubscription\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003erequest\u003c/span\u003e(\u003cspan style=\"color:#66d9ef\"\u003elong\u003c/span\u003e n);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003evoid\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ecancel\u003c/span\u003e();\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003epublic\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eProcessor\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT, R\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eextends\u003c/span\u003e Subscriber\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eT\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e, Publisher\u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003eR\u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"reactive-extensions\"\u003eReactive Extensions\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e用于可观察流的异步编程 API。\u003c/p\u003e\n\u003cp\u003eReactiveX 是来自观察者模式、迭代器模式以及函数式编程的最佳创意组合。\u003c/p\u003e","title":"Reactive 概览"},{"content":"翻译自 Reactive Streams\nReactive Streams 注：Reactive Streams 直译为响应式流，这里保留英文原词。\nReactive Streams 是一项提议，旨在为具有无阻塞背压的异步处理流提供标准。这包括针对运行环境（JVM 和 JavaScript）以及网络协议的努力。\nReactive Streams 是为了提供一个无阻塞背压异步流式处理的标准的一个提议。\nJDK9 java.util.concurrent.Flow 在 JDK 9 的 java.util.concurrent.Flow 中可用的接口，分别为 1 ：1 语义上各自对应于 Reactive Streams。这意味着将会有一个迁移期，库（Libraries）将采用 JDK 中的新类型，但是由于库的完全语义等效以及 Reactive Streams \u0026lt;-\u0026gt; Flow 适配器库和直接与 JDK Flow 类型兼容的 TCK，因此这个迁移期预计会很短。\n如果你有兴趣了解有关 JVM Reactive Streams，请阅读此 文章\n问题 在异步系统中，处理流数据（尤其是数量未先确定的的“实时”数据）需要特别注意。最突出的问题是，需要控制资源消耗，这样快速数据源不会压垮流目的地。为了在并行网络主机或一台多核机器上并行地使用计算资源，需要异步。\nReactive Streams 的主要目标是管理跨异步边界的流数据交换（考虑将元素传递到另一个线程或线程池），同时确保接收方不强制缓存任意数量的数据。换句话说，背压是此模型中不可或缺的一部分，以使在线程之间进行调节的队列收到限制。如果背压的通信是同步的，则异步处理的好处将被抵消（另请看 Reactive Manifesto），因此必须注意对 Reactive Streams 实现的所有方面进行完全无阻塞和异步行为授权。\n本说明书旨在允许创建许多符合要求的实现，这些实现通过遵守规则将能够平滑地互相操作，并在流应用程序的整个处理图中保留上述好处和特性。\n范围 Reactive Streams 的范围是找接口、方法和协议的最小集，这些接口、方法和协议将描述实现目标——无阻塞背压的异步处理流，所需要的操作和实体。\n端用户 DSLs（领域特定语言）或者协议绑定 API（应用编程接口）有目的地被排除在范围之外，以鼓励和支持可能使用不同编程语言的不同实现，以尽可能地遵循其平台的习惯用法。\n我们预计，接受这个 Reactive Streams 规范以及它的实现经验将共同导向广泛的集成，例如，包括将来 JDK 版本中的 Java 平台支持或者在将来的网页浏览器中网络协议的支持。\n工作组 基本含义 基本含义定义了如何通过背压来调节流中元素的传输。元素的传输方式，传输过程中的表现形式或者背压的信号发送方式均不属于本规范的一部分。\nJVM 接口（已完成） 工作组将基本语义应用于一组编程接口，这些编程接口的主要目的是允许使用共享内存堆在 JVM 内的对象和线程之间传递流，从而实现不同一致性的实现和语言绑定的互操作。\n在 2019 年 8 月 23 日，我们发布了针对 JVM 的 Reactive Streams 1.0.3 版本，包含了 Java API， 一个文本 说明, 一个 TCK 和 实现示例.\n1.0.3 的新功能是主 jar 中包含 JDK 9（适配器库）。Maven Central 上提供了相应的代码库：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.reactivestreams\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reactive-streams\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.reactivestreams\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reactive-streams-tck\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.reactivestreams\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reactive-streams-tck-flow\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.reactivestreams\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reactive-streams-examples\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这些代码的源码在 GitHub。请使用 GitHub Issues 来提供反馈。\n所有的库和说明都在 知识共享零 下发布到了公共领域。\n在 这里 阅读更多有关 Reactive Streams 1.0.3 相关内容。\n实现须知 为了着手实现最终规范，建议先阅读 README 和这个 Java API 文档，然后看一下这个 规范，再看一下这个 TCK 以及 示例实现。如果你对以上有任何问题，请先看一下 关闭的问题，如果尚未解决，请打开一个 新的问题。\n这项工作是在 reactive-streams-jvm 仓库执行的。\nJavaScript 接口 这个工作组定义了一组最小的对象属性，用于观察 JavaScript 运行环境中的流元素。目的是提供一个可测试的规范，该规范允许不同实现在同一个运行环境进行互操作。\n这项工作是在 reactive-streams-js 仓库执行的。\n网路协议 该工作组定义了用于在各种传输介质上传递 Reactive Streams，其中涉及到元素的序列化和反序列化。此类传输媒介例如 TCP，UDP，HTTP 和 WebSockets。\n这项工作是在 reactive-streams-io 仓库执行的。\n","permalink":"https://lexcao.io/zh/posts/reactive-streams/","summary":"\u003cp\u003e翻译自 \u003ca href=\"https://www.reactive-streams.org/\"\u003e\u003cem\u003eReactive Streams\u003c/em\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"reactive-streams\"\u003eReactive Streams\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注：Reactive Streams 直译为响应式流，这里保留英文原词。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cem\u003eReactive Streams\u003c/em\u003e 是一项提议，旨在为具有\u003cstrong\u003e无阻塞背压的异步处理流\u003c/strong\u003e提供标准。这包括针对运行环境（JVM 和 JavaScript）以及网络协议的努力。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eReactive Streams\u003c/em\u003e 是为了提供一个\u003cstrong\u003e无阻塞背压异步流式处理的标准的一个提议\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"jdk9-javautilconcurrentflow\"\u003eJDK9 java.util.concurrent.Flow\u003c/h2\u003e\n\u003cp\u003e在 JDK 9 的 \u003ca href=\"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html\"\u003e\u003cem\u003ejava.util.concurrent.Flow\u003c/em\u003e\u003c/a\u003e 中可用的接口，分别为 1 ：1 语义上各自对应于 Reactive Streams。这意味着将会有一个迁移期，库（Libraries）将采用 JDK 中的新类型，但是由于库的完全语义等效以及 \u003ccode\u003eReactive Streams \u0026lt;-\u0026gt; Flow\u003c/code\u003e 适配器库和直接与 JDK Flow 类型兼容的 TCK，因此这个迁移期预计会很短。\u003c/p\u003e\n\u003cp\u003e如果你有兴趣了解有关 \u003cem\u003eJVM Reactive Streams\u003c/em\u003e，请阅读此 \u003ca href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md\"\u003e\u003cem\u003e文章\u003c/em\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"问题\"\u003e问题\u003c/h2\u003e\n\u003cp\u003e在异步系统中，处理流数据（尤其是数量未先确定的的“实时”数据）需要特别注意。最突出的问题是，需要控制资源消耗，这样快速数据源不会压垮流目的地。为了在并行网络主机或一台多核机器上并行地使用计算资源，需要异步。\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eReactive Streams\u003c/em\u003e 的主要目标是管理跨异步边界的流数据交换（考虑将元素传递到另一个线程或线程池），同时确保接收方不强制缓存任意数量的数据。换句话说，\u003cstrong\u003e背压\u003c/strong\u003e是此模型中不可或缺的一部分，以使在线程之间进行调节的队列收到限制。如果背压的通信是同步的，则异步处理的好处将被抵消（另请看  \u003ca href=\"http://reactivemanifesto.org/\"\u003e\u003cem\u003eReactive Manifesto\u003c/em\u003e\u003c/a\u003e），因此必须注意对 Reactive Streams 实现的所有方面进行完全无阻塞和异步行为授权。\u003c/p\u003e\n\u003cp\u003e本说明书旨在允许创建许多符合要求的实现，这些实现通过遵守规则将能够平滑地互相操作，并在流应用程序的整个处理图中保留上述好处和特性。\u003c/p\u003e\n\u003ch2 id=\"范围\"\u003e范围\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eReactive Streams\u003c/em\u003e 的范围是找接口、方法和协议的最小集，这些接口、方法和协议将描述实现目标——无阻塞背压的异步处理流，所需要的操作和实体。\u003c/p\u003e\n\u003cp\u003e端用户 DSLs（领域特定语言）或者协议绑定 API（应用编程接口）有目的地被排除在范围之外，以鼓励和支持可能使用不同编程语言的不同实现，以尽可能地遵循其平台的习惯用法。\u003c/p\u003e\n\u003cp\u003e我们预计，接受这个 \u003cem\u003eReactive Streams\u003c/em\u003e 规范以及它的实现经验将共同导向广泛的集成，例如，包括将来 JDK 版本中的 Java 平台支持或者在将来的网页浏览器中网络协议的支持。\u003c/p\u003e\n\u003ch3 id=\"工作组\"\u003e工作组\u003c/h3\u003e\n\u003ch4 id=\"基本含义\"\u003e基本含义\u003c/h4\u003e\n\u003cp\u003e基本含义定义了如何通过背压来调节流中元素的传输。元素的传输方式，传输过程中的表现形式或者背压的信号发送方式均不属于本规范的一部分。\u003c/p\u003e","title":"Reactive Streams 规范翻译"},{"content":"简介 最近我在寻找一个方法给自己取一个英文名字，然后我发现这篇文章，如何选择一个英文名字。该文章在选择一个英文名字提出了一个行之有效的方法，我用该方法制作了一个应用来帮助选择一个英文名字。\n你可以在 这里 尝试一下。\n我会在下面展开讲一下那篇文章和这个应用。\n文章所说 以下是文章原文。\nDo not try to be creative in picking an English name.\nAvoid:\nDo not try to pick a fun or cute-sounding name from a movie, television, or video game character Do not pick a name that you think sounds cool or trendy, because Americans will think it sounds stupid Do not pick a name because your friends think it sounds cute, because your friends are not the Americans you have to interact with in the future Do not translate some positive-sounding word in your language into English and make that into your name Do:\nChoose a name from the 100 most popular names for your birth year If possible, choose a name that sounds somewhat similar to your real name Do not choose a variation as your official name Do not worry about what a name means 以下是我的翻译版本。\n不要尝试在选择一个英文名上富有创造力。\n避免：\n不要从电影，电视或者游戏里的角色去选择一个有趣或发音可爱的名字 不要选择一个你认为听起来很酷或者新潮的，因为美国人可能认为很蠢 不要选择一个名字因为你朋友认为听起来很可爱，因为你的朋友不是将来要和你互动的美国人 不要直接翻译一些你母语当中正面的词汇为英语并把它当作你的名字 推荐：\n从 你出生那年最流行的 100 个名字 里面选择一个 如果可以，选择一个听起来跟你真实名字有某些相似的名字 不要选择一个名字的变体作为你的官方名字 不要担心一个名字的含义 应用所做 从 你出生那年最流行的 100 个名字 里面选择一个\n我根据文章的建议从 美国社保局出生婴儿名字数据 下载了原始数据。\n把它放到了 GitHub 上，并且已经做了一个 JSON 格式的。\n请在阅读他们的 说明 之后免费使用，Enjoy！\n我是怎么选择的 从我的中文名中找灵感，Lixin Cao，我想要一个以 L 开头的英文名。 找到我出生年的英文名字，选出一些我喜欢的。 Levi Alex Lucas Liam 带上我的姓氏，比如 LeviCao，去社交网站看一下有没有被占用。 Levi （圣经相关的） Alex （已经被人占用） Lucas （太流行） Liam （太流行） 在 nameberry 和 behindthename 搜索名字的含义和一些变体。 我最喜欢 Alex，然后我最后选择了 Lex 作为我的英文名字。 参考链接 英文名选择器 英文名选择器 源码 美国社保局英文名数据 GitHub 如何选择一个英文名 美国社保局出生婴儿名字 美国社保局出生婴儿名字数据 ","permalink":"https://lexcao.io/zh/posts/choose-english-name/","summary":"\u003ch1 id=\"简介\"\u003e简介\u003c/h1\u003e\n\u003cp\u003e最近我在寻找一个方法给自己取一个英文名字，然后我发现这篇文章，\u003ca href=\"http://www.pgbovine.net/choosing-english-name.htm\"\u003e\u003cem\u003e如何选择一个英文名字\u003c/em\u003e\u003c/a\u003e。该文章在选择一个英文名字提出了一个行之有效的方法，我用该方法制作了一个应用来帮助选择一个英文名字。\u003c/p\u003e\n\u003cp\u003e你可以在 \u003ca href=\"https://lexcao.github.io/English-name-picker\"\u003e\u003cem\u003e这里\u003c/em\u003e\u003c/a\u003e 尝试一下。\u003c/p\u003e\n\u003cp\u003e我会在下面展开讲一下那篇文章和这个应用。\u003c/p\u003e\n\u003ch1 id=\"文章所说\"\u003e文章所说\u003c/h1\u003e\n\u003cp\u003e以下是文章原文。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDo not try to be creative in picking an English name.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAvoid:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eDo not try to pick a fun or cute-sounding name from a movie, television, or video game character\u003c/li\u003e\n\u003cli\u003eDo not pick a name that you think sounds cool or trendy, because Americans will think it sounds stupid\u003c/li\u003e\n\u003cli\u003eDo not pick a name because your friends think it sounds cute, because your friends are not the Americans you have to interact with in the future\u003c/li\u003e\n\u003cli\u003eDo not translate some positive-sounding word in your language into English and make that into your name\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003cp\u003eDo:\u003c/p\u003e","title":"选择一个英文名字"},{"content":"选择一个合适的静态网站生成器比较难，尤其是当你第一次想要搭建一个博客网站的时候。这是我第一次搭建一个博客并且没有足够的时间去尝试所有常见的生成器，我选择了 Jekyll 作为第一次搭建使用的生成器，尽管它可能不是最好的一个。我准备以后再尝试其他生成器。\n这是我从 Google 找到的一些简要的描述，希望它能对你选择什么生成器开始搭建网站有帮助。\n我从 GitHub 选择了以下三个静态博客生成器进行比较\nJekyll Hugo Hexo 什么是静态网站生成器 HTML 文件； 没有服务端处理或者数据库交互； 比动态网站更安全； 利于使用 CDN 进行扩展； 缓存会带来比动态网页更高的效率； 请求超快速。 Jekyll 使用语言 Ruby； GitHub 支持； 使用 GitHub Pages 免费部署。 优势 免费且开源； RubyGems 支持构建主题为 gems 方便分发； 简单便捷使用； 强大的 GitHub Pages 支持； 开箱即用的合适的默认极简主题。 劣势 当网站内容不断增加后，构建速度会明显变慢。\n功能 Liquid 模版引擎； 基于 Gem 主题； Markdown 和 YAML 类型支持； Sass 预处理 CSS 支持； 官方插件支持 CoffeeScript。 Hugo 使用语言 Go. 优势 免费开源； 速度非常快，对构建速度做了优化； 内置支持很多功能： 动态 API 请求的内容； 无限制内容类型； shortcakes， 一个灵活的 Markdown 替代； 国际化； 别名重定向； 分页。 预制的 Go 模版和模式； 无需依赖（不用安装 Go，因为它是编译好的二进制）； 功能强大的内容模型。 劣势 主题使用 Go 模版，所以需要熟悉 Go； 没有内置默认主题； 缺少扩展性和插件（因为 Go 是编译型语言）。 功能 Go 模版； 国际化; 支持动态 API。 Hexo 使用 Node.js. 优势 相当快速； 在 GitHub Pages 部署简单； 中文支持（可能是劣势对于非中文用户）； 中文社区。 劣势 没有英文。 功能 EJS 模版引擎; 支持 中文; 对于 HTML + CSS + Javascript 非常友好。 我正在使用 Jekyll\n喜欢 非常多的免费主题和插件； 有很多教程对于初学者来说； 不需要任何技能就能部署到 GitHub Pages 上。 不喜欢 对于大多数插件没有被 GitHub Pages 支持； 不支持国际化。 顺便一提，由于目前文章数量比较少，构建速度不在我的考虑范围之内，将来如果用 Jekyll 明显感到构建变慢的时候，我就会尝试其他的生成器。\n以上三个生成器的构建速度排名：Hugo \u0026gt; Hexo \u0026gt; jekyll。\n下一个将来要尝试的生成器应该是 Hugo，到时候我会更新这篇文章，写一些实际的使用感受。\n参考链接 如何选择正确的静态生成器 Jekyll vs. Hugo vs. Hexo 静态网站生成器比较 ","permalink":"https://lexcao.io/zh/posts/jekyll-hugo-hexo/","summary":"\u003cp\u003e选择一个合适的静态网站生成器比较难，尤其是当你第一次想要搭建一个博客网站的时候。这是我第一次搭建一个博客并且没有足够的时间去尝试所有常见的生成器，我选择了 \u003ccode\u003eJekyll\u003c/code\u003e 作为第一次搭建使用的生成器，尽管它可能不是最好的一个。我准备以后再尝试其他生成器。\u003c/p\u003e\n\u003cp\u003e这是我从 Google 找到的一些简要的描述，希望它能对你选择什么生成器开始搭建网站有帮助。\u003c/p\u003e\n\u003cp\u003e我从 GitHub 选择了以下三个静态博客生成器进行比较\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://jekyllrb.com/\"\u003e\u003cem\u003eJekyll\u003c/em\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://gohugo.io/\"\u003e\u003cem\u003eHugo\u003c/em\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://hexo.io/\"\u003e\u003cem\u003eHexo\u003c/em\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"什么是静态网站生成器\"\u003e什么是静态网站生成器\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003eHTML 文件；\u003c/li\u003e\n\u003cli\u003e没有服务端处理或者数据库交互；\u003c/li\u003e\n\u003cli\u003e比动态网站更安全；\u003c/li\u003e\n\u003cli\u003e利于使用 CDN 进行扩展；\u003c/li\u003e\n\u003cli\u003e缓存会带来比动态网页更高的效率；\u003c/li\u003e\n\u003cli\u003e请求超快速。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"jekyll\"\u003e\u003ca href=\"https://jekyllrb.com/\"\u003e\u003cem\u003eJekyll\u003c/em\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e使用语言 \u003cstrong\u003eRuby\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGitHub\u003c/strong\u003e 支持；\u003c/li\u003e\n\u003cli\u003e使用 GitHub Pages 免费部署。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"优势\"\u003e优势\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e免费且开源；\u003c/li\u003e\n\u003cli\u003eRubyGems 支持构建主题为 gems 方便分发；\u003c/li\u003e\n\u003cli\u003e简单便捷使用；\u003c/li\u003e\n\u003cli\u003e强大的 GitHub Pages 支持；\u003c/li\u003e\n\u003cli\u003e开箱即用的合适的默认极简主题。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"劣势\"\u003e劣势\u003c/h2\u003e\n\u003cp\u003e当网站内容不断增加后，构建速度会明显变慢。\u003c/p\u003e\n\u003ch2 id=\"功能\"\u003e功能\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLiquid\u003c/code\u003e 模版引擎；\u003c/li\u003e\n\u003cli\u003e基于 \u003ccode\u003eGem\u003c/code\u003e 主题；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMarkdown\u003c/code\u003e 和 \u003ccode\u003eYAML\u003c/code\u003e 类型支持；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSass\u003c/code\u003e 预处理 CSS 支持；\u003c/li\u003e\n\u003cli\u003e官方插件支持 \u003ccode\u003eCoffeeScript\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"hugo\"\u003e\u003ca href=\"https://gohugo.io\"\u003e\u003cem\u003eHugo\u003c/em\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e使用语言 \u003cstrong\u003eGo\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"优势-1\"\u003e优势\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e免费开源；\u003c/li\u003e\n\u003cli\u003e速度非常快，对构建速度做了优化；\u003c/li\u003e\n\u003cli\u003e内置支持很多功能：\n\u003col\u003e\n\u003cli\u003e动态 API 请求的内容；\u003c/li\u003e\n\u003cli\u003e无限制内容类型；\u003c/li\u003e\n\u003cli\u003eshortcakes， 一个灵活的 Markdown 替代；\u003c/li\u003e\n\u003cli\u003e国际化；\u003c/li\u003e\n\u003cli\u003e别名重定向；\u003c/li\u003e\n\u003cli\u003e分页。\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003cli\u003e预制的 Go 模版和模式；\u003c/li\u003e\n\u003cli\u003e无需依赖（不用安装 Go，因为它是编译好的二进制）；\u003c/li\u003e\n\u003cli\u003e功能强大的内容模型。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"劣势-1\"\u003e劣势\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e主题使用 Go 模版，所以需要熟悉 Go；\u003c/li\u003e\n\u003cli\u003e没有内置默认主题；\u003c/li\u003e\n\u003cli\u003e缺少扩展性和插件（因为 Go 是编译型语言）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"功能-1\"\u003e功能\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eGo 模版；\u003c/li\u003e\n\u003cli\u003e国际化;\u003c/li\u003e\n\u003cli\u003e支持动态 API。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"hexo\"\u003e\u003ca href=\"https://hexo.io\"\u003e\u003cem\u003eHexo\u003c/em\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e使用 \u003cstrong\u003eNode.js\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"优势-2\"\u003e优势\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e相当快速；\u003c/li\u003e\n\u003cli\u003e在 GitHub Pages 部署简单；\u003c/li\u003e\n\u003cli\u003e中文支持（可能是劣势对于非中文用户）；\u003c/li\u003e\n\u003cli\u003e中文社区。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"劣势-2\"\u003e劣势\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e没有英文。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"功能-2\"\u003e功能\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eEJS\u003c/code\u003e 模版引擎;\u003c/li\u003e\n\u003cli\u003e支持 \u003ccode\u003e中文\u003c/code\u003e;\u003c/li\u003e\n\u003cli\u003e对于 \u003ccode\u003eHTML + CSS + Javascript\u003c/code\u003e 非常友好。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"我正在使用\"\u003e我正在使用\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003eJekyll\u003c/strong\u003e\u003c/p\u003e","title":"Jekyll / Hugo / Hexo 比较"},{"content":"实现目标 支持多语言，英文为主，中文为辅； 当访问 / 根目录下页面，比如 /about.html /posts/hello-world 显示英文页面； 当访问 /zh/ 目录下页面，比如 /zh/about.html /zh/posts/hello-world 显示中文页面； 当访问 ../hello-world 文章时，可以通过链接跳转到对应语言页面； archive 和 index 页面中仅显示出当前语言页面。 相关缺陷 404 页面无法配置，只能在 404.html 页面写上两种语言； 支持多语言文章的分页插件 jekyll-paginate-v2 没在 GitHub Pages 支持的插件白名单内，目前本博客首页不支持分页。多语言分页详见下文； 多语言时间表示有点麻烦，需要做一些字符串处理工作，能实现但是不太优雅，具体可以参考 Jekyll-Date-Formatting。 开始配置 最初，我搜索到 i18n 插件 Jekyll-Multiple-Languages-Plugin。\n该仓库的 Star 数是多语言插件中最多的，同时里面也列出了相关其他多语言插件，已经比较完善，不想折腾的可以直接使用。\n目前我为了简单和可定制化，同时省略掉插件中不必要的功能，选择使用自定义规则来实现多语言功能。\n1. 单个博文配置 每一篇文章和页面需要定义两个属性：\nuid 标示文章唯一，一篇文章的中文版本和英文版本 uid 相同； 注意：uid 可以设置为任意命名，比如 document_id 。 locale 标示文章语言，一篇文章被渲染后作为哪种语言展示。 所以每篇文章的 Front Matter 新增如下设置\n--- uid: hello-world locale: zh --- 2. 对于文章 posts 每篇文章都需要在 Front Matter 中写上 locale 重复多余。不要重复自己。我准备使用不同文件夹来区分不同语言的文章，然后在配置文件设置 locale 的默认值。\n在 _posts 目录下创建 zh 文件夹用于存放中文文章。当访问 /zh/posts/xxx 时即展示中文页面。\n（当然，也可以设置不同的目录，参照以下配置进行设置不同的 path ）\ndefaults: - values: #1 locale: en - scope: #2 path: _posts/zh/** type: posts values: locale: zh #1 未指定 scope 全局默认：所有文章 posts 和页面 pages 默认 en； #2 指定 scope 路径 _posts/zh/** 下 posts 类型：zh。 3. 对于页面中通用的字符串 导航栏中 归档 关于 或者 下一页 等这样的通用字符串。\n使用 site.data 功能来实现，在 /_data 目录下创建 locales 文件夹，并分别创建 en.yml 和 zh.yml 用于存放英文和中文字符串。\n# /_data/locales/en.yml 文件中 menu: about: About archive: Archive # /_data/locales/zh.yml 文件中 menu: about: 关于 archive: 归档 配置好这些字符串后，在需要替换文字的地方使用\n\u0026lt;nav class=\u0026#34;menu-content\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/about\u0026#34;\u0026gt;{{ site.data.locales[page.locale].menu.about }}\u0026lt;/a\u0026gt; \u0026lt;/nav\u0026gt; 4. 对于页面 pages 一些通用页面：archive.html about.html 等 pages 类型。\n单独在项目根目录下创建一个文件夹 _zh，并作为 collection 来配置\ncollections: zh: output: true 在 _zh 文件夹下创建对应页面\n/menu/archive.html /menu/about.html 5. 语言选择器 用于在不同语言的文章或页面中根据 locale 进行切换。\n在 _includes 文件夹下添加一个新文件 language-selector.html。\n遍历 posts、 pages 和 collections 找到相应的语言页面\n{% if page.uid %} \u0026lt;!-- #1 --\u0026gt; \u0026lt;div class=\u0026#34;language-selector\u0026#34;\u0026gt; {% assign postsOrPages = site.posts \u0026lt;!-- #2 --\u0026gt; | concat: site.pages | concat: site.zh | where: \u0026#34;uid\u0026#34;, page.uid | sort: \u0026#34;locale\u0026#34; %} {% for item in postsOrPages %} {% unless item.url contains \u0026#39;/page/\u0026#39; %} \u0026lt;!-- #3 --\u0026gt; \u0026lt;a href=\u0026#34;{{ item.url }}\u0026#34; class=\u0026#34;{{ item.locale }}\u0026#34;\u0026gt; {{ site.data.locales[item.locale].name }} \u0026lt;!-- #4 --\u0026gt; \u0026lt;/a\u0026gt; {% endunless %} {% endfor %} \u0026lt;/div\u0026gt; {% endif %} #1 仅在有 uid 的页面显示语言选择器 #2 拼接 posts pages zh 数组，找到 uid 对应的页面，根据 local 排序 #3 过滤掉 /pages/ 目录下页面 #4 拿到 locale 对应的语言文字，如 EN 中 6. 归档页面 需要手动多虑掉非本语言页面的文章。\npost.next 提供便捷获取下一篇文章的方法，但是在多语言文章中无法保证 locale 的一致性，需要作出如下修改\n\u0026lt;!-- archive.html --\u0026gt; \u0026lt;!-- 使用 posts 的下标，而不用 post.next --\u0026gt; {% assign posts = site.posts | where: \u0026#34;locale\u0026#34;, page.locale %} {% for index in (0..posts.size) limit: posts.size %} {% assign post = posts[index] %} {% assign prevIndex = index | minus: 1 %} {% assign prev = posts[prevIndex] %} {% capture year %}{{ post.date | date: \u0026#39;%Y\u0026#39; }}{% endcapture %} {% capture prevYear %}{{ prev.date | date: \u0026#39;%Y\u0026#39; }}{% endcapture %} {% if year != prevYear or index == 0 %} \u0026lt;h3\u0026gt;{{ year }}\u0026lt;/h3\u0026gt; {% endif %} \u0026lt;li itemscope\u0026gt; \u0026lt;a href=\u0026#34;{{ post.url }}\u0026#34;\u0026gt;{{ post.title }}\u0026lt;/a\u0026gt; \u0026lt;p class=\u0026#34;post-date\u0026#34;\u0026gt;\u0026lt;span\u0026gt;{{ post.date | date: \u0026#34;%B %-d\u0026#34; }}\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; {% endfor %} 核心思想：先根据 locale 过滤，遍历的时候使用下标而不是 post.next。\n7. 多语言 SEO 在 _includes 文件夹下面创建一个新页面 language-seo.html。\n通过 hreflang 指示对应的语言\n{% assign posts = site.posts | where:\u0026#34;uid\u0026#34;, page.uid | sort: \u0026#39;locale\u0026#39; %} {% for post in posts %} \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;{{ post.locale }}\u0026#34; href=\u0026#34;{{ post.url }}\u0026#34; /\u0026gt; {% endfor %} 并且在 head.html 引用\n\u0026lt;!-- Language SEO --\u0026gt; {% include language-seo.html %} 最后 我省略了一些不重要的常规配置，源码请看 GitHub: lexcao.github.io\n相关参考链接 Jekyll Multiple Language Plugin Making Jekyll Multilingual Multi-Languages-with-Jekyll Deploy A Multi-Language Jekyll Site jekyll-paginate-v2 另一件事 多语言支持分页 旧的分页插件 jekyll-pagination-v1 无法根据筛选条件过滤已经不再适合，不能在对应的语言页面显示对应的语言文章列表。\n如果想在多语言下支持分页，可以使用 jekyll-pagination-v2。我上面提到过 Github Pages 插件 白名单列表 不支持该插件，如果需要使用就需要 手动实现部署。以下是如何配置使用 jekyll-pagination-v2\nGemfile 安装 $ gem \u0026#39;jekyll-paginate-v2\u0026#39; _config.yml 配置 注意：v2 和 v1 的配置不兼容，需要按照如下配置做相应修改\nplugins: - jekyll-paginate-v2 pagination: enabled: true per_page: 5 permalink: /page/:num/ sort_reverse: true pages 页面配置 首页 index.html 进行分页，需要添加如下配置\n# /index.html --- pagination: enabled: true # 是的，这里还需要再次开启一次 locale: en --- pagination.locale 此处用来配置分页筛选条件，根据页面的 locale 字段进行过滤。这也是我在 Front Matter 用 locale 字段来标志语言的原因，复用。\n对应的，在 _zh 文件夹下面创建中文首页 index.html。\n# /_zh/index.html --- permalink: /zh/ # 此处是为了让首页不显示 .html 后缀 pagination: enabled: true locale: zh --- 注意：我在这里配置的时候，遇到一个问题，当我把 index.html 放到 _zh 文件夹后，分页 locale 筛选不起作用，目前还没解决。\n临时解决方案是将 zh/index.html 放在根目录，并改名为 index_zh.html。\n分页使用 使用没有变化，和 v1 一样的使用方式，详细请看 Pagination\n相关参考链接 Jekyll-Paginate-v2 Jekyll-Paginate-V2 Filter Locales ","permalink":"https://lexcao.io/zh/posts/jekyll-multi-language-without-plugin/","summary":"\u003ch1 id=\"实现目标\"\u003e实现目标\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e支持多语言，英文为主，中文为辅；\u003c/li\u003e\n\u003cli\u003e当访问 \u003ccode\u003e/\u003c/code\u003e 根目录下页面，比如 \u003ccode\u003e/about.html\u003c/code\u003e \u003ccode\u003e/posts/hello-world\u003c/code\u003e 显示英文页面；\u003c/li\u003e\n\u003cli\u003e当访问 \u003ccode\u003e/zh/\u003c/code\u003e 目录下页面，比如 \u003ccode\u003e/zh/about.html\u003c/code\u003e \u003ccode\u003e/zh/posts/hello-world\u003c/code\u003e 显示中文页面；\u003c/li\u003e\n\u003cli\u003e当访问 \u003ccode\u003e../hello-world\u003c/code\u003e 文章时，可以通过链接跳转到对应语言页面；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003earchive\u003c/code\u003e 和 \u003ccode\u003eindex\u003c/code\u003e 页面中仅显示出当前语言页面。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"相关缺陷\"\u003e相关缺陷\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e404 页面无法配置，只能在 \u003ccode\u003e404.html\u003c/code\u003e 页面写上两种语言；\u003c/li\u003e\n\u003cli\u003e支持多语言文章的分页插件 \u003ccode\u003ejekyll-paginate-v2\u003c/code\u003e 没在 GitHub Pages 支持的插件白名单内，目前本博客首页不支持分页。多语言分页详见\u003ca href=\"/zh/posts/jekyll-multi-language-without-plugin/#paginate\"\u003e下文\u003c/a\u003e；\u003c/li\u003e\n\u003cli\u003e多语言时间表示有点麻烦，需要做一些字符串处理工作，能实现但是不太优雅，具体可以参考 \u003ca href=\"http://alanwsmith.com/jekyll-liquid-date-formatting-examples\"\u003e\u003cem\u003eJekyll-Date-Formatting\u003c/em\u003e\u003c/a\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"开始配置\"\u003e开始配置\u003c/h1\u003e\n\u003cp\u003e最初，我搜索到 \u003ccode\u003ei18n\u003c/code\u003e 插件 \u003ca href=\"https://github.com/kurtsson/jekyll-multiple-languages-plugin\"\u003e\u003cem\u003eJekyll-Multiple-Languages-Plugin\u003c/em\u003e\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e该仓库的 Star 数是多语言插件中最多的，同时里面也列出了相关其他多语言插件，已经比较完善，不想折腾的可以直接使用。\u003c/p\u003e\n\u003cp\u003e目前我为了简单和可定制化，同时省略掉插件中不必要的功能，选择使用自定义规则来实现多语言功能。\u003c/p\u003e\n\u003ch2 id=\"1-单个博文配置\"\u003e1. 单个博文配置\u003c/h2\u003e\n\u003cp\u003e每一篇文章和页面需要定义两个属性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003euid\u003c/code\u003e 标示文章唯一，一篇文章的中文版本和英文版本 \u003ccode\u003euid\u003c/code\u003e 相同；\n\u003cul\u003e\n\u003cli\u003e注意：\u003ccode\u003euid\u003c/code\u003e 可以设置为任意命名，比如 \u003ccode\u003edocument_id\u003c/code\u003e 。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elocale\u003c/code\u003e 标示文章语言，一篇文章被渲染后作为哪种语言展示。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所以每篇文章的 \u003ccode\u003eFront Matter\u003c/code\u003e 新增如下设置\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e---\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003euid\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ehello-world\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003elocale\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003ezh\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e---\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"2-对于文章-posts\"\u003e2. 对于文章 posts\u003c/h2\u003e\n\u003cp\u003e每篇文章都需要在 \u003ccode\u003eFront Matter\u003c/code\u003e 中写上 \u003ccode\u003elocale\u003c/code\u003e 重复多余。\u003cstrong\u003e不要重复自己\u003c/strong\u003e。我准备使用不同文件夹来区分不同语言的文章，然后在配置文件设置 \u003ccode\u003elocale\u003c/code\u003e 的默认值。\u003c/p\u003e","title":"Jekyll 不使用插件支持多语言"},{"content":"你好 网上邻居 欢迎来到我的博客，我是 曹历鑫 Lex Cao。\n本博客名为 代码笔记 CodingNotes。\n本博客用于 分享/总结/记录 我的生活或工作中跟编程有关的 知识/思考/想法。\n关于我 现居 深圳。\n使用\nJava / Kotlin（主要使用 ❤️）； SpringBoot； SpringCloud。 如果你想 联系我。\n关于博客 静态网站生成器\nJekyll 4.0 https://jekyllrb.com/ 使用主题 Lagrange http://jekyllthemes.org/themes/lagrange/ 代码托管\nGitHub 博客源码在这里 博客部署\nGitHub Pages 中英支持 为了更好的练习英文，本博客支持中文和英文两种语言。有对应语言的页面时，可以点击右上角的语言字符进行切换。\n顺便一提，本博客以英文为主，当然，也会有相应的中文内容。\n敬请期待。\n感谢你的驻足 相关链接 Code icon by Icons8 Powered by Jekyll with Lagrange theme Deployed by GitHub Pages Free to use photos by Pexels Free to use photos by Unsplash ","permalink":"https://lexcao.io/zh/about/","summary":"\u003ch2 id=\"你好-网上邻居\"\u003e你好 网上邻居\u003c/h2\u003e\n\u003cp\u003e欢迎来到我的博客，我是 \u003cstrong\u003e曹历鑫\u003c/strong\u003e \u003ccode\u003eLex Cao\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e本博客名为 \u003cstrong\u003e代码笔记\u003c/strong\u003e \u003ccode\u003eCodingNotes\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e本博客用于 \u003cstrong\u003e分享/总结/记录\u003c/strong\u003e 我的生活或工作中跟编程有关的 \u003cstrong\u003e知识/思考/想法\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"关于我\"\u003e关于我\u003c/h2\u003e\n\u003cp\u003e现居 深圳。\u003c/p\u003e\n\u003cp\u003e使用\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJava / Kotlin（主要使用 ❤️）；\u003c/li\u003e\n\u003cli\u003eSpringBoot；\u003c/li\u003e\n\u003cli\u003eSpringCloud。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果你想 \u003ca href=\"mailto:lexcao@foxmail.com\"\u003e联系我\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"关于博客\"\u003e关于博客\u003c/h2\u003e\n\u003cp\u003e静态网站生成器\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eJekyll 4.0\u003c/code\u003e \u003ca href=\"https://jekyllrb.com/\"\u003ehttps://jekyllrb.com/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e使用主题  \u003ccode\u003eLagrange\u003c/code\u003e \u003ca href=\"http://jekyllthemes.org/themes/lagrange/\"\u003ehttp://jekyllthemes.org/themes/lagrange/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e代码托管\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGitHub\u003c/li\u003e\n\u003cli\u003e博客源码在\u003ca href=\"https://github.com/lexcao/lexcao.github.io\"\u003e\u003cem\u003e这里\u003c/em\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e博客部署\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGitHub Pages\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"中英支持\"\u003e中英支持\u003c/h2\u003e\n\u003cp\u003e为了更好的练习英文，本博客支持中文和英文两种语言。有对应语言的页面时，可以点击右上角的语言字符进行切换。\u003c/p\u003e\n\u003cp\u003e顺便一提，本博客以英文为主，当然，也会有相应的中文内容。\u003c/p\u003e\n\u003cp\u003e敬请期待。\u003c/p\u003e\n\u003ch2 id=\"感谢你的驻足\"\u003e感谢你的驻足\u003c/h2\u003e\n\u003ch2 id=\"相关链接\"\u003e相关链接\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" href=\"https://icons8.com/icons/set/code\"\u003eCode\u003c/a\u003e icon by \u003ca target=\"_blank\" href=\"https://icons8.com\"\u003eIcons8\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePowered by \u003ca href=\"https://jekyllrb.com/\"\u003e\u003cem\u003eJekyll\u003c/em\u003e\u003c/a\u003e with \u003ca href=\"http://jekyllthemes.org/themes/lagrange/\"\u003e\u003cem\u003eLagrange\u003c/em\u003e\u003c/a\u003e theme\u003c/li\u003e\n\u003cli\u003eDeployed by \u003ca href=\"https://pages.github.com\"\u003e\u003cem\u003eGitHub Pages\u003c/em\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eFree to use photos by \u003ca href=\"https://www.pexels.com/\"\u003e\u003cem\u003ePexels\u003c/em\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eFree to use photos by \u003ca href=\"https://unsplash.com\"\u003e\u003cem\u003eUnsplash\u003c/em\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"关于"},{"content":"博客配置：\n静态网页生成器 Jekyll 3.8.5 Ruby 2.6.0 主题 lagrange 网页分析 Google Aynalysis Baidu Aynalysis 部署 GitHub Pages 这是我的第一篇文章，作为最简单的 “你好 世界”，我想记录一下该博客的诞生过程，以及如果你也想搭建一个自己的博客应该怎么做。\n本文章将会涉及三个部分：\n选择博客类型 准备好所需内容 将他们编排起来 第一步 选择博客类型 根据前端网页是否与后台服务器或者数据库交互分为：静态网站 / 动态网站\n静态网站：\n仅依靠 HTML / CSS / JS 没有后台服务器存储数据 数据是预先生成的 动态网站：\n依赖前端 HTML / CSS / JS 数据从后台服务器获取 能够动态响应用户请求 所以，静态博客：\n文章预先生成 不依赖后台服务器 动态博客：\n文章从后台服务器获取 前端页面动态获取 考虑到刚接触到博客搭建，先从简单的静态博客入手。目前 GitHub 上有很多开源的静态网站生成器，这里我选择使用 Jekyll。\n选择合适的静态博客生成器请看 [Jekyll / Hugo / Hexo 比较]({{ \u0026ldquo;/zh/posts/jekyll-hugo-hexo\u0026rdquo; | relative_url }})。\n第二步 准备好所需内容 准备内容涉及以下方面：\n博客文章 博客介绍 作者信息 博客域名 博客文章 提前写好文章准备发布\nGitHub Pages 部署记录（本文 😆） [Jekyll 不使用插件支持多语言]({{ \u0026ldquo;/zh/posts/jekyll-multi-language-without-plugin\u0026rdquo; | relative_url }})（本博客是中文和英文 😆） [Jekyll / Hugo / Hexo 比较]({{ \u0026ldquo;/zh/posts/jekyll-hugo-hexo\u0026rdquo; | relative_url }})（本博客用 Jekyll 😆） 如何选择一个英文名（Lex Cao 😆） 博客介绍 提前写好博客介绍，博客创建初期可以只包含简略信息，以后再慢慢补充，\n详细请看 [关于]({{ \u0026ldquo;/zh/menu/about.html\u0026rdquo; | relative_url }})。\n作者信息 笔名 这里我给自己取了一个英文名 Lex Cao\n取英文名可以参考 如何选择一个英文名\n博客名 中文名 代码笔记\n英文名 CodingNotes\n博客域名 caolixin.com 中文拼音没实际意义\nlexcao.com 已经被占用\nthecodingnotes.com 好像不错，但是有点长\n第三步 编排起来 Jekyll 安装 相关参考链接\nInstall on MacOS Jekyll with Bundle Creating a GitHub Pages with Jekyll 使用到的命令\n# install ruby 2.6.0+ $ xcode-select --install $ brew install ruby $ export PATH=/usr/local/opt/ruby/bin:$PATH $ source ~/.zshrc # install jekyll \u0026amp; bundler $ gem install --user-install bundler jekyll $ export PATH=$HOME/.gem/ruby/2.6.0/bin:$PATH $ source ~/.zshrc # init $ cd /blogs/github-pages-jekyll $ git init $ jekyll new . $ jekyll serve # serve with bundle $ bundle exec jekyll serve 主题选择 关于主题，我比较喜欢简约一点。\n在相关主题浏览网站：\njekyllthemes.org/ jekyllthemes.io/ 找到的心仪的主题：\nLagrange Chalk Type Kikofri 选出以上 4 个主题，最后使用 lagrange 作为博客主题。\n插件说明 GitHub Pages 集成 Jekyll 实现自动部署需要插件 github-pages。该插件仅允许使用白名单内插件，具体请看允许插件及版本； 要想使用自定义插件（白名单以外的插件），不能 GitHub Pages 的自动部署功能，需要将 _site 目录放到仓库上，手动实现自动部署； 本次是第一次搭建博客，所以选用了 GitHub Pages 的自动部署。 多语言配置 多语言配置，需要折腾的地方比较多，详细请看文章\nJekyll 不使用插件支持多语言。\n部署到 GitHub Pages 官方教程\n创建一个仓库 仓库名需要按照固定格式 \u0026lt;user\u0026gt;.github.io\n如：lexcao.github.io\n将文章推到 GitHub # 添加远程仓库 $ git remote add origin https://github.com/lexcao/lexcao.github.io.git $ git push -u origin master 网站已可以访问 进入仓库设置页面 Settings \u0026gt; Options \u0026gt; 拉到最下面，\nYour site is published at https://lexcao.github.io/ 博客已经发布成功。\n访问 https://lexcao.github.io/ 即可看到。\n可以在 environment 看到博客部署情况，默认配置是 master 分支有代码更新会进行自动部署。\n网站统计 博客可以访问以后，就可以开始接入网站统计相关功能，借助第三方平台。\nGoogle Analytics 在 Google Analytics 创建媒体资源，拿到一个 UA-xxx-x ID，并且引入统计代码； 在 Google Tag Manager 创建跟踪代码，根据上面拿到的 UA-xxx-x ID 新增一个 Google Analytics 代码跟踪，引入全局统计代码，并发布。 可选择，在 Google Analytics 关联 Google Search Console。 注意事项：\nGoogle Tag Manager 不允许变量为中文名; 重新发布 GitHub Pages 生效后，如果请求 js 文件 net::ERR_BLOCKED_BY_CLIENT 错误，关掉广告拦截插件重试。 Baidu Analytics 在 百度统计 关联上网页，引入统计代码，完成配置。\n实时性比 Google 稍微差一点（可能是 github.io 这个域名在国外的原因）\n结语 至此，整个博客已经完美运转了，可以开始专心写文章了 😊。\n","permalink":"https://lexcao.io/zh/posts/hello-world/","summary":"\u003cp\u003e博客配置：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e静态网页生成器\n\u003cul\u003e\n\u003cli\u003eJekyll 3.8.5\u003c/li\u003e\n\u003cli\u003eRuby 2.6.0\u003c/li\u003e\n\u003cli\u003e主题 \u003ca href=\"http://jekyllthemes.org/themes/lagrange/\"\u003elagrange\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e网页分析\n\u003cul\u003e\n\u003cli\u003eGoogle Aynalysis\u003c/li\u003e\n\u003cli\u003eBaidu Aynalysis\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e部署\n\u003cul\u003e\n\u003cli\u003eGitHub Pages\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这是我的第一篇文章，作为最简单的 “你好 世界”，我想记录一下该博客的诞生过程，以及如果你也想搭建一个自己的博客应该怎么做。\u003c/p\u003e\n\u003cp\u003e本文章将会涉及三个部分：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e选择博客类型\u003c/li\u003e\n\u003cli\u003e准备好所需内容\u003c/li\u003e\n\u003cli\u003e将他们编排起来\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"第一步-选择博客类型\"\u003e第一步 选择博客类型\u003c/h1\u003e\n\u003cp\u003e根据前端网页是否与后台服务器或者数据库交互分为：静态网站 / 动态网站\u003c/p\u003e\n\u003cp\u003e静态网站：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e仅依靠 HTML / CSS / JS\u003c/li\u003e\n\u003cli\u003e没有后台服务器存储数据\u003c/li\u003e\n\u003cli\u003e数据是预先生成的\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e动态网站：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e依赖前端 HTML / CSS / JS\u003c/li\u003e\n\u003cli\u003e数据从后台服务器获取\u003c/li\u003e\n\u003cli\u003e能够动态响应用户请求\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所以，静态博客：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e文章预先生成\u003c/li\u003e\n\u003cli\u003e不依赖后台服务器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e动态博客：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e文章从后台服务器获取\u003c/li\u003e\n\u003cli\u003e前端页面动态获取\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e考虑到刚接触到博客搭建，先从简单的静态博客入手。目前 GitHub 上有很多开源的静态网站生成器，这里我选择使用 \u003ccode\u003eJekyll\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e选择合适的静态博客生成器请看 [\u003cem\u003eJekyll / Hugo / Hexo 比较\u003c/em\u003e]({{ \u0026ldquo;/zh/posts/jekyll-hugo-hexo\u0026rdquo; | relative_url }})。\u003c/p\u003e\n\u003ch1 id=\"第二步-准备好所需内容\"\u003e第二步 准备好所需内容\u003c/h1\u003e\n\u003cp\u003e准备内容涉及以下方面：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e博客文章\u003c/li\u003e\n\u003cli\u003e博客介绍\u003c/li\u003e\n\u003cli\u003e作者信息\u003c/li\u003e\n\u003cli\u003e博客域名\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"博客文章\"\u003e博客文章\u003c/h2\u003e\n\u003cp\u003e提前写好文章准备发布\u003c/p\u003e","title":"你好 世界"},{"content":"","permalink":"https://lexcao.io/zh/projects/","summary":"","title":"项目"}]