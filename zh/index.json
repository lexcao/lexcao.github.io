[{"content":"背景 本文是 Spring Data JPA 多条件连表查询 文章的最佳实践总结。\n解决什么问题？ 使用 Spring Data JPA 需要针对多条件进行连表查询的场景不使用原生 SQL 或者 HQL 的时候，仅仅通过 JpaSpecificationExecutor 构造 Specification 动态条件语句来实现类型安全的多条件查询。\n说明 相关上下文背景请前往 前文 了解。 这里再提一下接下来示例会用到的场景：\n三个实体：作者、书、书评。其中，作者与书是一对多的关系，书与书评是一对一的关系（当然书评与读者的评价是一对多的关系，这里省去，仅用一对一来进行演示即可）。\n假设有这样的后台查询条件：作者名称、书的发布时间、书评的评分。（这里每个实体取一个字段进行连表查询演示，其他字段同理）。返回书籍列表以及相关表字段。\n【本文所有代码在此】\n最佳实践 需要 SELECT 查询的字段，通过单独的 Java Bean 进行映射 利用 JPA 的自动实体映射结果集 @EntityGraph 注解标注返回实体需要 Fetch 的字段 无需再手动针对连表进行 fetch，解决 N+1 问题 JOIN ON 查询条件使用 join().on() 拼接 Join\u0026lt;Object, Object\u0026gt; author = root.join(\u0026#34;author\u0026#34;); author.on(cb.equal(author.get(\u0026#34;name\u0026#34;), param.getAuthorName())); WHERE 查询条件使用 query.where() 拼接 query.where(cb.equal(root.get(\u0026#34;publishTime\u0026#34;), param.getBookPublishTime())); 代码示例 针对 Repository 需要 override 已有 findAll 方法，使用 @EntityGraph 注解 使用 @EntityGraph 注解，标注额外属性需要 fetch // BookJoinRepository.java @Repository public interface BookJoinRepository extends JpaRepository\u0026lt;BookJoin, String\u0026gt;, JpaSpecificationExecutor\u0026lt;BookJoin\u0026gt; { @Override @EntityGraph(attributePaths = { \u0026#34;author\u0026#34;, \u0026#34;review\u0026#34; }) Page\u0026lt;BookJoin\u0026gt; findAll(Specification\u0026lt;BookJoin\u0026gt; spec, Pageable pageable); } 针对 Specification WHERE 查询条件使用 query.where() 拼接 JOIN ON 查询条件使用 join().on() 拼接 static Specification\u0026lt;BookJoin\u0026gt; multiQuery_04(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { if (null != param.getBookPublishTime()) { query.where(cb.equal(root.get(\u0026#34;publishTime\u0026#34;), param.getBookPublishTime())); } if (null != param.getAuthorName()) { Join\u0026lt;Object, Object\u0026gt; author = root.join(\u0026#34;author\u0026#34;); author.on(cb.equal(author.get(\u0026#34;name\u0026#34;), param.getAuthorName())); } if (null != param.getReviewScore()) { Join\u0026lt;Object, Object\u0026gt; review = root.join(\u0026#34;review\u0026#34;); review.on(cb.equal(review.get(\u0026#34;score\u0026#34;), param.getReviewScore())); } return query.getRestriction(); }; } 结果 SQL 语句 select bookjoin0_.id as id1_1_0_, bookjoin_a1_.id as id1_0_1_, bookjoin_r2_.id as id1_2_2_, bookjoin0_.author_id as author_i3_1_0_, bookjoin0_.publish_time as publish_2_1_0_, bookjoin0_.review_id as review_i4_1_0_, bookjoin_a1_.name as name2_0_1_, bookjoin_r2_.score as score2_2_2_ from book bookjoin0_ inner join author bookjoin_a1_ on bookjoin0_.author_id = bookjoin_a1_.id and (bookjoin_a1_.name = ?) inner join review bookjoin_r2_ on bookjoin0_.review_id = bookjoin_r2_.id and (bookjoin_r2_.score = ?) where bookjoin0_.publish_time = ? limit ? 当然，这里案例使用的是 INNER JOIN，对于 LEFT JOIN 也是生效的。\nJoin\u0026lt;Object, Object\u0026gt; author = root.join(\u0026#34;author\u0026#34;, JoinType.LEFT); author.on(cb.equal(author.get(\u0026#34;name\u0026#34;), param.getAuthorName())); // left outer join author bookjoin_a1_ on // bookjoin0_.author_id = bookjoin_a1_.id // and (bookjoin_a1_.name = ?) 链接 Spring Data JPA 多条件连表查询 Add annotation which will automatically add join fetch to query ","permalink":"https://lexcao.io/zh/posts/spring-data-jpa-join-table-best-practice/","summary":"背景 本文是 Spring Data JPA 多条件连表查询 文章的最佳实践总结。\n解决什么问题？ 使用 Spring Data JPA 需要针对多条件进行连表查询的场景不使用原生 SQL 或者 HQL 的时候，仅仅通过 JpaSpecificationExecutor 构造 Specification 动态条件语句来实现类型安全的多条件查询。\n说明 相关上下文背景请前往 前文 了解。 这里再提一下接下来示例会用到的场景：\n三个实体：作者、书、书评。其中，作者与书是一对多的关系，书与书评是一对一的关系（当然书评与读者的评价是一对多的关系，这里省去，仅用一对一来进行演示即可）。\n假设有这样的后台查询条件：作者名称、书的发布时间、书评的评分。（这里每个实体取一个字段进行连表查询演示，其他字段同理）。返回书籍列表以及相关表字段。\n【本文所有代码在此】\n最佳实践 需要 SELECT 查询的字段，通过单独的 Java Bean 进行映射 利用 JPA 的自动实体映射结果集 @EntityGraph 注解标注返回实体需要 Fetch 的字段 无需再手动针对连表进行 fetch，解决 N+1 问题 JOIN ON 查询条件使用 join().on() 拼接 Join\u0026lt;Object, Object\u0026gt; author = root.join(\u0026#34;author\u0026#34;); author.on(cb.equal(author.get(\u0026#34;name\u0026#34;), param.getAuthorName())); WHERE 查询条件使用 query.where() 拼接 query.where(cb.equal(root.get(\u0026#34;publishTime\u0026#34;), param.getBookPublishTime())); 代码示例 针对 Repository 需要 override 已有 findAll 方法，使用 @EntityGraph 注解 使用 @EntityGraph 注解，标注额外属性需要 fetch // BookJoinRepository.","title":"Spring Data JPA 多条件连表查询最佳实践"},{"content":"痛点 项目中使用 Spring Data JPA 作为 ORM 框架的时候，实体映射非常方便。Spring Data Repository 的顶层抽象完全解决单实体的查询，面对单实体的复杂查询，也能使用 JpaSpecificationExecutor\u0026lt;T\u0026gt; 构造 Specification\u0026lt;T\u0026gt; 轻松应对。\n而对于后台管理报表查询需求来说，需要进行连表多条件动态查询的时候，就显得无从下手。因为它并不像 MyBatis 一样能够在 XML 文件中写出动态 SQL 语句。\n尽管可以使用 EntityManager 动态拼接原生 SQL 语句，但是该方法返回值为 ResultSet ，也就是说查出来的实体映射关系需要手动映射（😢这样不太优雅，已经定义出实体，还需要自己去映射）。\n所以，本文的目的是，在现有实体关系的基础上，结合 Specification\u0026lt;T\u0026gt; 记录下 Spring Data JPA 多条件动态连表查询操作，以及其中的踩坑和优化。\n想要直接看结论的，请看这篇 Spring Data JPA 动态多条件连表查询最佳实践。\n基础操作 那么，让我们开始进入代码操作。【本文所有代码在此】\n前置说明 相关依赖 Java 11 SpringBoot 2.4.2 build.gradle\nplugins { id \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;2.4.2\u0026#39; id \u0026#39;io.spring.dependency-management\u0026#39; version \u0026#39;1.0.11.RELEASE\u0026#39; id \u0026#39;java\u0026#39; } dependencies { implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39; compileOnly \u0026#39;org.projectlombok:lombok\u0026#39; runtimeOnly \u0026#39;mysql:mysql-connector-java\u0026#39; annotationProcessor \u0026#39;org.projectlombok:lombok\u0026#39; testImplementation \u0026#39;org.springframework.boot:spring-boot-starter-test\u0026#39; testRuntimeOnly \u0026#39;com.h2database:h2\u0026#39; } maven.xml\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 模拟场景 三个实体：作者、书、书评。其中，作者与书是一对多的关系，书与书评是一对一的关系（当然书评与读者的评价是一对多的关系，这里省去，仅用一对一来进行演示即可）。\n假设有这样的后台查询条件：作者名称、书的发布时间、书评的评分。（这里每个实体取一个字段进行连表查询演示，其他字段同理）。返回书籍列表以及相关表字段。\n实体关系 表结构 CREATE TABLE `author` ( `id` VARCHAR(255) PRIMARY KEY, `name` VARCHAR(255) ); CREATE TABLE `book` ( `id` VARCHAR(255) PRIMARY KEY, `publish_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP, `author_id` VARCHAR(255), `review_id` VARCHAR(255) ); CREATE TABLE `review` ( `id` VARCHAR(255) PRIMARY KEY, `score` INT ); -- 数据初始化 INSERT INTO `author` (`id`, `name`) VALUES (\u0026#39;A_1\u0026#39;, \u0026#39;Author_1\u0026#39;), (\u0026#39;A_2\u0026#39;, \u0026#39;Author_2\u0026#39;), (\u0026#39;A_3\u0026#39;, \u0026#39;Author_3\u0026#39;), (\u0026#39;A_4\u0026#39;, \u0026#39;Author_4\u0026#39;), (\u0026#39;A_5\u0026#39;, \u0026#39;Author_5\u0026#39;); INSERT INTO `review` (`id`, `score`) VALUES (\u0026#39;R_1\u0026#39;, 20), (\u0026#39;R_2\u0026#39;, 30), (\u0026#39;R_3\u0026#39;, 40), (\u0026#39;R_4\u0026#39;, 50), (\u0026#39;R_5\u0026#39;, 60), (\u0026#39;R_6\u0026#39;, 70), (\u0026#39;R_7\u0026#39;, 80), (\u0026#39;R_8\u0026#39;, 90); INSERT INTO `book` (`id`, `author_id`, `review_id`) VALUES (\u0026#39;B_1\u0026#39;, \u0026#39;A_1\u0026#39;, \u0026#39;R_1\u0026#39;), (\u0026#39;B_2\u0026#39;, \u0026#39;A_2\u0026#39;, \u0026#39;R_2\u0026#39;), (\u0026#39;B_3\u0026#39;, \u0026#39;A_3\u0026#39;, \u0026#39;R_3\u0026#39;), (\u0026#39;B_4\u0026#39;, \u0026#39;A_4\u0026#39;, \u0026#39;R_4\u0026#39;), (\u0026#39;B_5\u0026#39;, \u0026#39;A_5\u0026#39;, \u0026#39;R_5\u0026#39;), (\u0026#39;B_6\u0026#39;, \u0026#39;A_2\u0026#39;, \u0026#39;R_6\u0026#39;), (\u0026#39;B_7\u0026#39;, \u0026#39;A_2\u0026#39;, \u0026#39;R_7\u0026#39;), (\u0026#39;B_8\u0026#39;, \u0026#39;A_3\u0026#39;, \u0026#39;R_8\u0026#39;); JPA 实体关系 使用 Java persistence API 构建如下实体关系，其他业务字段省略。\n@Data @Table @Entity public class Author { @Id private String id; private String name; } @Data @Table @Entity public class Book { @Id private String id; @Column(name = \u0026#34;publish_time\u0026#34;) private LocalDateTime publishTime; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;author_id\u0026#34;, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)) private Author author; @OneToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;review_id\u0026#34;, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)) private Review review; } @Data @Table @Entity public class Review { @Id private String id; } 相关解释：\n@Data Lombok 注解，自动生成 getter、setter、hashcode、equals @Table @Entity @Id @Column @JoinColumn 均为 persistence API @ManyToOne 实体映射关系 多对一 @OneToOne 实体映射关系 一对一 在实际业务中，连表的时候不一定是查询多个实体的全部字段，为了不影响原有实体关系的正常映射，这里单独声明一个类 BookJoin 来映射查询条件返回。优雅的实现 Spring Data JPA 连表操作，这样做的好处是：\n只有 SELECT 查询出来的字段，才需要在实体里面声明出来 JOIN ON 后面的条件，需要在实体里面声明出来 再根据 Specification 中的 query.join 来进行 JOIN 以下是连表实体 BookJoin.java 文件\n@Data @Entity @Table(name = \u0026#34;book\u0026#34;) public class BookJoin { @Id private String id; @Column(name = \u0026#34;publish_time\u0026#34;) private LocalDateTime publishTime; @ManyToOne @JoinColumn(name = \u0026#34;author_id\u0026#34;, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)) private Author author; @OneToOne @JoinColumn(name = \u0026#34;review_id\u0026#34;, foreignKey = @ForeignKey(ConstraintMode.NO_CONSTRAINT)) private Review review; @Data @Entity @Table(name = \u0026#34;author\u0026#34;) public static class Author { @Id private String id; private String name; } @Data @Entity @Table(name = \u0026#34;review\u0026#34;) public static class Review { @Id private String id; private Integer score; } } 构建测试环境 为了演示多条件查询结果，这里使用 JUnit 来进行单元测试\nSpringBoot x JUnit 单元测试更详细的内容，请看另一篇博客\n/** * given: * empty query * then: * paged data */ @Test void multiQuery() { var spec = BookJoinSpec.multiQuery(emptyQuery()); var page = PageRequest.of(0, 5); queryBySpecMethod(spec, page); } private Page\u0026lt;BookJoin\u0026gt; queryBySpecMethod(Specification\u0026lt;BookJoin\u0026gt; spec, PageRequest pageRequest) { var books = repo.findAll(spec, pageRequest); assertThat(books.getNumberOfElements()).isGreaterThan(0); books.getContent().forEach(it -\u0026gt; { assertThat(it).isNotNull(); // 访问结果集的属性，验证是否懒加载 assertThat(it.getAuthor().getName()).isNotNull(); assertThat(it.getReview().getScore()).isNotNull(); } ); return books; } 连表操作 如何进行声明式连表查询，这里讲演示各种写法的不同， 以及各个参数所起的作用，最后会给出一个最终版本作为最佳实践参考。\n01 版本 static Specification\u0026lt;BookJoin\u0026gt; multiQuery_01(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { var predicates = new LinkedList\u0026lt;Predicate\u0026gt;(); root.join(\u0026#34;author\u0026#34;); root.join(\u0026#34;review\u0026#34;); // ... }; } 通过以上的单元测试，打印出的 SQL 如下\nHibernate: SELECT `bookjoin0_`.`id` AS `id1_1_`, `bookjoin0_`.`author_id` AS `author_i3_1_`, `bookjoin0_`.`publish_time` AS `publish_2_1_`, `bookjoin0_`.`review_id` AS `review_i4_1_` FROM `book` `bookjoin0_` INNER JOIN `author` `bookjoin_a1_` ON `bookjoin0_`.`author_id` = `bookjoin_a1_`.`id` INNER JOIN `review` `bookjoin_r2_` ON `bookjoin0_`.`review_id` = `bookjoin_r2_`.`id` WHERE 1 = 1 LIMIT ? OFFSET ? Hibernate: SELECT `bookjoin_a0_`.`id` AS `id1_0_0_`, `bookjoin_a0_`.`name` AS `name2_0_0_` FROM `author` `bookjoin_a0_` WHERE `bookjoin_a0_`.`id` = ? Hibernate: SELECT `bookjoin_r0_`.`id` AS `id1_2_0_`, `bookjoin_r0_`.`score` AS `score2_2_0_` FROM `review` `bookjoin_r0_` WHERE `bookjoin_r0_`.`id` = ? Hibernate: SELECT `bookjoin_r0_`.`id` AS `id1_2_0_`, `bookjoin_r0_`.`score` AS `score2_2_0_` FROM `review` `bookjoin_r0_` WHERE `bookjoin_r0_`.`id` = ? Hibernate: SELECT `bookjoin_a0_`.`id` AS `id1_0_0_`, `bookjoin_a0_`.`name` AS `name2_0_0_` FROM `author` `bookjoin_a0_` WHERE `bookjoin_a0_`.`id` = ? Hibernate: SELECT `bookjoin_r0_`.`id` AS `id1_2_0_`, `bookjoin_r0_`.`score` AS `score2_2_0_` FROM `review` `bookjoin_r0_` WHERE `bookjoin_r0_`.`id` = ? 可以看到：\n数据总共查出来 3 条，结果执行的 SQL 语句有 7 条 分别是：1 条连表查询，3 条 author 表的单查询，3 条 review 表的单查询 02 版本 - 使用 fetch 优化 使用 fetch 替代 join\njoin 仅连表查询，返回的主实体的所有属性，可以理解为 SELECT book.* fetch 连表查询 + 快加载，返回连表所有实体的属性，可以理解为 SELECT * static Specification\u0026lt;BookJoin\u0026gt; multiQuery_02(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { // ... root.fetch(\u0026#34;author\u0026#34;); root.fetch(\u0026#34;review\u0026#34;); // ... }; } 通过以上的单元测试，打印出的 SQL 如下\nHibernate: SELECT `bookjoin0_`.`id` AS `id1_1_0_`, `bookjoin_a1_`.`id` AS `id1_0_1_`, `bookjoin_r2_`.`id` AS `id1_2_2_`, `bookjoin0_`.`author_id` AS `author_i3_1_0_`, `bookjoin0_`.`publish_time` AS `publish_2_1_0_`, `bookjoin0_`.`review_id` AS `review_i4_1_0_`, `bookjoin_a1_`.`name` AS `name2_0_1_`, `bookjoin_r2_`.`score` AS `score2_2_2_` FROM `book` `bookjoin0_` INNER JOIN `author` `bookjoin_a1_` ON `bookjoin0_`.`author_id` = `bookjoin_a1_`.`id` INNER JOIN `review` `bookjoin_r2_` ON `bookjoin0_`.`review_id` = `bookjoin_r2_`.`id` WHERE 1 = 1 LIMIT ? OFFSET ? 可以看到：\n执行的 SQL 只有 1 条 SELECT 中的字段包括连表的字段 踩坑 - 分页问题 创建一个新的单元测试，直接使用 fetch 分页报错\n@Test void multiQuery_02() { var spec = BookJoinSpec.multiQuery_02(emptyQuery()); var page = PageRequest.of(0, 5); assertThatThrownBy(() -\u0026gt; queryBySpecMethod(spec, page)) .hasCauseInstanceOf(QueryException.class); } 当使用 fetch 再进行分页的时候，会报以下错误\nCaused by: org.hibernate.QueryException: query specified join fetching, but the owner of the fetched association was not present in the select list. 原因分析：\n实际报错出现在 count 语句，错误信息表示该 count 语句返回值没有找到具体的映射属性 解决方法：\n针对分页的 count 查询语句单独做处理，代码如下 static Specification\u0026lt;BookJoin\u0026gt; multiQuery_02_fix(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { // ... if (Long.class.equals(query.getResultType()) || long.class.equals(query.getResultType())) { root.join(\u0026#34;author\u0026#34;); root.join(\u0026#34;review\u0026#34;); } else { root.fetch(\u0026#34;author\u0026#34;); root.fetch(\u0026#34;review\u0026#34;); } // ... }; } 注意 可能疑问「上面 BookJoin 实体里面声明关系不是 fetch = FetchType.LAZY ，没有指明是懒加载，为什么连表查询的时候还是没有加载出来」。\n原因是 JPA 里面 join 机制处理，原理大致是这样的：\n根据 join 和 fetch 生成不同的 JpaQL 语句，差别在于 join 与 join fetch -- fetch 生成的 JpaQL 语句 select generatedAlias0 from BookJoin as generatedAlias0 inner join fetch generatedAlias0.author as generatedAlias1 inner join fetch generatedAlias0.review as generatedAlias2 where 1=1 -- join 生成的 JpaQL 语句 select generatedAlias0 from BookJoin as generatedAlias0 inner join generatedAlias0.author as generatedAlias1 inner join generatedAlias0.review as generatedAlias2 where 1=1 JpaQL 语句根据 join fetch 转换为 HQL 再转换为最终的 SQL 语句，通过 QueryTranslatorImpl 类，在 doCompile 方法看到完整转换过程，部分代码如下 // QueryTranslatorImpl // doCompile -\u0026gt; analyze -\u0026gt; HqlSqlBaseWalker.statement -\u0026gt; selectStatement // selectClause -\u0026gt; fromClause -\u0026gt; fromElementList -\u0026gt; fromElement -\u0026gt; joinElement // HqlSqlWalker.java createFromJoinElement #367 // DotNode 此处设置 fetch DotNode dot = (DotNode) path; JoinType hibernateJoinType = JoinProcessor.toHibernateJoinType( joinType ); dot.setJoinType( hibernateJoinType ); // Tell the dot node about the join type. dot.setFetch( fetch ); // Generate an explicit join for the root dot node. The implied joins will be collected and passed up // to the root dot node. dot.resolve( true, false, alias == null ? null : alias.getText() ); // 解析阶段 // selectStatement -\u0026gt; query -\u0026gt; processQuery // 上面的报错在此处 SelectClause.java #212 if ( !fromElementsForLoad.contains( origin ) \u0026amp;\u0026amp; !fromElementsForLoad.contains( fromElement.getFetchOrigin() ) ) throw new QueryException( \u0026#34;query specified join fetching, but the owner \u0026#34; + \u0026#34;of the fetched association was not present in the select list \u0026#34; + \u0026#34;[\u0026#34; + fromElement.getDisplayText() + \u0026#34;]\u0026#34; ); } 03 版本 - 加上 WHERE 条件筛选 创建一个新的单元测试，筛选一下 Join 条件\n@Test void multiQuery_03() { var query = BookJoinQuery.builder() .authorName(\u0026#34;Author_2\u0026#34;) .build(); var spec = BookJoinSpec.multiQuery_03(query); var page = PageRequest.of(0, 5); var result = queryBySpecMethod(spec, page); var givenAuthor = result.getContent().get(0).getAuthor(); assertThat(givenAuthor.getName()).isEqualTo(\u0026#34;Author_2\u0026#34;); } 具体的连表查询条件如下\nstatic Specification\u0026lt;BookJoin\u0026gt; multiQuery_03(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { var predicates = new LinkedList\u0026lt;Predicate\u0026gt;(); if (Long.class.equals(query.getResultType()) || long.class.equals(query.getResultType())) { root.join(\u0026#34;author\u0026#34;); root.join(\u0026#34;review\u0026#34;); } else { root.fetch(\u0026#34;author\u0026#34;); root.fetch(\u0026#34;review\u0026#34;); } if (null != param.getBookPublishTime()) { predicates.add(cb.equal(root.get(\u0026#34;publishTime\u0026#34;), param.getBookPublishTime())); } if (null != param.getAuthorName()) { predicates.add(cb.equal(root.get(\u0026#34;author\u0026#34;).get(\u0026#34;name\u0026#34;), param.getAuthorName())); } if (null != param.getReviewScore()) { predicates.add(cb.equal(root.get(\u0026#34;review\u0026#34;).get(\u0026#34;score\u0026#34;), param.getReviewScore())); } query.where(predicates.toArray(new Predicate[0])); return query.getRestriction(); }; } 生成的查询语句如下，可以看到查询条件是拼接在 WHERE 部分\nselect bookjoin0_.id as id1_1_0_, bookjoin_a1_.id as id1_0_1_, bookjoin_r2_.id as id1_2_2_, bookjoin0_.author_id as author_i3_1_0_, bookjoin0_.publish_time as publish_2_1_0_, bookjoin0_.review_id as review_i4_1_0_, bookjoin_a1_.name as name2_0_1_, bookjoin_r2_.score as score2_2_2_ from book bookjoin0_ inner join author bookjoin_a1_ on bookjoin0_.author_id = bookjoin_a1_.id inner join review bookjoin_r2_ on bookjoin0_.review_id = bookjoin_r2_.id where bookjoin_a1_.name = ? limit ? 如果我想要针对 join 的表进行 on 条件查询，应该怎么做呢？ 下面来看下 04 版本。\n04 版本 - 加上 JOIN ON 条件筛选 创建一个新的单元测试\n@Test void multiQuery_04() { var query = BookJoinQuery.builder() .authorName(\u0026#34;Author_2\u0026#34;) .reviewScore(70) .build(); var spec = BookJoinSpec.multiQuery_04(query); var page = PageRequest.of(0, 5); var bookJoin = queryBySpecMethod(spec, page).getContent().get(0); assertThat(bookJoin.getAuthor().getName()).isEqualTo(\u0026#34;Author_2\u0026#34;); assertThat(bookJoin.getReview().getScore()).isEqualTo(70); } 首先直接对 join 条件进行 on 查询\nstatic Specification\u0026lt;BookJoin\u0026gt; multiQuery_04(BookJoinQuery param) { return (root, query, cb) -\u0026gt; { if (null != param.getBookPublishTime()) { query.where(cb.equal(root.get(\u0026#34;publishTime\u0026#34;), param.getBookPublishTime())); } if (null != param.getAuthorName()) { Join\u0026lt;Object, Object\u0026gt; author = root.join(\u0026#34;author\u0026#34;); author.on(cb.equal(author.get(\u0026#34;name\u0026#34;), param.getAuthorName())); } if (null != param.getReviewScore()) { Join\u0026lt;Object, Object\u0026gt; review = root.join(\u0026#34;review\u0026#34;); review.on(cb.equal(review.get(\u0026#34;score\u0026#34;), param.getReviewScore())); } return query.getRestriction(); }; } 此时生成的 SQL 语句如下，能够成功拼接 JOIN ON 条件但是出现 N + 1 问题，\nselect bookjoin0_.id as id1_1_, bookjoin0_.author_id as author_i3_1_, bookjoin0_.publish_time as publish_2_1_, bookjoin0_.review_id as review_i4_1_ from book bookjoin0_ inner join author bookjoin_a1_ on bookjoin0_.author_id = bookjoin_a1_.id and (bookjoin_a1_.name = ?) inner join review bookjoin_r2_ on bookjoin0_.review_id = bookjoin_r2_.id and (bookjoin_r2_.score = ?) limit ? select bookjoin_a0_.id as id1_0_0_, bookjoin_a0_.name as name2_0_0_ from author bookjoin_a0_ where bookjoin_a0_.id = ? select bookjoin_r0_.id as id1_2_0_, bookjoin_r0_.score as score2_2_0_ from review bookjoin_r0_ where bookjoin_r0_.id = ? 此时如果我们改用 fetch 的话，又不能进行 on 条件筛选，该怎么处理呢？\n这里的解决方案是引入一个新的注解 @EntityGraph，修改我们的查询方法\n主动声明查询方法返回的 Entity 明确需要进行 Fetch 的属性有哪些 @Override @EntityGraph(attributePaths = { \u0026#34;author\u0026#34;, \u0026#34;review\u0026#34; }) Page\u0026lt;BookJoin\u0026gt; findAll(Specification\u0026lt;BookJoin\u0026gt; spec, Pageable pageable); 再看一下生成的语句，很好，自动帮忙 fetch 出来了，并且也解决了 02 版本的分页查询问题\nselect bookjoin0_.id as id1_1_0_, bookjoin_a1_.id as id1_0_1_, bookjoin_r2_.id as id1_2_2_, bookjoin0_.author_id as author_i3_1_0_, bookjoin0_.publish_time as publish_2_1_0_, bookjoin0_.review_id as review_i4_1_0_, bookjoin_a1_.name as name2_0_1_, bookjoin_r2_.score as score2_2_2_ from book bookjoin0_ inner join author bookjoin_a1_ on bookjoin0_.author_id = bookjoin_a1_.id and (bookjoin_a1_.name = ?) inner join review bookjoin_r2_ on bookjoin0_.review_id = bookjoin_r2_.id and (bookjoin_r2_.score = ?) limit ? 注意 上面使用的示例是针对【强一对一关系】所以使用默认的连接类型 INNER JOIN\n当然也可以使用左外连接（右外连接不支持）\nroot.join(\u0026#34;author\u0026#34;, JoinType.LEFT); root.fetch(\u0026#34;author\u0026#34;, JoinType.LEFT); 扩展阅读 Advanced Spring Data JPA - Specifications and Querydsl REST Query Language with Spring Data JPA Specifications Spring Data JPA Specification DSL for Kotlin 🔗 链接 Github source Spring Data JPA使用Specification 👀总结 使用 SpringJPA 来写动态多条件连表查询，通过代码来控制 SQL 语句，需要对 JPA 以及 Hibernate 相关 API 相对熟练才可以写出优质的 SQL 语句生成。 和 MyBatis 可以直接拼接 SQL 的相比，各有应用场景。 整体来说用代码来写 JPA 的动态查询，对于习惯 SQL 语句的人来说，还是感觉隔了一层。 对于这样的分页连表查询，个人感觉还是 MyBatis 舒服一点，简单。 ","permalink":"https://lexcao.io/zh/posts/spring-data-jpa-join-table/","summary":"痛点 项目中使用 Spring Data JPA 作为 ORM 框架的时候，实体映射非常方便。Spring Data Repository 的顶层抽象完全解决单实体的查询，面对单实体的复杂查询，也能使用 JpaSpecificationExecutor\u0026lt;T\u0026gt; 构造 Specification\u0026lt;T\u0026gt; 轻松应对。\n而对于后台管理报表查询需求来说，需要进行连表多条件动态查询的时候，就显得无从下手。因为它并不像 MyBatis 一样能够在 XML 文件中写出动态 SQL 语句。\n尽管可以使用 EntityManager 动态拼接原生 SQL 语句，但是该方法返回值为 ResultSet ，也就是说查出来的实体映射关系需要手动映射（😢这样不太优雅，已经定义出实体，还需要自己去映射）。\n所以，本文的目的是，在现有实体关系的基础上，结合 Specification\u0026lt;T\u0026gt; 记录下 Spring Data JPA 多条件动态连表查询操作，以及其中的踩坑和优化。\n想要直接看结论的，请看这篇 Spring Data JPA 动态多条件连表查询最佳实践。\n基础操作 那么，让我们开始进入代码操作。【本文所有代码在此】\n前置说明 相关依赖 Java 11 SpringBoot 2.4.2 build.gradle\nplugins { id \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;2.4.2\u0026#39; id \u0026#39;io.spring.dependency-management\u0026#39; version \u0026#39;1.0.11.RELEASE\u0026#39; id \u0026#39;java\u0026#39; } dependencies { implementation \u0026#39;org.springframework.boot:spring-boot-starter-data-jpa\u0026#39; compileOnly \u0026#39;org.projectlombok:lombok\u0026#39; runtimeOnly \u0026#39;mysql:mysql-connector-java\u0026#39; annotationProcessor \u0026#39;org.","title":"Spring Data JPA 多条件连表查询 (2022 更新)"},{"content":"什么 我想写一篇关于我如何学习Rust的博客。\n请原谅我在 2022 年才开始学习这个伟大的编程语言。\n为了在实践中学习Rust，我构建了一个全栈待办应用。\n你可以在 这里 尝试。相关源码可以在 GitHub 上找到。\n现在，我准备写一下它是如何构建的。\n如何 首先，和大家一样，我也是从 The Book 中学习 Rust。这是一本不应该跳过入门学习 Rust 的好书。\n在学习了一些基本的语法之后，我尝试从零开始使用 Rust 构建一个全栈应用，这是一个使用 Rust tokio 的后端服务和一个使用 Rust WASM（Web Assembly）的前端页面。\n我将分别对这两部分做一个简单的介绍。\n后端 后台服务是一个的简单的 REST API。使用 actix-web 作为网络框架。\n我将写另一篇博客，介绍我如何使用 TDD 开发 Rust 后台服务。 被 Rust 编译器和 Borrow Checker 教育是一次特别的体验。 对于部署，我使用 Supabase 作为 Postgres 服务，使用 Railway 来运行后台服务 docker 镜像。\n前端 前端页面有在线和离线数据源，在线是从后台服务器获取数据，而离线是在本地存储。并且有一个按钮来切换它们。\n前台由 Rust WASM 和 yew 框架驱动，这是一个类似 React 基于组件构建 Web 应用框架。\n如果你熟悉 JSX，你可以在使用 Yew 时感到很自在。 在 Rust 中编写类似 React 的代码体验良好，而且真的很有趣。 但有一些不同之处我想与大家分享，晚点会写一篇博客来谈这个问题，所以敬请关注。 部署的话，是放在 Vercel 上进行托管，用 GitHub Action 来实现自动部署。\n结果 全栈 Rust 的好处之一是共享代码。通过使用 Cargo workspace 功能后端和前端可以共享这个公共包。其中包含了两边都可以使用的 requests 和 models。后端代码在集成测试的时候进行了测试，所以前端代码可以直接使用它而不需要额外测试和编码。\n整个开发体验的话就是所有 Rust 代码和一些少量 CSS。整体感觉不错。\n非常感谢 Rust 编译器，它是学习 Rust 的一位好老师。\n相关引用 源码 Rust The Book WASM actix-web yew Vercel Railway Supabase ","permalink":"https://lexcao.io/zh/posts/learn-rust-fullstack/","summary":"什么 我想写一篇关于我如何学习Rust的博客。\n请原谅我在 2022 年才开始学习这个伟大的编程语言。\n为了在实践中学习Rust，我构建了一个全栈待办应用。\n你可以在 这里 尝试。相关源码可以在 GitHub 上找到。\n现在，我准备写一下它是如何构建的。\n如何 首先，和大家一样，我也是从 The Book 中学习 Rust。这是一本不应该跳过入门学习 Rust 的好书。\n在学习了一些基本的语法之后，我尝试从零开始使用 Rust 构建一个全栈应用，这是一个使用 Rust tokio 的后端服务和一个使用 Rust WASM（Web Assembly）的前端页面。\n我将分别对这两部分做一个简单的介绍。\n后端 后台服务是一个的简单的 REST API。使用 actix-web 作为网络框架。\n我将写另一篇博客，介绍我如何使用 TDD 开发 Rust 后台服务。 被 Rust 编译器和 Borrow Checker 教育是一次特别的体验。 对于部署，我使用 Supabase 作为 Postgres 服务，使用 Railway 来运行后台服务 docker 镜像。\n前端 前端页面有在线和离线数据源，在线是从后台服务器获取数据，而离线是在本地存储。并且有一个按钮来切换它们。\n前台由 Rust WASM 和 yew 框架驱动，这是一个类似 React 基于组件构建 Web 应用框架。\n如果你熟悉 JSX，你可以在使用 Yew 时感到很自在。 在 Rust 中编写类似 React 的代码体验良好，而且真的很有趣。 但有一些不同之处我想与大家分享，晚点会写一篇博客来谈这个问题，所以敬请关注。 部署的话，是放在 Vercel 上进行托管，用 GitHub Action 来实现自动部署。","title":"通过构建全栈待办应用学习 Rust"},{"content":"通过使用 Kotlin / Java 中 Junit5 和 Mockito 测试框架，在预约功能中演示 TDD 开发流程。\nTDD 介绍 TDD（Test-Driven Development） 是一种开发流程，中文是「测试驱动开发」。用一句白话形容，就是「先写测试再开发」。先写测试除了能确保测试程式的撰写，还有一个好处：有助于在开发初期厘清程式介面如何设计。详细理论知识可以前往 Wiki 了解，这里不再过多介绍。\n测试驱动开发 Test Driven Development TDD 开发流程（5步） 术语说明：\n红灯 - Failure - 测试用例失败 绿灯 - Success - 测试用例成功 重构 - Refactor - 重构功能代码 具体步骤：\n选定一个功能，编写测试用例 执行测试，得到【红灯】 编写满足测试用例的功能代码 再次执行，得到【绿灯】 【重构】代码 小结：\n对于每一个功能，在【红灯】-【绿灯】-【重构】间来回循环往复，不断得到完善。\n前置工作 代码说明 使用 Kotlin 语言（会有相对应的 Java 代码） 使用到的测试框架 Running: JUnit5 Mock: MockK / Mockito Assertion: Kotest / AssertJ 只涉及 TDD 的具体流程，不涉及单元测试如何编写（可以看 SpringBoot 单元测试各层） 功能介绍 假设一个用户预约的场景。\n用户可以创建一个预约 同一个时间点，只有一个用户可以下单成功 使用到的库 kotlin plugins { java id(\u0026#34;io.freefair.lombok\u0026#34;) version \u0026#34;6.0.0-m2\u0026#34; kotlin(\u0026#34;jvm\u0026#34;) version \u0026#34;1.5.0-RC\u0026#34; } group = \u0026#34;io.github.lexcao\u0026#34; version = \u0026#34;1.0-SNAPSHOT\u0026#34; repositories { mavenCentral() } dependencies { implementation(kotlin(\u0026#34;stdlib\u0026#34;)) // for Java mocking and assertion testImplementation(\u0026#34;org.mockito:mockito-core:3.9.0\u0026#34;) testImplementation(\u0026#34;org.assertj:assertj-core:3.19.0\u0026#34;) // for Kotlin mocking and assertion testImplementation(\u0026#34;io.mockk:mockk:1.11.0\u0026#34;) testImplementation(\u0026#34;io.kotest:kotest-assertions-core:4.4.3\u0026#34;) testImplementation(\u0026#34;org.junit.jupiter:junit-jupiter-api:5.6.0\u0026#34;) testRuntimeOnly(\u0026#34;org.junit.jupiter:junit-jupiter-engine\u0026#34;) } tasks { test { useJUnitPlatform() } } ReservationService 前置 提前创建以下空文件，避免代码无法运行\nReservation.java ReservationService.java ReservationRepository.java Red - 01 - 编写单元测试 执行单元测试，显示【红灯】，代码分支：\nkotlin-red-01 java-red-01 kotlin @TestInstance(TestInstance.Lifecycle.PER_CLASS) internal class ReservationServiceImplTest { private val service: ReservationService = ReservationServiceImpl() @Nested inner class MakeReservation { private val time: LocalDateTime = LocalDateTime.of(2021, 5, 1, 21, 30) @Test fun shouldSuccess() { // given val reservation = Reservation(name = \u0026#34;Tom\u0026#34;, time = time) // actual val reserved: Reservation = service.makeReservation(reservation) // expect reserved shouldBe reservation } } } Green - 01 - 编写实现 执行单元测试，显示【绿灯】，代码分支：\nkotlin-green-01 java-green-01 kotlin class ReservationServiceImpl : ReservationService { override fun makeReservation(reservation: Reservation): Reservation { return reservation } } Red - 02 - 加入功能 - 完善单元测试 （注意：持久化层目前不需要关心，在这里使用 mock 相关功能）\n加入持久化逻辑，完善代码，显示【红灯】，代码分支：\nkotlin-red-02 java-red-02 kotlin private val mockRepository: ReservationRepository = mockk() private val service: ReservationService = ReservationServiceImpl(mockRepository) @AfterEach fun clear() { clearAllMocks() } @Test fun shouldSuccess() { // given every { mockRepository.save(any()) } returns reservation // verify verifySequence { mockRepository.save(reservation) } // ... } Green - 02 - 编写实现 - 完善功能 代码分支：\nkotlin-green-02 java-green-02 kotlin override fun makeReservation(reservation: Reservation): Reservation { return repository.save(reservation) } Red - 03 - 边界测试 当同一时间内已有预约的情况下，代码分支：\nkotlin-red-03 java-red-03 kotlin @Test fun shouldSuccess() { // given ... every { mockRepository.findByTime(time) } returns null // verify ... mockRepository.findByTime(time) } @Test fun shouldFailure() { // given val reservation = Reservation(name = \u0026#34;Tom\u0026#34;, time = time) every { mockRepository.findByTime(time) } returns reservation // actual shouldThrow\u0026lt;ReservationTimeNotAvailable\u0026gt; { service.makeReservation(reservation) } // verify verifySequence { mockRepository.findByTime(time) mockRepository.save(reservation) wasNot Called } } Green - 03 - 完善边界检查 kotlin override fun makeReservation(reservation: Reservation): Reservation { val mayBeReserved = repository.findByTime(reservation.time) if (mayBeReserved != null) { throw ReservationTimeNotAvailable } return repository.save(reservation) } Refactor - 简单的小重构 别忘了，重构完之后，运行一遍单元测试，【绿灯】。代码分支：\nkotlin-refactor override fun makeReservation(reservation: Reservation): Reservation { repository.findByTime(reservation.time)?.run { throw ReservationTimeNotAvailable } return repository.save(reservation) } 小结 一个简单的小功能通过 TDD 开发流程就此开发完成。\n完整代码\n🔗 参考链接 测试驱动开发 Test Driven Development TDD 開發五步驟，帶你實戰 Test Driven Development 範例 自動軟體測試-tdd-與-bdd spring-boot-testing testing-web-layer ","permalink":"https://lexcao.io/zh/posts/kotlin-java-tdd-example/","summary":"通过使用 Kotlin / Java 中 Junit5 和 Mockito 测试框架，在预约功能中演示 TDD 开发流程。\nTDD 介绍 TDD（Test-Driven Development） 是一种开发流程，中文是「测试驱动开发」。用一句白话形容，就是「先写测试再开发」。先写测试除了能确保测试程式的撰写，还有一个好处：有助于在开发初期厘清程式介面如何设计。详细理论知识可以前往 Wiki 了解，这里不再过多介绍。\n测试驱动开发 Test Driven Development TDD 开发流程（5步） 术语说明：\n红灯 - Failure - 测试用例失败 绿灯 - Success - 测试用例成功 重构 - Refactor - 重构功能代码 具体步骤：\n选定一个功能，编写测试用例 执行测试，得到【红灯】 编写满足测试用例的功能代码 再次执行，得到【绿灯】 【重构】代码 小结：\n对于每一个功能，在【红灯】-【绿灯】-【重构】间来回循环往复，不断得到完善。\n前置工作 代码说明 使用 Kotlin 语言（会有相对应的 Java 代码） 使用到的测试框架 Running: JUnit5 Mock: MockK / Mockito Assertion: Kotest / AssertJ 只涉及 TDD 的具体流程，不涉及单元测试如何编写（可以看 SpringBoot 单元测试各层） 功能介绍 假设一个用户预约的场景。","title":"Kotlin/Java TDD 开发流程记录"},{"content":"最近遇到一个平时没怎么关注的 Kotlin 相等问题，决定记录一下探究过程。\n事由 以下代码片段 Kotlin 版本 1.3.72。\n还原问题代码，已去除业务逻辑部分，仅保留关键代码，片段如下：\n// 有一个状态枚举 enum class MyState { OK, CANCELED } // 某个处理函数会返回 nullable MyState fun processing(): MyState? { // 假设当前某种情况下返回 取消 这个状态 return MyState.CANCELED } // 在处理状态时 fun handleState() { // 此时编译器推断出类型为 State? val state = processing() if (state == CANCELED) { // 当处理 CANCELED 以下代码没有执行 println(\u0026#34;Handle \u0026lt;CANCELED\u0026gt; state\u0026#34;) } } 当处理 CANCELED 代码没有执行，原因在于***「import」***。\nimport javax.print.attribute.standard.JobState.CANCELED // 此处使用静态导入引入了一个其他包中同名的一个静态变量，该变量声明如下 // public static final JobState CANCELED = new JobState (7); 解决方法：\n// 删除上面的静态引包，换成我们的 MyState if (state == MyState.CANCELED) { ... } 👏拍拍手，这个 BUG 改起来真容易。又可以愉快地摸鱼了呢。\n😠等等，作为静态语言面对如此诡异地类型不匹配为什么能够通过编译？\n🤔思考 ❓问题点：\n🤐 Kotlin 枚举类对比 Java 的一个静态变量，直觉上感觉类型不匹配的情况，为什么能够通过编译？ ❓❓❓头上的问号变多了：\nKotlin 中其他类型会出现这种类似的情况吗？ Kotlin 编译器具体怎么处理枚举类型的？ Java 会出现这种情况吗？（应该不会） 在 Stack Overflow 和 YouTrack 搜了一圈，没有找到想要的信息。 可能是搜索关键字不对😢。\n为了探个究竟，通过以下实验研究 Kotlin 编译器类型不匹配行为。\n「点击跳转到结果部分」\n🔬实验 第一步 实验预期 先看下各自的相等（equality）语法说明：\nJava 中，\n== 比较的是两个对象的引用，也就是内存地址。内存地址相同的前提是两个对象必须是同一种类型； equals() 比较的是两个对象的内容。 Kotlin 中，\nIn Kotlin there are two types of equality: Structural equality (a check for equals()).\na == b =\u0026gt; a?.equals(b) ?: (b === null) Referential equality (two references point to the same object);\na === b =\u0026gt; a and b point to the same object \u0026mdash; kotlin equality\n以下是简单翻译：\nKotlin 中有两种类型的相等：\n结构相等（对 equals() 的检查）\na == b =\u0026gt; a?.equals(b) ?: (b === null) 引用相等（两个引用指向同一对象）\na === b =\u0026gt; a 和 b 指向同一对像 简单来说，\nJava 中的 == 对应 Kotlin ===； Kotlin 中的 == 包含 Java equals 和 ==。 先设置一个预期：\nJava 中的相等，\nequals() 成功通过编译，程序正常运行； 方法入参是 Object，不同类型相比不会报错。 == 不能编译； 引用相同前提需要对象相同。 Kotlin 中的相等，\n=== 不能编译； 与 Java 的 == 行为一致，引用相同前提需要对象相同。 == 不能编译； a?.equals(b) ?: (b === null) 这里 equals 入参是 Any? 能够通过编译，但是后面会对比对象引用，凭直觉来看，有对比引用的话，如果类型不一致，不能编译。 第二步 收集变量 通过上面复现出的问题梳理出以下变量：\nvariable values 条件判断语句 Kotlin: if / when | Java: if / switch 表达式对象 Kotlin: class / enum class / object Java: class / enum / static field 表达式声明 K - K / J - J / J - K 第三步 初步筛选 对于条件判断语句，\nKotlin 的 if 和 when 的行为一致，所以这里可以只使用 if； Java 中 switch 仅支持 enum / String / primitive ，再加上对于 enum 有严格类型校验（语法层面，当 switch(enum) case 语句就处于该 enum 的上下文，只能使用该 enum 中定义的值。不考虑，同样只使用 if。 if (condition) {} 对于相等判断，\nJava 使用 == 和 equals()； Kotlin 仅使用 == （=== 行为与 Java 中 == 一致，故省略）。 对于表达式对象，每个实验对象定义 a / b ，b 用于同类型时备用。\n表达式对象 Java Kotlin class MyJavaClassA / MyJavaClassB MyKotlinClassA / MyKotlinClassB enum RetentionPolicy / ElementType AnnotationRetention / AnnotationTarget object / static JobState / JobStateReason MyKotlinObjectA / MyKotlinObjectB public class MyJavaClassA {} // MyJavaClassA.java public class MyJavaClassB {} // MyJavaClassB.java class MyKotlinClassA // MyKotlinClassA.kt class MyKotlinClassB // MyKotlinClassB.kt object MyKotlinObject // MyKotlinObjectA object MyKotlinObject // MyKotlinObjectB // RetentionPolicy : java.lang.annotation.RetentionPolicy // ElementType : java.lang.annotation.ElementType // AnnotationRetention : kotlin.annotation.AnnotationRetention // AnnotationTarget : kotlin.annotation.AnnotationTarget // JobState : javax.print.attribute.standard.JobState // JobStateReason : javax.print.attribute.standard.JobStateReason 对于表达式声明，还需要新增一个 Kotlin 中 nullable 类型\n// 总共有以下几类 J - J K - K K? - K? J - K J - K? K - K? 第四步 验证框架 // java 验证代码 public class JavaGenerated { void if_JavaClass_To_JavaClass(MyJavaClassB a) { if (a.equals(new MyJavaClassA())) { } else if (a == new MyJavaClassA()) { } } } // kotlin 验证代码 class KotlinGenerated { fun if_JavaClass_To_JavaClass(a: MyJavaClassB) { if (a == MyJavaClassA()) { } } } 第五步 编码验证 有了上面的模版之后，就可以根据变量开始编码验证。\n面对多种的变量组合的情况，手动编写大量的模版代码非常的劳累。\n所以利用工具，使用 JavaPoet 和 KotlinPoet 来生成代码。\n(花了一天来写自动生成代码逻辑，完成后感到一阵空虚，为什么要花那么多的时间折腾，手动复制粘贴早写完了。)\n😭这里大致说以下生成的思路：\n1. 分别枚举出需要测试的三种类型，JavaCase 和 KotlinCase 2. JavaCase 和 KotlinCase 中相两两组合 得到 java-kotlin 3. 根据 java-kotlin 再次组合 5 种情况 * J 2 J * J 2 K * K 2 K * K? 2 K * K? 2 J 4. 根据 java-kotlin-pairs 生成对应的 KotlinIf 和 JavaIf 方法 5. 根据方法，通过 JavaPoet 和 KotlinPoet 代码 生成后的代码挺多的，感兴趣的去看，这两个文件：\nJavaGenerated.java KotlinGenerated.kt 第六步 观察结果 环境如下\nJava Version 1.8.0_172 Kotlin Version 1.3.72 IDEA Version 2020.1 这里结果大致分为两类：\n[error] ，不能编译。编译器告警，在 IDEA 中红色波浪线标出； [warning] ，能够编译。IDEA 告警，以黄色背景高亮。 JavaGenerated.java 完全符合预期，\n== 不能编译； equals() 能够编译，另外 IDEA 给出友好提醒。 type == equals Class [error] Operator \u0026lsquo;==\u0026rsquo; cannot be applied [warning] inconvertible types Static [error] Operator \u0026lsquo;==\u0026rsquo; cannot be applied [warning] inconvertible types Enum [error] Operator \u0026lsquo;==\u0026rsquo; cannot be applied [warning] condition is always false KotlinGenerated.kt 部分符合预期，\n=== 不能编译； == 对于 Kotlin 的 Class / Static 不能编译。 type == Class [error] EQUALITY_NOT_APPLICABLE,Operator \u0026lsquo;==\u0026rsquo; cannot be applied Static [error] EQUALITY_NOT_APPLICABLE,Operator \u0026lsquo;==\u0026rsquo; cannot be applied Enum [warning] INCOMPATIBLE_ENUM_COMPARISON,Comparison of incompatible enums is always unsuccessful 不符合预期，\nJava Class / Static 可以编译； Enum 可以编译。 下面是相关代码：\nfun if_JavaClass_To_JavaClass(a: MyJavaClassB) { if (a == MyJavaClassA()) { } } fun if_JavaStatic_To_JavaStatic(a: JobStateReason) { if (a == JobState.CANCELED) { } } fun if_NullableKotlinEnum_To_JavaStatic(a: AnnotationRetention?) { if (a == JobState.CANCELED) { } } 以上情况可以归纳为：\nJava 对象类型(Class/Static)，能通过编译； JavaClass_To_JavaClass JavaStatic_To_JavaStatic 可空的 Kotlin 枚举类型对应 Java 静态类型，能通过编译； NullableKotlinEnum_To_JavaStatic 大致梳理出以下疑问点： 2. Class / Static 的对比为什么比 Java 的 equals 更严格？ 3. 为什么 Enum 的对比可以通过编译，没有像上面那么严格？ 4. 使用两个不同的 Java 的对象对比，为什么可以通过编译？ 5. nullable 的枚举类为什么可以与 Java 的静态类型对比？\n第七步 探究原因 再回顾一下 Kotlin 官方文档中对相等（equality）的定义：\na == b =\u0026gt; a?.equals(b) ?: (b === null) a === b =\u0026gt; a and b point to the same object 1. Class / Static 的对比为什么比 Java 的 equals 更严格？ （目前没有想清楚原因）TODO ：这里应该去看 Kotlin 编译器在处理 EQUALITY_NOT_APPLICABLE 这个报错。\n2. 为什么 Enum 的对比可以通过编译，没有像上面那么严格？ 在 Java 中 enum 其实是语法糖，最终会被编译为范型类。\nabstract class Enum\u0026lt;E extends Enum\u0026lt;E\u0026gt;\u0026gt; { ... } Kotlin 不例外，enum class 也是语法糖，最终会被编译为范型类。\nabstract class Enum\u0026lt;E : Enum\u0026lt;E\u0026gt;\u0026gt; { ... } 当两个枚举对比的时候，相当与是同一个类的不同范型，所以能够通过编译，不会出现类型不匹配问题。\n这里，IDEA 告警 INCOMPATIBLE_ENUM_COMPARISON 给出友好提示。\n3. 使用两个不同的 Java 的对象对比，为什么可以通过编译？ Kotlin 中有严格的 Nullable / Notnull 语法。\n当与 Java 的类进行互相调用时，由于 Java 中的 Null 信息不确定，编译器无法推断出 Java 类的具体 Null 信息(默认视为 Nullable)。 可以在 IDEA 的智能类型推断中看到 ! 的标识。 （在 Java 中显式使用 JetBrains 提供的 @Nullable / @NotNull 这两个注解，可以让 Kotlin 编译器正确推断出 Null 信息） 【TODO，提供 IDEA 截图更好】\n所以两个 Nullable 类型的进行比较的时候，会走到 b === null 这个判断，不会报错，能够编译。\n4. Kotlin nullable 的枚举类为什么可以与 Java 的静态类型对比？ 进行上述前置探索，终于到这次问题的终点。结合上面的结论，总结如下：\n枚举类编译后是同一个 Enum 类； Java 的静态类型 Null 信息未知； 两个 Nullable 类型进行对比，会走到 b === null 判断，不会报错，能够编译。 // 给 Java 的类明确的 Null 信息 // IDEA 出现友好警告 [INCOMPATIBLE_ENUM_COMPARISON] fun if_NullableKotlinEnum_To_JavaStatic(a: AnnotationRetention?) { // 使用 !! 告诉编译器，明确 Null 信息是 Notnull if (a == JobState.CANCELED!!) { // [INCOMPATIBLE_ENUM_COMPARISON] Comparison of incompatible enums // \u0026#39;AnnotationRetention?\u0026#39; and \u0026#39;JobState\u0026#39; is always unsuccessful } } 👀总结 整个探求真相的过程还是很有趣的； 最后知道真相后，还是自己太菜了，基础知识没有完全掌握； 深入探究了 Kotlin 和 Java 的相等和枚举相关的内容； 下一步：趁着这股好奇心，去了解 Kotlin 编译器的相等类型判断源码。 🔗相关链接 GitHub Source Code Kotlin Equality Docs JavaPoet KotlinPoet JavaGenerated.java KotlinGenerated.kt ","permalink":"https://lexcao.io/zh/posts/kotlin-equality-diving/","summary":"最近遇到一个平时没怎么关注的 Kotlin 相等问题，决定记录一下探究过程。\n事由 以下代码片段 Kotlin 版本 1.3.72。\n还原问题代码，已去除业务逻辑部分，仅保留关键代码，片段如下：\n// 有一个状态枚举 enum class MyState { OK, CANCELED } // 某个处理函数会返回 nullable MyState fun processing(): MyState? { // 假设当前某种情况下返回 取消 这个状态 return MyState.CANCELED } // 在处理状态时 fun handleState() { // 此时编译器推断出类型为 State? val state = processing() if (state == CANCELED) { // 当处理 CANCELED 以下代码没有执行 println(\u0026#34;Handle \u0026lt;CANCELED\u0026gt; state\u0026#34;) } } 当处理 CANCELED 代码没有执行，原因在于***「import」***。\nimport javax.print.attribute.standard.JobState.CANCELED // 此处使用静态导入引入了一个其他包中同名的一个静态变量，该变量声明如下 // public static final JobState CANCELED = new JobState (7); 解决方法：","title":"Kotlin 奇怪的相等现象探究"},{"content":"背景 Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词\n持久化对象，即实体 PO(Persistent Object) 传输对象 DTO(Data Transfer Object) 业务对象 BO(Business Object) 展示对象 VO(View Object) 等等…… 这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程： 1. 接收请求体 CreateOrderRequest 2. 根据 OrderQuery 构造查询对象查询订单 3. 构造 OrderEntity 进行持久化操作 4. 构造 OrderBO 进行下游消费 5. 返回响应体 CreateOrderResponse 可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。\n在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。 所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。\n注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现\n是什么 通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。 主要有两个注解：\n@Konvertable 生成裁剪的实体以及对应的转换方法 @Konvert 单独针对某个类生成转换方法 废话不多说来看怎么使用。\n怎么用 1. 引入依赖 // for build.gradle.kts repositories { maven(\u0026#34;https://jitpack.io\u0026#34;) } dependencies { kapt(\u0026#34;com.github.lexcao:konverter:master-SNAPSHOT\u0026#34;) implementation(\u0026#34;com.github.lexcao:konverter-annotation:master-SNAPSHOT\u0026#34;) } // for build.gradle repositories { maven { url \u0026#39;https://jitpack.io\u0026#39; } } dependencies { kapt \u0026#39;com.github.lexcao:konverter:master-SNAPSHOT\u0026#39; implementation \u0026#39;com.github.lexcao:konverter-annotation:master-SNAPSHOT\u0026#39; } 2. 在需要转换的类上加上注解 @Konvertable( To(name = \u0026#34;LoginDTO\u0026#34;, pick = [\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;]), To(name = \u0026#34;UserListDTO\u0026#34;, omit = [\u0026#34;password\u0026#34;]) ) @Konvert(to = UserVO::class) data class UserEntity( val id: Long, @Konvert.Field(\u0026#34;name\u0026#34;) val username: String, val password: String, @Konvert.By(GenderEnumConverter::class) val gender: Int ) 3. 生成的代码如下： // @Konvertable /** * Auto generated code by @Konvertable */ data class LoginDTO( val username: String, val password: String ) /** * Auto generated code by @Konvertable */ data class UserListDTO( val id: Long, val username: String, val gender: Int ) /** * Auto generated code by @Konvert */ fun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String = this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password) /** * Auto generated code by @Konvert */ fun LoginDTO.toUserEntity( id: Long = 0L, username: String = this@toUserEntity.username, password: String = this@toUserEntity.password, gender: Int = 0 ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun UserEntity.toUserListDTO( id: Long = this@toUserListDTO.id, username: String = this@toUserListDTO.username, gender: Int = this@toUserListDTO.gender ): UserListDTO = UserListDTO(id=id,username=username,gender=gender) /** * Auto generated code by @Konvert */ fun UserListDTO.toUserEntity( id: Long = this@toUserEntity.id, username: String = this@toUserEntity.username, password: String = \u0026#34;\u0026#34;, gender: Int = this@toUserEntity.gender ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun UserEntity.toRegisterDTO( username: String = this@toRegisterDTO.username, password: String = this@toRegisterDTO.password, gender: Int = this@toRegisterDTO.gender ): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun RegisterDTO.toUserEntity( id: Long = 0L, username: String = this@toUserEntity.username, password: String = this@toUserEntity.password, gender: Int = this@toUserEntity.gender ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) // @Konvert // 转换为如下对象 data class UserVO( val id: String, val name: String, val gender: GenderEnum ) enum class GenderEnum { MALE, FEMALE; } object GenderEnumConverter : Konvert.KonvertBy\u0026lt;Int, GenderEnum\u0026gt; { override fun Int.forward(): GenderEnum { return GenderEnum.values()[this] } override fun GenderEnum.backward(): Int { return this.ordinal } } // 生成的代码 ** * Auto generated code by @Konvert */ fun UserEntity.toUserVO( id: String = this@toUserVO.id.toString(), name: String = this@toUserVO.username, gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() } ): UserVO = UserVO(id=id,name=name,gender=gender) /** * Auto generated code by @Konvert */ fun UserVO.toUserEntity( id: Long = this@toUserEntity.id.toLong(), username: String = this@toUserEntity.name, password: String = \u0026#34;\u0026#34;, gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() } ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) 相关 API 说明 转换规则\n如果转换至 String 类型，原类型不匹配时会调用 toString() 如果转换至基础数据类型，转换字段缺失时会使用默认类型 如果转换至允许为 null 类型，原类型不匹配时会使用默认值 null 如果转换至引用类型（String 除外）或者找不到映射需要在转换方法显式赋值 下一步 代码重构，新增测试用例 支持引用类型默认值 支持嵌套对象 支持 Java 已知 BUG 修复 支持映射失败字段获取原类型的构造函数参数默认值，或者成员变量默认值（目前 Kotlin KAPT 已支持获取成员变量默认值，暂不支持获取函数参数默认值） 已知 BUG 相同 name 在 @Konvertable 冲突 @Konvertable 参数合法性校验以及友好报错 KonvertBy 目前使用 Class 报错或者使用 Companion 报错 最后 Konverter 源码在 GitHub\n相关的样例代码 GitHub\n","permalink":"https://lexcao.io/zh/posts/konverter/","summary":"背景 Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词\n持久化对象，即实体 PO(Persistent Object) 传输对象 DTO(Data Transfer Object) 业务对象 BO(Business Object) 展示对象 VO(View Object) 等等…… 这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程： 1. 接收请求体 CreateOrderRequest 2. 根据 OrderQuery 构造查询对象查询订单 3. 构造 OrderEntity 进行持久化操作 4. 构造 OrderBO 进行下游消费 5. 返回响应体 CreateOrderResponse 可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。\n在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。 所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。\n注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现\n是什么 通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。 主要有两个注解：\n@Konvertable 生成裁剪的实体以及对应的转换方法 @Konvert 单独针对某个类生成转换方法 废话不多说来看怎么使用。\n怎么用 1. 引入依赖 // for build.","title":"使用 KAPT 生成 Kotlin Data Class 转换器"},{"content":"背景 某次发版之后，线上服务低概率出现某台实例接口响应超时，具体表现为：\n/health 接口超时报警； 线程死锁，Tomcat 线程池吃满； 服务完全无响应。 保留下当前 heap dump 和 thread stack 后，临时重启服务器恢复正常。\n# heap dump $ jmap -dump:format=b,file=dump.hprof [pid] # thread stack jstack [pid] \u0026gt; stack.txt 接下来简单记录一下排查结果。 （此文为回忆所写，当时排查的思考细节和过程已省略）\n排查 heap dump 使用工具 Eclipse + MAT\n安装 # 安装 eclipse $ brew cask install eclipse-java # 安装 eclipse MAT $ brew cask install mat # 是的，这个就是 eclipse-mat 相关连接 Eclipse\nEclipse MAT\n使用 把 heap dump 文件 dump.hprof 导入到 MAT。\n发现有一个名称为 Spring-Async-Scheduler 异步队列占用特别大。【TODO 图片】\n这里排查方向有了：异步调用相关。\nthread stack 使用工具 直接作为 txt 打开，或者使用 IDEA 自带的线程栈分析。\n使用 打开 IDEA 菜单栏 Analyze \u0026gt; Analyze Stack Trace or Thread Dump； 复制 thread.txt 内容到窗口区； 官方说明 IDEA Analyze Stacktrace ； 如果是同一个项目的调用栈，IDEA 支持跳转到具体的方法，强烈推荐👍。 【TODO 图片】 排查 通过 IDEA 中友好的线程栈信息可见，【TODO 截图】\nTomcat-NIO 全部 200 个线程都在等待，没有线程继续处理后续的请求；\nSpring-Async 全部 4 个线程也在等待；\n\u0026#34;async-1\u0026#34; #151 prio=5 os_prio=0 tid=0x00007f18001a1000 nid=0x94 waiting on condition [0x00007f17be9ea000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for \u0026lt;0x00000000e176e988\u0026gt; (a java.util.concurrent.CompletableFuture$Signaller) \u0026#34;async-2\u0026#34; #152 prio=5 os_prio=0 tid=0x00007f18001a4800 nid=0x95 waiting on condition [0x00007f17be8e9000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for \u0026lt;0x00000000e177c3c8\u0026gt; (a java.util.concurrent.CompletableFuture$Signaller) \u0026#34;async-3\u0026#34; #153 prio=5 os_prio=0 tid=0x00007f18001dc800 nid=0x96 waiting on condition [0x00007f17be7e8000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for \u0026lt;0x00000000e1794a08\u0026gt; (a java.util.concurrent.CompletableFuture$Signaller) \u0026#34;async-4\u0026#34; #160 prio=5 os_prio=0 tid=0x00007f182002d800 nid=0x9d waiting on condition [0x00007f17be0e1000] java.lang.Thread.State: WAITING (parking) at sun.misc.Unsafe.park(Native Method) - parking to wait for \u0026lt;0x00000000e176e958\u0026gt; (a java.util.concurrent.CompletableFuture$Signaller) 为什么 Spring-Async-Pool 线程池只有 4 个线程 查看 @EnablePooledAsync \u0026gt; AsyncAutoConfigurer \u0026gt; PooledAsyncProperties\n// 默认配置如下 // 核心线程池大小 var corePoolSize: Int = Runtime.getRuntime().availableProcessors() // 最大线程池大小 var maxPoolSize: Int = Math.max(Runtime.getRuntime().availableProcessors() shl 2, 64) // 队列容量 var queueCapacity: Int = 500_00 这个自动配置类是平台组提供的通用组件，默认是使用 CPU 核数。\n已知服务器配置为 4 核，所以核心线程池数量为 4。\n🤔思考 4 个异步线程队列等待，Tomcat 的 200 个线程也在等待。\n会不会是异步调用中出现循环等待造成死锁？ （需要看一下这次版本上线新增的异步调用代码） 有没有可能在异步调用途中发生异常？ 可以根据 Tomcat 中已经阻塞的线程看下具体是哪些接口引起？ 查看代码 新上线的异步代码嫌疑最大，这里定位到一个调用异步方法，已删除业务逻辑，提取出以下代码结构：\n@GetMapping(\u0026#34;/test\u0026#34;) fun test() { val future = async { fetch(listOf(1,2,3)) } future.await() // #2 } fun fetch(ids: List\u0026lt;Long\u0026gt;): DTO { return async { doFetch() }.await() // #1 } 简单说一下上面代码的调用，async 内调用 fetch() 方法，而里面嵌套了一个 async 调用。\n这里调用方可能并不知道 fetch() 函数里面已经开启了一个异步调用，出现异步嵌套调用的现象。 下面分析一下「异步内调用异步」为什么会出现相互等待导致线程死锁。\n已知当前声明的 Async-Pool 线程池线程数为 4 个：\n并发请求出现，同时出现 4个以上 #1 在等待 #1 处产生的异步调用进入 Asnyc-Pool-Queue 中排队 #2 处等待 #1 中的返回 #1 在等待其子任务 #2 在等待 #1 但是队中等待的只有 #2，#1 的子任务还在排队中 出现相互等待的情况，导致无限等下去了 这里简单模拟了一下异步队列里面的任务情况 1. 当前队列为空 \u0026gt; async-pool - [] \u0026gt; async-pool-queue - [] 2. 一个请求进来 \u0026gt; async-pool - [#2, #1] \u0026gt; async-pool-queue - [] 3. 多个请求顺序进来 - 理想情况 \u0026gt; async-pool - [#2, #1, #2, #1] \u0026gt; async-pool-queue - [#2, #1] ---- 以下是异常情况 4. 当多个请求并发进来 - 实际上 \u0026gt; async-pool - [#2, #2, #2, #2] \u0026gt; async-pool-queue - [#1, #1, #1, #1, #1] --\u0026gt; 此处触发无限等待 结论 异步里面嵌套异步的情况，如果两个异步使用同一个异步队列，在并发情况下会出现异步线程相互等待导致死锁问题。\n解决方案：\n使用同一个线程池的异步线程禁止嵌套调用； 如果需要异步嵌套异步调用，两个异步需要拥有不同的异步队列。 参考链接 Eclipse Eclipse MAT JStack IDEA Analyze Stacktrace ","permalink":"https://lexcao.io/zh/posts/async-within-async/","summary":"背景 某次发版之后，线上服务低概率出现某台实例接口响应超时，具体表现为：\n/health 接口超时报警； 线程死锁，Tomcat 线程池吃满； 服务完全无响应。 保留下当前 heap dump 和 thread stack 后，临时重启服务器恢复正常。\n# heap dump $ jmap -dump:format=b,file=dump.hprof [pid] # thread stack jstack [pid] \u0026gt; stack.txt 接下来简单记录一下排查结果。 （此文为回忆所写，当时排查的思考细节和过程已省略）\n排查 heap dump 使用工具 Eclipse + MAT\n安装 # 安装 eclipse $ brew cask install eclipse-java # 安装 eclipse MAT $ brew cask install mat # 是的，这个就是 eclipse-mat 相关连接 Eclipse\nEclipse MAT\n使用 把 heap dump 文件 dump.hprof 导入到 MAT。","title":"一次线程死锁排查记录"},{"content":"Reactive Streams Reactive Streams 在 Netflix 、Pivotal 和 Lightbend 工程师于 2013 年底发起这项计划。\nReactive Streams 是一项提议，为无阻塞背压的异步流提供一个标准。这包括针对运行时环境（JVM 和 JavaScript）以及网络协议上的工作。\n你可以在 Reactive Streams 官网网站阅读这个原始规范。\n你也可以在 这里 阅读它的中文翻译。\n无阻塞背压的异步流处理 Reactive Streams 由以下组成：\n异步； 流式； 无阻塞； 背压（回压）。 以下是 Java 接口，你可以在 GitHub 阅读更详细内容。\npublic interface Publisher\u0026lt;T\u0026gt; { public void subscribe(Subscriber\u0026lt;? super T\u0026gt; s); } public interface Subscriber\u0026lt;T\u0026gt; { public void onSubscribe(Subscription s); public void onNext(T t); public void onError(Throwable t); public void onComplete(); } public interface Subscription { public void request(long n); public void cancel(); } public interface Processor\u0026lt;T, R\u0026gt; extends Subscriber\u0026lt;T\u0026gt;, Publisher\u0026lt;R\u0026gt; { } Reactive Extensions 用于可观察流的异步编程 API。\nReactiveX 是来自观察者模式、迭代器模式以及函数式编程的最佳创意组合。\n\u0026ndash; Reactive Extensions\nProject Reactor Reactor 是第四代 Reactive 函数库，基于 Reactive Streams 规范 在 JVM 上构建无阻塞应用。\n可组合性和可读性 以丰富的操作符方法操作数据流 订阅之前没有任何反应 背压或者消费者具有通知生产者生产速率过高能力 并发上的高级抽象 \u0026ndash; From Imperative to Reactive Programming\n功能：\n完全无阻塞； 集成 Java API： Completable Future Stream Duration Flux 和 Mono Flux：一个 Reactive Streams 发布者，具有 rx 操作符，它发出 0 到 N 个元素，然后完成。 Mono：一个 Reactive Streams 发布者，具有 rx 操作符，发出 一个 元素成功完成，或者一个异常。 实现了 Reactive Streams 规范。 你可以在 GitHub 阅读更多细节。\n当然，你可以根据这个 快速上手 Rx API 来学习基础的接口。\n这里有个 帮助你如何选择操作符\nReactor Netty Reactor Netty 基于 Netty 框架，提供无阻塞和背压就绪的 TCP/HTTP/UDP 客户端和服务端。\n\u0026ndash; Reactor Netty\nSpring Reactor WebFlux Reactive 技术栈的网络框架，Spring WebFlux，在 5.0版本后期加入。它是完全无阻塞，支持 Reactive Streams 背压，并且在 Netty、Undertow 以及 Servlet .3.1+ 等服务器上运行。\n\u0026ndash; Spring WebFlux\nRSocket 基于 Reactive Sreams 背压的一个二进制协议\n功能：\n双向的 多路复用 基于消息（message driven） 二进制协议 交互模型：\n请求-响应（ 1 对 1 ） 发送 - 忘却 （ 1 对 0 UDP） 请求 - 流式（ 1 对多，发布 / 订阅） 请求 - 通道 （多对多） 通信协议\nWebSocket TCP UDP 总结 Reactive Streams 是一个规范。\nProject Reactor 是基于规范的 JVM 实现。\nSpring WebFlux 是 Spring 框架集成 Project Reactor。\nRSocket 是基于规范二进制协议实现。\n参考链接 Reactive Streams Reactive Streams JVM Reactive Extensions Project Reactor Reactor Core 快速上手 Rx API 帮助你如何选择操作符 Reactor Netty Spring WebFlux ","permalink":"https://lexcao.io/zh/posts/reactive-overview/","summary":"Reactive Streams Reactive Streams 在 Netflix 、Pivotal 和 Lightbend 工程师于 2013 年底发起这项计划。\nReactive Streams 是一项提议，为无阻塞背压的异步流提供一个标准。这包括针对运行时环境（JVM 和 JavaScript）以及网络协议上的工作。\n你可以在 Reactive Streams 官网网站阅读这个原始规范。\n你也可以在 这里 阅读它的中文翻译。\n无阻塞背压的异步流处理 Reactive Streams 由以下组成：\n异步； 流式； 无阻塞； 背压（回压）。 以下是 Java 接口，你可以在 GitHub 阅读更详细内容。\npublic interface Publisher\u0026lt;T\u0026gt; { public void subscribe(Subscriber\u0026lt;? super T\u0026gt; s); } public interface Subscriber\u0026lt;T\u0026gt; { public void onSubscribe(Subscription s); public void onNext(T t); public void onError(Throwable t); public void onComplete(); } public interface Subscription { public void request(long n); public void cancel(); } public interface Processor\u0026lt;T, R\u0026gt; extends Subscriber\u0026lt;T\u0026gt;, Publisher\u0026lt;R\u0026gt; { } Reactive Extensions 用于可观察流的异步编程 API。","title":"Reactive 概览"},{"content":"翻译自 Reactive Streams\nReactive Streams 注：Reactive Streams 直译为响应式流，这里保留英文原词。\nReactive Streams 是一项提议，旨在为具有无阻塞背压的异步处理流提供标准。这包括针对运行环境（JVM 和 JavaScript）以及网络协议的努力。\nReactive Streams 是为了提供一个无阻塞背压异步流式处理的标准的一个提议。\nJDK9 java.util.concurrent.Flow 在 JDK 9 的 java.util.concurrent.Flow 中可用的接口，分别为 1 ：1 语义上各自对应于 Reactive Streams。这意味着将会有一个迁移期，库（Libraries）将采用 JDK 中的新类型，但是由于库的完全语义等效以及 Reactive Streams \u0026lt;-\u0026gt; Flow 适配器库和直接与 JDK Flow 类型兼容的 TCK，因此这个迁移期预计会很短。\n如果你有兴趣了解有关 JVM Reactive Streams，请阅读此 文章\n问题 在异步系统中，处理流数据（尤其是数量未先确定的的“实时”数据）需要特别注意。最突出的问题是，需要控制资源消耗，这样快速数据源不会压垮流目的地。为了在并行网络主机或一台多核机器上并行地使用计算资源，需要异步。\nReactive Streams 的主要目标是管理跨异步边界的流数据交换（考虑将元素传递到另一个线程或线程池），同时确保接收方不强制缓存任意数量的数据。换句话说，背压是此模型中不可或缺的一部分，以使在线程之间进行调节的队列收到限制。如果背压的通信是同步的，则异步处理的好处将被抵消（另请看 Reactive Manifesto），因此必须注意对 Reactive Streams 实现的所有方面进行完全无阻塞和异步行为授权。\n本说明书旨在允许创建许多符合要求的实现，这些实现通过遵守规则将能够平滑地互相操作，并在流应用程序的整个处理图中保留上述好处和特性。\n范围 Reactive Streams 的范围是找接口、方法和协议的最小集，这些接口、方法和协议将描述实现目标——无阻塞背压的异步处理流，所需要的操作和实体。\n端用户 DSLs（领域特定语言）或者协议绑定 API（应用编程接口）有目的地被排除在范围之外，以鼓励和支持可能使用不同编程语言的不同实现，以尽可能地遵循其平台的习惯用法。\n我们预计，接受这个 Reactive Streams 规范以及它的实现经验将共同导向广泛的集成，例如，包括将来 JDK 版本中的 Java 平台支持或者在将来的网页浏览器中网络协议的支持。\n工作组 基本含义 基本含义定义了如何通过背压来调节流中元素的传输。元素的传输方式，传输过程中的表现形式或者背压的信号发送方式均不属于本规范的一部分。\nJVM 接口（已完成） 工作组将基本语义应用于一组编程接口，这些编程接口的主要目的是允许使用共享内存堆在 JVM 内的对象和线程之间传递流，从而实现不同一致性的实现和语言绑定的互操作。\n在 2019 年 8 月 23 日，我们发布了针对 JVM 的 Reactive Streams 1.0.3 版本，包含了 Java API， 一个文本 说明, 一个 TCK 和 实现示例.\n1.0.3 的新功能是主 jar 中包含 JDK 9（适配器库）。Maven Central 上提供了相应的代码库：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.reactivestreams\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reactive-streams\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.reactivestreams\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reactive-streams-tck\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.reactivestreams\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reactive-streams-tck-flow\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.reactivestreams\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reactive-streams-examples\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这些代码的源码在 GitHub。请使用 GitHub Issues 来提供反馈。\n所有的库和说明都在 知识共享零 下发布到了公共领域。\n在 这里 阅读更多有关 Reactive Streams 1.0.3 相关内容。\n实现须知 为了着手实现最终规范，建议先阅读 README 和这个 Java API 文档，然后看一下这个 规范，再看一下这个 TCK 以及 示例实现。如果你对以上有任何问题，请先看一下 关闭的问题，如果尚未解决，请打开一个 新的问题。\n这项工作是在 reactive-streams-jvm 仓库执行的。\nJavaScript 接口 这个工作组定义了一组最小的对象属性，用于观察 JavaScript 运行环境中的流元素。目的是提供一个可测试的规范，该规范允许不同实现在同一个运行环境进行互操作。\n这项工作是在 reactive-streams-js 仓库执行的。\n网路协议 该工作组定义了用于在各种传输介质上传递 Reactive Streams，其中涉及到元素的序列化和反序列化。此类传输媒介例如 TCP，UDP，HTTP 和 WebSockets。\n这项工作是在 reactive-streams-io 仓库执行的。\n","permalink":"https://lexcao.io/zh/posts/reactive-streams/","summary":"翻译自 Reactive Streams\nReactive Streams 注：Reactive Streams 直译为响应式流，这里保留英文原词。\nReactive Streams 是一项提议，旨在为具有无阻塞背压的异步处理流提供标准。这包括针对运行环境（JVM 和 JavaScript）以及网络协议的努力。\nReactive Streams 是为了提供一个无阻塞背压异步流式处理的标准的一个提议。\nJDK9 java.util.concurrent.Flow 在 JDK 9 的 java.util.concurrent.Flow 中可用的接口，分别为 1 ：1 语义上各自对应于 Reactive Streams。这意味着将会有一个迁移期，库（Libraries）将采用 JDK 中的新类型，但是由于库的完全语义等效以及 Reactive Streams \u0026lt;-\u0026gt; Flow 适配器库和直接与 JDK Flow 类型兼容的 TCK，因此这个迁移期预计会很短。\n如果你有兴趣了解有关 JVM Reactive Streams，请阅读此 文章\n问题 在异步系统中，处理流数据（尤其是数量未先确定的的“实时”数据）需要特别注意。最突出的问题是，需要控制资源消耗，这样快速数据源不会压垮流目的地。为了在并行网络主机或一台多核机器上并行地使用计算资源，需要异步。\nReactive Streams 的主要目标是管理跨异步边界的流数据交换（考虑将元素传递到另一个线程或线程池），同时确保接收方不强制缓存任意数量的数据。换句话说，背压是此模型中不可或缺的一部分，以使在线程之间进行调节的队列收到限制。如果背压的通信是同步的，则异步处理的好处将被抵消（另请看 Reactive Manifesto），因此必须注意对 Reactive Streams 实现的所有方面进行完全无阻塞和异步行为授权。\n本说明书旨在允许创建许多符合要求的实现，这些实现通过遵守规则将能够平滑地互相操作，并在流应用程序的整个处理图中保留上述好处和特性。\n范围 Reactive Streams 的范围是找接口、方法和协议的最小集，这些接口、方法和协议将描述实现目标——无阻塞背压的异步处理流，所需要的操作和实体。\n端用户 DSLs（领域特定语言）或者协议绑定 API（应用编程接口）有目的地被排除在范围之外，以鼓励和支持可能使用不同编程语言的不同实现，以尽可能地遵循其平台的习惯用法。\n我们预计，接受这个 Reactive Streams 规范以及它的实现经验将共同导向广泛的集成，例如，包括将来 JDK 版本中的 Java 平台支持或者在将来的网页浏览器中网络协议的支持。","title":"Reactive Streams 规范翻译"},{"content":"简介 最近我在寻找一个方法给自己取一个英文名字，然后我发现这篇文章，如何选择一个英文名字。该文章在选择一个英文名字提出了一个行之有效的方法，我用该方法制作了一个应用来帮助选择一个英文名字。\n你可以在 这里 尝试一下。\n我会在下面展开讲一下那篇文章和这个应用。\n文章所说 以下是文章原文。\nDo not try to be creative in picking an English name.\nAvoid:\nDo not try to pick a fun or cute-sounding name from a movie, television, or video game character Do not pick a name that you think sounds cool or trendy, because Americans will think it sounds stupid Do not pick a name because your friends think it sounds cute, because your friends are not the Americans you have to interact with in the future Do not translate some positive-sounding word in your language into English and make that into your name Do:\nChoose a name from the 100 most popular names for your birth year If possible, choose a name that sounds somewhat similar to your real name Do not choose a variation as your official name Do not worry about what a name means 以下是我的翻译版本。\n不要尝试在选择一个英文名上富有创造力。\n避免：\n不要从电影，电视或者游戏里的角色去选择一个有趣或发音可爱的名字 不要选择一个你认为听起来很酷或者新潮的，因为美国人可能认为很蠢 不要选择一个名字因为你朋友认为听起来很可爱，因为你的朋友不是将来要和你互动的美国人 不要直接翻译一些你母语当中正面的词汇为英语并把它当作你的名字 推荐：\n从 你出生那年最流行的 100 个名字 里面选择一个 如果可以，选择一个听起来跟你真实名字有某些相似的名字 不要选择一个名字的变体作为你的官方名字 不要担心一个名字的含义 应用所做 从 你出生那年最流行的 100 个名字 里面选择一个\n我根据文章的建议从 美国社保局出生婴儿名字数据 下载了原始数据。\n把它放到了 GitHub 上，并且已经做了一个 JSON 格式的。\n请在阅读他们的 说明 之后免费使用，Enjoy！\n我是怎么选择的 从我的中文名中找灵感，Lixin Cao，我想要一个以 L 开头的英文名。 找到我出生年的英文名字，选出一些我喜欢的。 Levi Alex Lucas Liam 带上我的姓氏，比如 LeviCao，去社交网站看一下有没有被占用。 Levi （圣经相关的） Alex （已经被人占用） Lucas （太流行） Liam （太流行） 在 nameberry 和 behindthename 搜索名字的含义和一些变体。 我最喜欢 Alex，然后我最后选择了 Lex 作为我的英文名字。 参考链接 英文名选择器 英文名选择器 源码 美国社保局英文名数据 GitHub 如何选择一个英文名 美国社保局出生婴儿名字 美国社保局出生婴儿名字数据 ","permalink":"https://lexcao.io/zh/posts/choose-english-name/","summary":"简介 最近我在寻找一个方法给自己取一个英文名字，然后我发现这篇文章，如何选择一个英文名字。该文章在选择一个英文名字提出了一个行之有效的方法，我用该方法制作了一个应用来帮助选择一个英文名字。\n你可以在 这里 尝试一下。\n我会在下面展开讲一下那篇文章和这个应用。\n文章所说 以下是文章原文。\nDo not try to be creative in picking an English name.\nAvoid:\nDo not try to pick a fun or cute-sounding name from a movie, television, or video game character Do not pick a name that you think sounds cool or trendy, because Americans will think it sounds stupid Do not pick a name because your friends think it sounds cute, because your friends are not the Americans you have to interact with in the future Do not translate some positive-sounding word in your language into English and make that into your name Do:","title":"选择一个英文名字"},{"content":"选择一个合适的静态网站生成器比较难，尤其是当你第一次想要搭建一个博客网站的时候。这是我第一次搭建一个博客并且没有足够的时间去尝试所有常见的生成器，我选择了 Jekyll 作为第一次搭建使用的生成器，尽管它可能不是最好的一个。我准备以后再尝试其他生成器。\n这是我从 Google 找到的一些简要的描述，希望它能对你选择什么生成器开始搭建网站有帮助。\n我从 GitHub 选择了以下三个静态博客生成器进行比较\nJekyll Hugo Hexo 什么是静态网站生成器 HTML 文件； 没有服务端处理或者数据库交互； 比动态网站更安全； 利于使用 CDN 进行扩展； 缓存会带来比动态网页更高的效率； 请求超快速。 Jekyll 使用语言 Ruby； GitHub 支持； 使用 GitHub Pages 免费部署。 优势 免费且开源； RubyGems 支持构建主题为 gems 方便分发； 简单便捷使用； 强大的 GitHub Pages 支持； 开箱即用的合适的默认极简主题。 劣势 当网站内容不断增加后，构建速度会明显变慢。\n功能 Liquid 模版引擎； 基于 Gem 主题； Markdown 和 YAML 类型支持； Sass 预处理 CSS 支持； 官方插件支持 CoffeeScript。 Hugo 使用语言 Go. 优势 免费开源； 速度非常快，对构建速度做了优化； 内置支持很多功能： 动态 API 请求的内容； 无限制内容类型； shortcakes， 一个灵活的 Markdown 替代； 国际化； 别名重定向； 分页。 预制的 Go 模版和模式； 无需依赖（不用安装 Go，因为它是编译好的二进制）； 功能强大的内容模型。 劣势 主题使用 Go 模版，所以需要熟悉 Go； 没有内置默认主题； 缺少扩展性和插件（因为 Go 是编译型语言）。 功能 Go 模版； 国际化; 支持动态 API。 Hexo 使用 Node.js. 优势 相当快速； 在 GitHub Pages 部署简单； 中文支持（可能是劣势对于非中文用户）； 中文社区。 劣势 没有英文。 功能 EJS 模版引擎; 支持 中文; 对于 HTML + CSS + Javascript 非常友好。 我正在使用 Jekyll\n喜欢 非常多的免费主题和插件； 有很多教程对于初学者来说； 不需要任何技能就能部署到 GitHub Pages 上。 不喜欢 对于大多数插件没有被 GitHub Pages 支持； 不支持国际化。 顺便一提，由于目前文章数量比较少，构建速度不在我的考虑范围之内，将来如果用 Jekyll 明显感到构建变慢的时候，我就会尝试其他的生成器。\n以上三个生成器的构建速度排名：Hugo \u0026gt; Hexo \u0026gt; jekyll。\n下一个将来要尝试的生成器应该是 Hugo，到时候我会更新这篇文章，写一些实际的使用感受。\n参考链接 如何选择正确的静态生成器 Jekyll vs. Hugo vs. Hexo 静态网站生成器比较 ","permalink":"https://lexcao.io/zh/posts/jekyll-hugo-hexo/","summary":"选择一个合适的静态网站生成器比较难，尤其是当你第一次想要搭建一个博客网站的时候。这是我第一次搭建一个博客并且没有足够的时间去尝试所有常见的生成器，我选择了 Jekyll 作为第一次搭建使用的生成器，尽管它可能不是最好的一个。我准备以后再尝试其他生成器。\n这是我从 Google 找到的一些简要的描述，希望它能对你选择什么生成器开始搭建网站有帮助。\n我从 GitHub 选择了以下三个静态博客生成器进行比较\nJekyll Hugo Hexo 什么是静态网站生成器 HTML 文件； 没有服务端处理或者数据库交互； 比动态网站更安全； 利于使用 CDN 进行扩展； 缓存会带来比动态网页更高的效率； 请求超快速。 Jekyll 使用语言 Ruby； GitHub 支持； 使用 GitHub Pages 免费部署。 优势 免费且开源； RubyGems 支持构建主题为 gems 方便分发； 简单便捷使用； 强大的 GitHub Pages 支持； 开箱即用的合适的默认极简主题。 劣势 当网站内容不断增加后，构建速度会明显变慢。\n功能 Liquid 模版引擎； 基于 Gem 主题； Markdown 和 YAML 类型支持； Sass 预处理 CSS 支持； 官方插件支持 CoffeeScript。 Hugo 使用语言 Go. 优势 免费开源； 速度非常快，对构建速度做了优化； 内置支持很多功能： 动态 API 请求的内容； 无限制内容类型； shortcakes， 一个灵活的 Markdown 替代； 国际化； 别名重定向； 分页。 预制的 Go 模版和模式； 无需依赖（不用安装 Go，因为它是编译好的二进制）； 功能强大的内容模型。 劣势 主题使用 Go 模版，所以需要熟悉 Go； 没有内置默认主题； 缺少扩展性和插件（因为 Go 是编译型语言）。 功能 Go 模版； 国际化; 支持动态 API。 Hexo 使用 Node.","title":"Jekyll / Hugo / Hexo 比较"},{"content":"实现目标 支持多语言，英文为主，中文为辅； 当访问 / 根目录下页面，比如 /about.html /posts/hello-world 显示英文页面； 当访问 /zh/ 目录下页面，比如 /zh/about.html /zh/posts/hello-world 显示中文页面； 当访问 ../hello-world 文章时，可以通过链接跳转到对应语言页面； archive 和 index 页面中仅显示出当前语言页面。 相关缺陷 404 页面无法配置，只能在 404.html 页面写上两种语言； 支持多语言文章的分页插件 jekyll-paginate-v2 没在 GitHub Pages 支持的插件白名单内，目前本博客首页不支持分页。多语言分页详见下文； 多语言时间表示有点麻烦，需要做一些字符串处理工作，能实现但是不太优雅，具体可以参考 Jekyll-Date-Formatting。 开始配置 最初，我搜索到 i18n 插件 Jekyll-Multiple-Languages-Plugin。\n该仓库的 Star 数是多语言插件中最多的，同时里面也列出了相关其他多语言插件，已经比较完善，不想折腾的可以直接使用。\n目前我为了简单和可定制化，同时省略掉插件中不必要的功能，选择使用自定义规则来实现多语言功能。\n1. 单个博文配置 每一篇文章和页面需要定义两个属性：\nuid 标示文章唯一，一篇文章的中文版本和英文版本 uid 相同； 注意：uid 可以设置为任意命名，比如 document_id 。 locale 标示文章语言，一篇文章被渲染后作为哪种语言展示。 所以每篇文章的 Front Matter 新增如下设置\n--- uid: hello-world locale: zh --- 2. 对于文章 posts 每篇文章都需要在 Front Matter 中写上 locale 重复多余。不要重复自己。我准备使用不同文件夹来区分不同语言的文章，然后在配置文件设置 locale 的默认值。\n在 _posts 目录下创建 zh 文件夹用于存放中文文章。当访问 /zh/posts/xxx 时即展示中文页面。\n（当然，也可以设置不同的目录，参照以下配置进行设置不同的 path ）\ndefaults: - values: #1 locale: en - scope: #2 path: _posts/zh/** type: posts values: locale: zh #1 未指定 scope 全局默认：所有文章 posts 和页面 pages 默认 en； #2 指定 scope 路径 _posts/zh/** 下 posts 类型：zh。 3. 对于页面中通用的字符串 导航栏中 归档 关于 或者 下一页 等这样的通用字符串。\n使用 site.data 功能来实现，在 /_data 目录下创建 locales 文件夹，并分别创建 en.yml 和 zh.yml 用于存放英文和中文字符串。\n# /_data/locales/en.yml 文件中 menu: about: About archive: Archive # /_data/locales/zh.yml 文件中 menu: about: 关于 archive: 归档 配置好这些字符串后，在需要替换文字的地方使用\n\u0026lt;nav class=\u0026#34;menu-content\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/about\u0026#34;\u0026gt;{{ site.data.locales[page.locale].menu.about }}\u0026lt;/a\u0026gt; \u0026lt;/nav\u0026gt; 4. 对于页面 pages 一些通用页面：archive.html about.html 等 pages 类型。\n单独在项目根目录下创建一个文件夹 _zh，并作为 collection 来配置\ncollections: zh: output: true 在 _zh 文件夹下创建对应页面\n/menu/archive.html /menu/about.html 5. 语言选择器 用于在不同语言的文章或页面中根据 locale 进行切换。\n在 _includes 文件夹下添加一个新文件 language-selector.html。\n遍历 posts、 pages 和 collections 找到相应的语言页面\n{% if page.uid %} \u0026lt;!-- #1 --\u0026gt; \u0026lt;div class=\u0026#34;language-selector\u0026#34;\u0026gt; {% assign postsOrPages = site.posts \u0026lt;!-- #2 --\u0026gt; | concat: site.pages | concat: site.zh | where: \u0026#34;uid\u0026#34;, page.uid | sort: \u0026#34;locale\u0026#34; %} {% for item in postsOrPages %} {% unless item.url contains \u0026#39;/page/\u0026#39; %} \u0026lt;!-- #3 --\u0026gt; \u0026lt;a href=\u0026#34;{{ item.url }}\u0026#34; class=\u0026#34;{{ item.locale }}\u0026#34;\u0026gt; {{ site.data.locales[item.locale].name }} \u0026lt;!-- #4 --\u0026gt; \u0026lt;/a\u0026gt; {% endunless %} {% endfor %} \u0026lt;/div\u0026gt; {% endif %} #1 仅在有 uid 的页面显示语言选择器 #2 拼接 posts pages zh 数组，找到 uid 对应的页面，根据 local 排序 #3 过滤掉 /pages/ 目录下页面 #4 拿到 locale 对应的语言文字，如 EN 中 6. 归档页面 需要手动多虑掉非本语言页面的文章。\npost.next 提供便捷获取下一篇文章的方法，但是在多语言文章中无法保证 locale 的一致性，需要作出如下修改\n\u0026lt;!-- archive.html --\u0026gt; \u0026lt;!-- 使用 posts 的下标，而不用 post.next --\u0026gt; {% assign posts = site.posts | where: \u0026#34;locale\u0026#34;, page.locale %} {% for index in (0..posts.size) limit: posts.size %} {% assign post = posts[index] %} {% assign prevIndex = index | minus: 1 %} {% assign prev = posts[prevIndex] %} {% capture year %}{{ post.date | date: \u0026#39;%Y\u0026#39; }}{% endcapture %} {% capture prevYear %}{{ prev.date | date: \u0026#39;%Y\u0026#39; }}{% endcapture %} {% if year != prevYear or index == 0 %} \u0026lt;h3\u0026gt;{{ year }}\u0026lt;/h3\u0026gt; {% endif %} \u0026lt;li itemscope\u0026gt; \u0026lt;a href=\u0026#34;{{ post.url }}\u0026#34;\u0026gt;{{ post.title }}\u0026lt;/a\u0026gt; \u0026lt;p class=\u0026#34;post-date\u0026#34;\u0026gt;\u0026lt;span\u0026gt;{{ post.date | date: \u0026#34;%B %-d\u0026#34; }}\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; {% endfor %} 核心思想：先根据 locale 过滤，遍历的时候使用下标而不是 post.next。\n7. 多语言 SEO 在 _includes 文件夹下面创建一个新页面 language-seo.html。\n通过 hreflang 指示对应的语言\n{% assign posts = site.posts | where:\u0026#34;uid\u0026#34;, page.uid | sort: \u0026#39;locale\u0026#39; %} {% for post in posts %} \u0026lt;link rel=\u0026#34;alternate\u0026#34; hreflang=\u0026#34;{{ post.locale }}\u0026#34; href=\u0026#34;{{ post.url }}\u0026#34; /\u0026gt; {% endfor %} 并且在 head.html 引用\n\u0026lt;!-- Language SEO --\u0026gt; {% include language-seo.html %} 最后 我省略了一些不重要的常规配置，源码请看 GitHub: lexcao.github.io\n相关参考链接 Jekyll Multiple Language Plugin Making Jekyll Multilingual Multi-Languages-with-Jekyll Deploy A Multi-Language Jekyll Site jekyll-paginate-v2 另一件事 多语言支持分页 旧的分页插件 jekyll-pagination-v1 无法根据筛选条件过滤已经不再适合，不能在对应的语言页面显示对应的语言文章列表。\n如果想在多语言下支持分页，可以使用 jekyll-pagination-v2。我上面提到过 Github Pages 插件 白名单列表 不支持该插件，如果需要使用就需要 手动实现部署。以下是如何配置使用 jekyll-pagination-v2\nGemfile 安装 $ gem \u0026#39;jekyll-paginate-v2\u0026#39; _config.yml 配置 注意：v2 和 v1 的配置不兼容，需要按照如下配置做相应修改\nplugins: - jekyll-paginate-v2 pagination: enabled: true per_page: 5 permalink: /page/:num/ sort_reverse: true pages 页面配置 首页 index.html 进行分页，需要添加如下配置\n# /index.html --- pagination: enabled: true # 是的，这里还需要再次开启一次 locale: en --- pagination.locale 此处用来配置分页筛选条件，根据页面的 locale 字段进行过滤。这也是我在 Front Matter 用 locale 字段来标志语言的原因，复用。\n对应的，在 _zh 文件夹下面创建中文首页 index.html。\n# /_zh/index.html --- permalink: /zh/ # 此处是为了让首页不显示 .html 后缀 pagination: enabled: true locale: zh --- 注意：我在这里配置的时候，遇到一个问题，当我把 index.html 放到 _zh 文件夹后，分页 locale 筛选不起作用，目前还没解决。\n临时解决方案是将 zh/index.html 放在根目录，并改名为 index_zh.html。\n分页使用 使用没有变化，和 v1 一样的使用方式，详细请看 Pagination\n相关参考链接 Jekyll-Paginate-v2 Jekyll-Paginate-V2 Filter Locales ","permalink":"https://lexcao.io/zh/posts/jekyll-multi-language-without-plugin/","summary":"实现目标 支持多语言，英文为主，中文为辅； 当访问 / 根目录下页面，比如 /about.html /posts/hello-world 显示英文页面； 当访问 /zh/ 目录下页面，比如 /zh/about.html /zh/posts/hello-world 显示中文页面； 当访问 ../hello-world 文章时，可以通过链接跳转到对应语言页面； archive 和 index 页面中仅显示出当前语言页面。 相关缺陷 404 页面无法配置，只能在 404.html 页面写上两种语言； 支持多语言文章的分页插件 jekyll-paginate-v2 没在 GitHub Pages 支持的插件白名单内，目前本博客首页不支持分页。多语言分页详见下文； 多语言时间表示有点麻烦，需要做一些字符串处理工作，能实现但是不太优雅，具体可以参考 Jekyll-Date-Formatting。 开始配置 最初，我搜索到 i18n 插件 Jekyll-Multiple-Languages-Plugin。\n该仓库的 Star 数是多语言插件中最多的，同时里面也列出了相关其他多语言插件，已经比较完善，不想折腾的可以直接使用。\n目前我为了简单和可定制化，同时省略掉插件中不必要的功能，选择使用自定义规则来实现多语言功能。\n1. 单个博文配置 每一篇文章和页面需要定义两个属性：\nuid 标示文章唯一，一篇文章的中文版本和英文版本 uid 相同； 注意：uid 可以设置为任意命名，比如 document_id 。 locale 标示文章语言，一篇文章被渲染后作为哪种语言展示。 所以每篇文章的 Front Matter 新增如下设置\n--- uid: hello-world locale: zh --- 2. 对于文章 posts 每篇文章都需要在 Front Matter 中写上 locale 重复多余。不要重复自己。我准备使用不同文件夹来区分不同语言的文章，然后在配置文件设置 locale 的默认值。","title":"Jekyll 不使用插件支持多语言"},{"content":"你好 网上邻居 欢迎来到我的博客，我是 曹历鑫 Lex Cao。\n本博客名为 代码笔记 CodingNotes。\n本博客用于 分享/总结/记录 我的生活或工作中跟编程有关的 知识/思考/想法。\n关于我 现居 深圳。\n使用\nJava / Kotlin（主要使用 ❤️）； SpringBoot； SpringCloud。 如果你想 联系我。\n关于博客 静态网站生成器\nJekyll 4.0 https://jekyllrb.com/ 使用主题 Lagrange http://jekyllthemes.org/themes/lagrange/ 代码托管\nGitHub 博客源码在这里 博客部署\nGitHub Pages 中英支持 为了更好的练习英文，本博客支持中文和英文两种语言。有对应语言的页面时，可以点击右上角的语言字符进行切换。\n顺便一提，本博客以英文为主，当然，也会有相应的中文内容。\n敬请期待。\n感谢你的驻足 相关链接 Code icon by Icons8 Powered by Jekyll with Lagrange theme Deployed by GitHub Pages Free to use photos by Pexels Free to use photos by Unsplash ","permalink":"https://lexcao.io/zh/about/","summary":"你好 网上邻居 欢迎来到我的博客，我是 曹历鑫 Lex Cao。\n本博客名为 代码笔记 CodingNotes。\n本博客用于 分享/总结/记录 我的生活或工作中跟编程有关的 知识/思考/想法。\n关于我 现居 深圳。\n使用\nJava / Kotlin（主要使用 ❤️）； SpringBoot； SpringCloud。 如果你想 联系我。\n关于博客 静态网站生成器\nJekyll 4.0 https://jekyllrb.com/ 使用主题 Lagrange http://jekyllthemes.org/themes/lagrange/ 代码托管\nGitHub 博客源码在这里 博客部署\nGitHub Pages 中英支持 为了更好的练习英文，本博客支持中文和英文两种语言。有对应语言的页面时，可以点击右上角的语言字符进行切换。\n顺便一提，本博客以英文为主，当然，也会有相应的中文内容。\n敬请期待。\n感谢你的驻足 相关链接 Code icon by Icons8 Powered by Jekyll with Lagrange theme Deployed by GitHub Pages Free to use photos by Pexels Free to use photos by Unsplash ","title":"关于"},{"content":"博客配置：\n静态网页生成器 Jekyll 3.8.5 Ruby 2.6.0 主题 lagrange 网页分析 Google Aynalysis Baidu Aynalysis 部署 GitHub Pages 这是我的第一篇文章，作为最简单的 “你好 世界”，我想记录一下该博客的诞生过程，以及如果你也想搭建一个自己的博客应该怎么做。\n本文章将会涉及三个部分：\n选择博客类型 准备好所需内容 将他们编排起来 第一步 选择博客类型 根据前端网页是否与后台服务器或者数据库交互分为：静态网站 / 动态网站\n静态网站：\n仅依靠 HTML / CSS / JS 没有后台服务器存储数据 数据是预先生成的 动态网站：\n依赖前端 HTML / CSS / JS 数据从后台服务器获取 能够动态响应用户请求 所以，静态博客：\n文章预先生成 不依赖后台服务器 动态博客：\n文章从后台服务器获取 前端页面动态获取 考虑到刚接触到博客搭建，先从简单的静态博客入手。目前 GitHub 上有很多开源的静态网站生成器，这里我选择使用 Jekyll。\n选择合适的静态博客生成器请看 [Jekyll / Hugo / Hexo 比较]({{ \u0026ldquo;/zh/posts/jekyll-hugo-hexo\u0026rdquo; | relative_url }})。\n第二步 准备好所需内容 准备内容涉及以下方面：\n博客文章 博客介绍 作者信息 博客域名 博客文章 提前写好文章准备发布\nGitHub Pages 部署记录（本文 😆） [Jekyll 不使用插件支持多语言]({{ \u0026ldquo;/zh/posts/jekyll-multi-language-without-plugin\u0026rdquo; | relative_url }})（本博客是中文和英文 😆） [Jekyll / Hugo / Hexo 比较]({{ \u0026ldquo;/zh/posts/jekyll-hugo-hexo\u0026rdquo; | relative_url }})（本博客用 Jekyll 😆） 如何选择一个英文名（Lex Cao 😆） 博客介绍 提前写好博客介绍，博客创建初期可以只包含简略信息，以后再慢慢补充，\n详细请看 [关于]({{ \u0026ldquo;/zh/menu/about.html\u0026rdquo; | relative_url }})。\n作者信息 笔名 这里我给自己取了一个英文名 Lex Cao\n取英文名可以参考 如何选择一个英文名\n博客名 中文名 代码笔记\n英文名 CodingNotes\n博客域名 caolixin.com 中文拼音没实际意义\nlexcao.com 已经被占用\nthecodingnotes.com 好像不错，但是有点长\n第三步 编排起来 Jekyll 安装 相关参考链接\nInstall on MacOS Jekyll with Bundle Creating a GitHub Pages with Jekyll 使用到的命令\n# install ruby 2.6.0+ $ xcode-select --install $ brew install ruby $ export PATH=/usr/local/opt/ruby/bin:$PATH $ source ~/.zshrc # install jekyll \u0026amp; bundler $ gem install --user-install bundler jekyll $ export PATH=$HOME/.gem/ruby/2.6.0/bin:$PATH $ source ~/.zshrc # init $ cd /blogs/github-pages-jekyll $ git init $ jekyll new . $ jekyll serve # serve with bundle $ bundle exec jekyll serve 主题选择 关于主题，我比较喜欢简约一点。\n在相关主题浏览网站：\njekyllthemes.org/ jekyllthemes.io/ 找到的心仪的主题：\nLagrange Chalk Type Kikofri 选出以上 4 个主题，最后使用 lagrange 作为博客主题。\n插件说明 GitHub Pages 集成 Jekyll 实现自动部署需要插件 github-pages。该插件仅允许使用白名单内插件，具体请看允许插件及版本； 要想使用自定义插件（白名单以外的插件），不能 GitHub Pages 的自动部署功能，需要将 _site 目录放到仓库上，手动实现自动部署； 本次是第一次搭建博客，所以选用了 GitHub Pages 的自动部署。 多语言配置 多语言配置，需要折腾的地方比较多，详细请看文章\nJekyll 不使用插件支持多语言。\n部署到 GitHub Pages 官方教程\n创建一个仓库 仓库名需要按照固定格式 \u0026lt;user\u0026gt;.github.io\n如：lexcao.github.io\n将文章推到 GitHub # 添加远程仓库 $ git remote add origin https://github.com/lexcao/lexcao.github.io.git $ git push -u origin master 网站已可以访问 进入仓库设置页面 Settings \u0026gt; Options \u0026gt; 拉到最下面，\nYour site is published at https://lexcao.github.io/ 博客已经发布成功。\n访问 https://lexcao.github.io/ 即可看到。\n可以在 environment 看到博客部署情况，默认配置是 master 分支有代码更新会进行自动部署。\n网站统计 博客可以访问以后，就可以开始接入网站统计相关功能，借助第三方平台。\nGoogle Analytics 在 Google Analytics 创建媒体资源，拿到一个 UA-xxx-x ID，并且引入统计代码； 在 Google Tag Manager 创建跟踪代码，根据上面拿到的 UA-xxx-x ID 新增一个 Google Analytics 代码跟踪，引入全局统计代码，并发布。 可选择，在 Google Analytics 关联 Google Search Console。 注意事项：\nGoogle Tag Manager 不允许变量为中文名; 重新发布 GitHub Pages 生效后，如果请求 js 文件 net::ERR_BLOCKED_BY_CLIENT 错误，关掉广告拦截插件重试。 Baidu Analytics 在 百度统计 关联上网页，引入统计代码，完成配置。\n实时性比 Google 稍微差一点（可能是 github.io 这个域名在国外的原因）\n结语 至此，整个博客已经完美运转了，可以开始专心写文章了 😊。\n","permalink":"https://lexcao.io/zh/posts/hello-world/","summary":"博客配置：\n静态网页生成器 Jekyll 3.8.5 Ruby 2.6.0 主题 lagrange 网页分析 Google Aynalysis Baidu Aynalysis 部署 GitHub Pages 这是我的第一篇文章，作为最简单的 “你好 世界”，我想记录一下该博客的诞生过程，以及如果你也想搭建一个自己的博客应该怎么做。\n本文章将会涉及三个部分：\n选择博客类型 准备好所需内容 将他们编排起来 第一步 选择博客类型 根据前端网页是否与后台服务器或者数据库交互分为：静态网站 / 动态网站\n静态网站：\n仅依靠 HTML / CSS / JS 没有后台服务器存储数据 数据是预先生成的 动态网站：\n依赖前端 HTML / CSS / JS 数据从后台服务器获取 能够动态响应用户请求 所以，静态博客：\n文章预先生成 不依赖后台服务器 动态博客：\n文章从后台服务器获取 前端页面动态获取 考虑到刚接触到博客搭建，先从简单的静态博客入手。目前 GitHub 上有很多开源的静态网站生成器，这里我选择使用 Jekyll。\n选择合适的静态博客生成器请看 [Jekyll / Hugo / Hexo 比较]({{ \u0026ldquo;/zh/posts/jekyll-hugo-hexo\u0026rdquo; | relative_url }})。\n第二步 准备好所需内容 准备内容涉及以下方面：","title":"你好 世界"},{"content":"","permalink":"https://lexcao.io/zh/projects/","summary":"","title":"项目"}]