<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用 KAPT 生成 Kotlin Data Class 转换器 | The Coding Notes</title>
<meta name=keywords content><meta name=description content='背景
Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词

持久化对象，即实体 PO(Persistent Object)
传输对象 DTO(Data Transfer Object)
业务对象 BO(Business Object)
展示对象 VO(View Object)
等等……
这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：

1. 接收请求体 CreateOrderRequest
2. 根据 OrderQuery 构造查询对象查询订单
3. 构造 OrderEntity 进行持久化操作
4. 构造 OrderBO 进行下游消费
5. 返回响应体 CreateOrderResponse
可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。
在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。
所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。

注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现
是什么
通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。
主要有两个注解：

@Konvertable 生成裁剪的实体以及对应的转换方法
@Konvert 单独针对某个类生成转换方法

废话不多说来看怎么使用。
怎么用
1. 引入依赖
// for build.gradle.kts
repositories {
    maven("https://jitpack.io")
}

dependencies {
    kapt("com.github.lexcao:konverter:master-SNAPSHOT")
    implementation("com.github.lexcao:konverter-annotation:master-SNAPSHOT")
}

// for build.gradle
repositories {
    maven { url &#39;https://jitpack.io&#39; }
}

dependencies {
    kapt &#39;com.github.lexcao:konverter:master-SNAPSHOT&#39;
    implementation &#39;com.github.lexcao:konverter-annotation:master-SNAPSHOT&#39;
}
2. 在需要转换的类上加上注解
@Konvertable(
    To(name = "LoginDTO", pick = ["username", "password"]),
    To(name = "UserListDTO", omit = ["password"])
)
@Konvert(to = UserVO::class)
data class UserEntity(
    val id: Long,
    @Konvert.Field("name")
    val username: String,
    val password: String,
    @Konvert.By(GenderEnumConverter::class)
    val gender: Int
)
3. 生成的代码如下：
// @Konvertable
/**
 *  Auto generated code by @Konvertable
 */
data class LoginDTO(
  val username: String,
  val password: String
)

/**
 *  Auto generated code by @Konvertable
 */
data class UserListDTO(
  val id: Long,
  val username: String,
  val gender: Int
)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String =
    this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password)

/**
 *  Auto generated code by @Konvert
 */
fun LoginDTO.toUserEntity(
  id: Long = 0L,
  username: String = this@toUserEntity.username,
  password: String = this@toUserEntity.password,
  gender: Int = 0
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toUserListDTO(
  id: Long = this@toUserListDTO.id,
  username: String = this@toUserListDTO.username,
  gender: Int = this@toUserListDTO.gender
): UserListDTO = UserListDTO(id=id,username=username,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserListDTO.toUserEntity(
  id: Long = this@toUserEntity.id,
  username: String = this@toUserEntity.username,
  password: String = "",
  gender: Int = this@toUserEntity.gender
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toRegisterDTO(
  username: String = this@toRegisterDTO.username,
  password: String = this@toRegisterDTO.password,
  gender: Int = this@toRegisterDTO.gender
): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun RegisterDTO.toUserEntity(
  id: Long = 0L,
  username: String = this@toUserEntity.username,
  password: String = this@toUserEntity.password,
  gender: Int = this@toUserEntity.gender
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)
// @Konvert
// 转换为如下对象
data class UserVO(
    val id: String,
    val name: String,
    val gender: GenderEnum
)

enum class GenderEnum {
    MALE, FEMALE;
}

object GenderEnumConverter : Konvert.KonvertBy<Int, GenderEnum> {
    override fun Int.forward(): GenderEnum {
        return GenderEnum.values()[this]
    }

    override fun GenderEnum.backward(): Int {
        return this.ordinal
    }
}

// 生成的代码
**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toUserVO(
  id: String = this@toUserVO.id.toString(),
  name: String = this@toUserVO.username,
  gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() }
): UserVO = UserVO(id=id,name=name,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserVO.toUserEntity(
  id: Long = this@toUserEntity.id.toLong(),
  username: String = this@toUserEntity.name,
  password: String = "",
  gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() }
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)
相关 API 说明
转换规则'><meta name=author content="Lex Cao"><link rel=canonical href=https://lexcao.io/zh/posts/konverter/><link crossorigin=anonymous href=/assets/css/stylesheet.0633f72569546c04f177152a4fc857757796b843f92bb1208cf7114db62b1d94.css integrity="sha256-BjP3JWlUbATxdxUqT8hXdXeWuEP5K7EgjPcRTbYrHZQ=" rel="preload stylesheet" as=style><link rel=icon href=https://lexcao.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lexcao.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lexcao.io/favicon-32x32.png><link rel=apple-touch-icon href=https://lexcao.io/apple-touch-icon.png><link rel=mask-icon href=https://lexcao.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://lexcao.io/posts/konverter/><link rel=alternate hreflang=zh href=https://lexcao.io/zh/posts/konverter/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-DDVMDVDZMH"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DDVMDVDZMH")}</script><meta property="og:title" content="使用 KAPT 生成 Kotlin Data Class 转换器"><meta property="og:description" content='背景
Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词

持久化对象，即实体 PO(Persistent Object)
传输对象 DTO(Data Transfer Object)
业务对象 BO(Business Object)
展示对象 VO(View Object)
等等……
这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：

1. 接收请求体 CreateOrderRequest
2. 根据 OrderQuery 构造查询对象查询订单
3. 构造 OrderEntity 进行持久化操作
4. 构造 OrderBO 进行下游消费
5. 返回响应体 CreateOrderResponse
可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。
在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。
所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。

注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现
是什么
通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。
主要有两个注解：

@Konvertable 生成裁剪的实体以及对应的转换方法
@Konvert 单独针对某个类生成转换方法

废话不多说来看怎么使用。
怎么用
1. 引入依赖
// for build.gradle.kts
repositories {
    maven("https://jitpack.io")
}

dependencies {
    kapt("com.github.lexcao:konverter:master-SNAPSHOT")
    implementation("com.github.lexcao:konverter-annotation:master-SNAPSHOT")
}

// for build.gradle
repositories {
    maven { url &#39;https://jitpack.io&#39; }
}

dependencies {
    kapt &#39;com.github.lexcao:konverter:master-SNAPSHOT&#39;
    implementation &#39;com.github.lexcao:konverter-annotation:master-SNAPSHOT&#39;
}
2. 在需要转换的类上加上注解
@Konvertable(
    To(name = "LoginDTO", pick = ["username", "password"]),
    To(name = "UserListDTO", omit = ["password"])
)
@Konvert(to = UserVO::class)
data class UserEntity(
    val id: Long,
    @Konvert.Field("name")
    val username: String,
    val password: String,
    @Konvert.By(GenderEnumConverter::class)
    val gender: Int
)
3. 生成的代码如下：
// @Konvertable
/**
 *  Auto generated code by @Konvertable
 */
data class LoginDTO(
  val username: String,
  val password: String
)

/**
 *  Auto generated code by @Konvertable
 */
data class UserListDTO(
  val id: Long,
  val username: String,
  val gender: Int
)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String =
    this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password)

/**
 *  Auto generated code by @Konvert
 */
fun LoginDTO.toUserEntity(
  id: Long = 0L,
  username: String = this@toUserEntity.username,
  password: String = this@toUserEntity.password,
  gender: Int = 0
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toUserListDTO(
  id: Long = this@toUserListDTO.id,
  username: String = this@toUserListDTO.username,
  gender: Int = this@toUserListDTO.gender
): UserListDTO = UserListDTO(id=id,username=username,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserListDTO.toUserEntity(
  id: Long = this@toUserEntity.id,
  username: String = this@toUserEntity.username,
  password: String = "",
  gender: Int = this@toUserEntity.gender
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toRegisterDTO(
  username: String = this@toRegisterDTO.username,
  password: String = this@toRegisterDTO.password,
  gender: Int = this@toRegisterDTO.gender
): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun RegisterDTO.toUserEntity(
  id: Long = 0L,
  username: String = this@toUserEntity.username,
  password: String = this@toUserEntity.password,
  gender: Int = this@toUserEntity.gender
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)
// @Konvert
// 转换为如下对象
data class UserVO(
    val id: String,
    val name: String,
    val gender: GenderEnum
)

enum class GenderEnum {
    MALE, FEMALE;
}

object GenderEnumConverter : Konvert.KonvertBy<Int, GenderEnum> {
    override fun Int.forward(): GenderEnum {
        return GenderEnum.values()[this]
    }

    override fun GenderEnum.backward(): Int {
        return this.ordinal
    }
}

// 生成的代码
**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toUserVO(
  id: String = this@toUserVO.id.toString(),
  name: String = this@toUserVO.username,
  gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() }
): UserVO = UserVO(id=id,name=name,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserVO.toUserEntity(
  id: Long = this@toUserEntity.id.toLong(),
  username: String = this@toUserEntity.name,
  password: String = "",
  gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() }
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)
相关 API 说明
转换规则'><meta property="og:type" content="article"><meta property="og:url" content="https://lexcao.io/zh/posts/konverter/"><meta property="og:image" content="https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&amp;fit=crop&amp;w=720&amp;q=80"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-13T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-13T00:00:00+00:00"><meta property="og:site_name" content="The Coding Notes"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&amp;fit=crop&amp;w=720&amp;q=80"><meta name=twitter:title content="使用 KAPT 生成 Kotlin Data Class 转换器"><meta name=twitter:description content='背景
Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词

持久化对象，即实体 PO(Persistent Object)
传输对象 DTO(Data Transfer Object)
业务对象 BO(Business Object)
展示对象 VO(View Object)
等等……
这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：

1. 接收请求体 CreateOrderRequest
2. 根据 OrderQuery 构造查询对象查询订单
3. 构造 OrderEntity 进行持久化操作
4. 构造 OrderBO 进行下游消费
5. 返回响应体 CreateOrderResponse
可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。
在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。
所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。

注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现
是什么
通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。
主要有两个注解：

@Konvertable 生成裁剪的实体以及对应的转换方法
@Konvert 单独针对某个类生成转换方法

废话不多说来看怎么使用。
怎么用
1. 引入依赖
// for build.gradle.kts
repositories {
    maven("https://jitpack.io")
}

dependencies {
    kapt("com.github.lexcao:konverter:master-SNAPSHOT")
    implementation("com.github.lexcao:konverter-annotation:master-SNAPSHOT")
}

// for build.gradle
repositories {
    maven { url &#39;https://jitpack.io&#39; }
}

dependencies {
    kapt &#39;com.github.lexcao:konverter:master-SNAPSHOT&#39;
    implementation &#39;com.github.lexcao:konverter-annotation:master-SNAPSHOT&#39;
}
2. 在需要转换的类上加上注解
@Konvertable(
    To(name = "LoginDTO", pick = ["username", "password"]),
    To(name = "UserListDTO", omit = ["password"])
)
@Konvert(to = UserVO::class)
data class UserEntity(
    val id: Long,
    @Konvert.Field("name")
    val username: String,
    val password: String,
    @Konvert.By(GenderEnumConverter::class)
    val gender: Int
)
3. 生成的代码如下：
// @Konvertable
/**
 *  Auto generated code by @Konvertable
 */
data class LoginDTO(
  val username: String,
  val password: String
)

/**
 *  Auto generated code by @Konvertable
 */
data class UserListDTO(
  val id: Long,
  val username: String,
  val gender: Int
)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String =
    this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password)

/**
 *  Auto generated code by @Konvert
 */
fun LoginDTO.toUserEntity(
  id: Long = 0L,
  username: String = this@toUserEntity.username,
  password: String = this@toUserEntity.password,
  gender: Int = 0
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toUserListDTO(
  id: Long = this@toUserListDTO.id,
  username: String = this@toUserListDTO.username,
  gender: Int = this@toUserListDTO.gender
): UserListDTO = UserListDTO(id=id,username=username,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserListDTO.toUserEntity(
  id: Long = this@toUserEntity.id,
  username: String = this@toUserEntity.username,
  password: String = "",
  gender: Int = this@toUserEntity.gender
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toRegisterDTO(
  username: String = this@toRegisterDTO.username,
  password: String = this@toRegisterDTO.password,
  gender: Int = this@toRegisterDTO.gender
): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun RegisterDTO.toUserEntity(
  id: Long = 0L,
  username: String = this@toUserEntity.username,
  password: String = this@toUserEntity.password,
  gender: Int = this@toUserEntity.gender
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)
// @Konvert
// 转换为如下对象
data class UserVO(
    val id: String,
    val name: String,
    val gender: GenderEnum
)

enum class GenderEnum {
    MALE, FEMALE;
}

object GenderEnumConverter : Konvert.KonvertBy<Int, GenderEnum> {
    override fun Int.forward(): GenderEnum {
        return GenderEnum.values()[this]
    }

    override fun GenderEnum.backward(): Int {
        return this.ordinal
    }
}

// 生成的代码
**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toUserVO(
  id: String = this@toUserVO.id.toString(),
  name: String = this@toUserVO.username,
  gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() }
): UserVO = UserVO(id=id,name=name,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserVO.toUserEntity(
  id: Long = this@toUserEntity.id.toLong(),
  username: String = this@toUserEntity.name,
  password: String = "",
  gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() }
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)
相关 API 说明
转换规则'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"博文","item":"https://lexcao.io/zh/posts/"},{"@type":"ListItem","position":2,"name":"使用 KAPT 生成 Kotlin Data Class 转换器","item":"https://lexcao.io/zh/posts/konverter/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用 KAPT 生成 Kotlin Data Class 转换器","name":"使用 KAPT 生成 Kotlin Data Class 转换器","description":"背景 Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词\n持久化对象，即实体 PO(Persistent Object) 传输对象 DTO(Data Transfer Object) 业务对象 BO(Business Object) 展示对象 VO(View Object) 等等…… 这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程： 1. 接收请求体 CreateOrderRequest 2. 根据 OrderQuery 构造查询对象查询订单 3. 构造 OrderEntity 进行持久化操作 4. 构造 OrderBO 进行下游消费 5. 返回响应体 CreateOrderResponse 可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。\n在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。 所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。\n注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现\n是什么 通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。 主要有两个注解：\n@Konvertable 生成裁剪的实体以及对应的转换方法 @Konvert 单独针对某个类生成转换方法 废话不多说来看怎么使用。\n怎么用 1. 引入依赖 // for build.gradle.kts repositories { maven(\u0026#34;https://jitpack.io\u0026#34;) } dependencies { kapt(\u0026#34;com.github.lexcao:konverter:master-SNAPSHOT\u0026#34;) implementation(\u0026#34;com.github.lexcao:konverter-annotation:master-SNAPSHOT\u0026#34;) } // for build.gradle repositories { maven { url \u0026#39;https://jitpack.io\u0026#39; } } dependencies { kapt \u0026#39;com.github.lexcao:konverter:master-SNAPSHOT\u0026#39; implementation \u0026#39;com.github.lexcao:konverter-annotation:master-SNAPSHOT\u0026#39; } 2. 在需要转换的类上加上注解 @Konvertable( To(name = \u0026#34;LoginDTO\u0026#34;, pick = [\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;]), To(name = \u0026#34;UserListDTO\u0026#34;, omit = [\u0026#34;password\u0026#34;]) ) @Konvert(to = UserVO::class) data class UserEntity( val id: Long, @Konvert.Field(\u0026#34;name\u0026#34;) val username: String, val password: String, @Konvert.By(GenderEnumConverter::class) val gender: Int ) 3. 生成的代码如下： // @Konvertable /** * Auto generated code by @Konvertable */ data class LoginDTO( val username: String, val password: String ) /** * Auto generated code by @Konvertable */ data class UserListDTO( val id: Long, val username: String, val gender: Int ) /** * Auto generated code by @Konvert */ fun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String = this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password) /** * Auto generated code by @Konvert */ fun LoginDTO.toUserEntity( id: Long = 0L, username: String = this@toUserEntity.username, password: String = this@toUserEntity.password, gender: Int = 0 ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun UserEntity.toUserListDTO( id: Long = this@toUserListDTO.id, username: String = this@toUserListDTO.username, gender: Int = this@toUserListDTO.gender ): UserListDTO = UserListDTO(id=id,username=username,gender=gender) /** * Auto generated code by @Konvert */ fun UserListDTO.toUserEntity( id: Long = this@toUserEntity.id, username: String = this@toUserEntity.username, password: String = \u0026#34;\u0026#34;, gender: Int = this@toUserEntity.gender ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun UserEntity.toRegisterDTO( username: String = this@toRegisterDTO.username, password: String = this@toRegisterDTO.password, gender: Int = this@toRegisterDTO.gender ): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun RegisterDTO.toUserEntity( id: Long = 0L, username: String = this@toUserEntity.username, password: String = this@toUserEntity.password, gender: Int = this@toUserEntity.gender ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) // @Konvert // 转换为如下对象 data class UserVO( val id: String, val name: String, val gender: GenderEnum ) enum class GenderEnum { MALE, FEMALE; } object GenderEnumConverter : Konvert.KonvertBy\u0026lt;Int, GenderEnum\u0026gt; { override fun Int.forward(): GenderEnum { return GenderEnum.values()[this] } override fun GenderEnum.backward(): Int { return this.ordinal } } // 生成的代码 ** * Auto generated code by @Konvert */ fun UserEntity.toUserVO( id: String = this@toUserVO.id.toString(), name: String = this@toUserVO.username, gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() } ): UserVO = UserVO(id=id,name=name,gender=gender) /** * Auto generated code by @Konvert */ fun UserVO.toUserEntity( id: Long = this@toUserEntity.id.toLong(), username: String = this@toUserEntity.name, password: String = \u0026#34;\u0026#34;, gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() } ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) 相关 API 说明 转换规则\n","keywords":[],"articleBody":"背景 Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词\n持久化对象，即实体 PO(Persistent Object) 传输对象 DTO(Data Transfer Object) 业务对象 BO(Business Object) 展示对象 VO(View Object) 等等…… 这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程： 1. 接收请求体 CreateOrderRequest 2. 根据 OrderQuery 构造查询对象查询订单 3. 构造 OrderEntity 进行持久化操作 4. 构造 OrderBO 进行下游消费 5. 返回响应体 CreateOrderResponse 可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。\n在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。 所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。\n注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现\n是什么 通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。 主要有两个注解：\n@Konvertable 生成裁剪的实体以及对应的转换方法 @Konvert 单独针对某个类生成转换方法 废话不多说来看怎么使用。\n怎么用 1. 引入依赖 // for build.gradle.kts repositories { maven(\"https://jitpack.io\") } dependencies { kapt(\"com.github.lexcao:konverter:master-SNAPSHOT\") implementation(\"com.github.lexcao:konverter-annotation:master-SNAPSHOT\") } // for build.gradle repositories { maven { url 'https://jitpack.io' } } dependencies { kapt 'com.github.lexcao:konverter:master-SNAPSHOT' implementation 'com.github.lexcao:konverter-annotation:master-SNAPSHOT' } 2. 在需要转换的类上加上注解 @Konvertable( To(name = \"LoginDTO\", pick = [\"username\", \"password\"]), To(name = \"UserListDTO\", omit = [\"password\"]) ) @Konvert(to = UserVO::class) data class UserEntity( val id: Long, @Konvert.Field(\"name\") val username: String, val password: String, @Konvert.By(GenderEnumConverter::class) val gender: Int ) 3. 生成的代码如下： // @Konvertable /** * Auto generated code by @Konvertable */ data class LoginDTO( val username: String, val password: String ) /** * Auto generated code by @Konvertable */ data class UserListDTO( val id: Long, val username: String, val gender: Int ) /** * Auto generated code by @Konvert */ fun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String = this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password) /** * Auto generated code by @Konvert */ fun LoginDTO.toUserEntity( id: Long = 0L, username: String = this@toUserEntity.username, password: String = this@toUserEntity.password, gender: Int = 0 ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun UserEntity.toUserListDTO( id: Long = this@toUserListDTO.id, username: String = this@toUserListDTO.username, gender: Int = this@toUserListDTO.gender ): UserListDTO = UserListDTO(id=id,username=username,gender=gender) /** * Auto generated code by @Konvert */ fun UserListDTO.toUserEntity( id: Long = this@toUserEntity.id, username: String = this@toUserEntity.username, password: String = \"\", gender: Int = this@toUserEntity.gender ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun UserEntity.toRegisterDTO( username: String = this@toRegisterDTO.username, password: String = this@toRegisterDTO.password, gender: Int = this@toRegisterDTO.gender ): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun RegisterDTO.toUserEntity( id: Long = 0L, username: String = this@toUserEntity.username, password: String = this@toUserEntity.password, gender: Int = this@toUserEntity.gender ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) // @Konvert // 转换为如下对象 data class UserVO( val id: String, val name: String, val gender: GenderEnum ) enum class GenderEnum { MALE, FEMALE; } object GenderEnumConverter : Konvert.KonvertBy { override fun Int.forward(): GenderEnum { return GenderEnum.values()[this] } override fun GenderEnum.backward(): Int { return this.ordinal } } // 生成的代码 ** * Auto generated code by @Konvert */ fun UserEntity.toUserVO( id: String = this@toUserVO.id.toString(), name: String = this@toUserVO.username, gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() } ): UserVO = UserVO(id=id,name=name,gender=gender) /** * Auto generated code by @Konvert */ fun UserVO.toUserEntity( id: Long = this@toUserEntity.id.toLong(), username: String = this@toUserEntity.name, password: String = \"\", gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() } ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) 相关 API 说明 转换规则\n如果转换至 String 类型，原类型不匹配时会调用 toString() 如果转换至基础数据类型，转换字段缺失时会使用默认类型 如果转换至允许为 null 类型，原类型不匹配时会使用默认值 null 如果转换至引用类型（String 除外）或者找不到映射需要在转换方法显式赋值 下一步 代码重构，新增测试用例 支持引用类型默认值 支持嵌套对象 支持 Java 已知 BUG 修复 支持映射失败字段获取原类型的构造函数参数默认值，或者成员变量默认值（目前 Kotlin KAPT 已支持获取成员变量默认值，暂不支持获取函数参数默认值） 已知 BUG 相同 name 在 @Konvertable 冲突 @Konvertable 参数合法性校验以及友好报错 KonvertBy 目前使用 Class 报错或者使用 Companion 报错 最后 Konverter 源码在 GitHub\n相关的样例代码 GitHub\n","wordCount":"504","inLanguage":"zh","image":"https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format\u0026fit=crop\u0026w=720\u0026q=80","datePublished":"2020-04-13T00:00:00Z","dateModified":"2020-04-13T00:00:00Z","author":{"@type":"Person","name":"Lex Cao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lexcao.io/zh/posts/konverter/"},"publisher":{"@type":"Organization","name":"The Coding Notes","logo":{"@type":"ImageObject","url":"https://lexcao.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lexcao.io/zh/ accesskey=h title="代码笔记 (Alt + H)">代码笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://lexcao.io/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://lexcao.io/zh/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://lexcao.io/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://lexcao.io/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://lexcao.io/zh/projects/ title=项目><span>项目</span></a></li><li><a href=https://lexcao.io/zh/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lexcao.io/zh/>主页</a>&nbsp;»&nbsp;<a href=https://lexcao.io/zh/posts/>博文</a></div><h1 class="post-title entry-hint-parent">使用 KAPT 生成 Kotlin Data Class 转换器</h1><div class=post-meta><span title='2020-04-13 00:00:00 +0000 UTC'>四月 13, 2020</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;Lex Cao&nbsp;|&nbsp;翻译:<ul class=i18n_list><li><a href=https://lexcao.io/posts/konverter/>English</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a></li><li><a href=#%e6%98%af%e4%bb%80%e4%b9%88 aria-label=是什么>是什么</a></li><li><a href=#%e6%80%8e%e4%b9%88%e7%94%a8 aria-label=怎么用>怎么用</a><ul><li><a href=#1-%e5%bc%95%e5%85%a5%e4%be%9d%e8%b5%96 aria-label="1. 引入依赖">1. 引入依赖</a></li><li><a href=#2-%e5%9c%a8%e9%9c%80%e8%a6%81%e8%bd%ac%e6%8d%a2%e7%9a%84%e7%b1%bb%e4%b8%8a%e5%8a%a0%e4%b8%8a%e6%b3%a8%e8%a7%a3 aria-label="2. 在需要转换的类上加上注解">2. 在需要转换的类上加上注解</a></li><li><a href=#3-%e7%94%9f%e6%88%90%e7%9a%84%e4%bb%a3%e7%a0%81%e5%a6%82%e4%b8%8b aria-label="3. 生成的代码如下：">3. 生成的代码如下：</a></li><li><a href=#%e7%9b%b8%e5%85%b3-api-%e8%af%b4%e6%98%8e aria-label="相关 API 说明">相关 API 说明</a></li></ul></li><li><a href=#%e4%b8%8b%e4%b8%80%e6%ad%a5 aria-label=下一步>下一步</a></li><li><a href=#%e5%b7%b2%e7%9f%a5-bug aria-label="已知 BUG">已知 BUG</a></li><li><a href=#%e6%9c%80%e5%90%8e aria-label=最后>最后</a></li></ul></div></details></div><div class=post-content><h1 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h1><p>Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词</p><ul><li>持久化对象，即实体 PO(<em>Persistent Object</em>)</li><li>传输对象 DTO(<em>Data Transfer Object</em>)</li><li>业务对象 BO(<em>Business Object</em>)</li><li>展示对象 VO(<em>View Object</em>)</li><li>等等……
这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：</li></ul><pre tabindex=0><code>1. 接收请求体 CreateOrderRequest
2. 根据 OrderQuery 构造查询对象查询订单
3. 构造 OrderEntity 进行持久化操作
4. 构造 OrderBO 进行下游消费
5. 返回响应体 CreateOrderResponse
</code></pre><p>可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。</p><p>在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。
所以 <code>Konverter</code> 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。</p><blockquote><p>注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现</p></blockquote><h1 id=是什么>是什么<a hidden class=anchor aria-hidden=true href=#是什么>#</a></h1><p>通过 <a href=https://kotlinlang.org/docs/reference/kapt.html]><em>KAPT(Kotlin Annotation Processing Tool</em></a> 注解处理以及 <a href=https://github.com/square/kotlinpoet><em>Kotlin Poet</em></a> 代码生成，实现自动生成对实体的相关裁剪的对象。
主要有两个注解：</p><ul><li><code>@Konvertable</code> 生成裁剪的实体以及对应的转换方法</li><li><code>@Konvert</code> 单独针对某个类生成转换方法</li></ul><p>废话不多说来看怎么使用。</p><h1 id=怎么用>怎么用<a hidden class=anchor aria-hidden=true href=#怎么用>#</a></h1><h2 id=1-引入依赖>1. 引入依赖<a hidden class=anchor aria-hidden=true href=#1-引入依赖>#</a></h2><pre tabindex=0><code>// for build.gradle.kts
repositories {
    maven(&#34;https://jitpack.io&#34;)
}

dependencies {
    kapt(&#34;com.github.lexcao:konverter:master-SNAPSHOT&#34;)
    implementation(&#34;com.github.lexcao:konverter-annotation:master-SNAPSHOT&#34;)
}

// for build.gradle
repositories {
    maven { url &#39;https://jitpack.io&#39; }
}

dependencies {
    kapt &#39;com.github.lexcao:konverter:master-SNAPSHOT&#39;
    implementation &#39;com.github.lexcao:konverter-annotation:master-SNAPSHOT&#39;
}
</code></pre><h2 id=2-在需要转换的类上加上注解>2. 在需要转换的类上加上注解<a hidden class=anchor aria-hidden=true href=#2-在需要转换的类上加上注解>#</a></h2><pre tabindex=0><code>@Konvertable(
    To(name = &#34;LoginDTO&#34;, pick = [&#34;username&#34;, &#34;password&#34;]),
    To(name = &#34;UserListDTO&#34;, omit = [&#34;password&#34;])
)
@Konvert(to = UserVO::class)
data class UserEntity(
    val id: Long,
    @Konvert.Field(&#34;name&#34;)
    val username: String,
    val password: String,
    @Konvert.By(GenderEnumConverter::class)
    val gender: Int
)
</code></pre><h2 id=3-生成的代码如下>3. 生成的代码如下：<a hidden class=anchor aria-hidden=true href=#3-生成的代码如下>#</a></h2><pre tabindex=0><code>// @Konvertable
/**
 *  Auto generated code by @Konvertable
 */
data class LoginDTO(
  val username: String,
  val password: String
)

/**
 *  Auto generated code by @Konvertable
 */
data class UserListDTO(
  val id: Long,
  val username: String,
  val gender: Int
)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String =
    this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password)

/**
 *  Auto generated code by @Konvert
 */
fun LoginDTO.toUserEntity(
  id: Long = 0L,
  username: String = this@toUserEntity.username,
  password: String = this@toUserEntity.password,
  gender: Int = 0
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toUserListDTO(
  id: Long = this@toUserListDTO.id,
  username: String = this@toUserListDTO.username,
  gender: Int = this@toUserListDTO.gender
): UserListDTO = UserListDTO(id=id,username=username,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserListDTO.toUserEntity(
  id: Long = this@toUserEntity.id,
  username: String = this@toUserEntity.username,
  password: String = &#34;&#34;,
  gender: Int = this@toUserEntity.gender
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toRegisterDTO(
  username: String = this@toRegisterDTO.username,
  password: String = this@toRegisterDTO.password,
  gender: Int = this@toRegisterDTO.gender
): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun RegisterDTO.toUserEntity(
  id: Long = 0L,
  username: String = this@toUserEntity.username,
  password: String = this@toUserEntity.password,
  gender: Int = this@toUserEntity.gender
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)
</code></pre><pre tabindex=0><code>// @Konvert
// 转换为如下对象
data class UserVO(
    val id: String,
    val name: String,
    val gender: GenderEnum
)

enum class GenderEnum {
    MALE, FEMALE;
}

object GenderEnumConverter : Konvert.KonvertBy&lt;Int, GenderEnum&gt; {
    override fun Int.forward(): GenderEnum {
        return GenderEnum.values()[this]
    }

    override fun GenderEnum.backward(): Int {
        return this.ordinal
    }
}

// 生成的代码
**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toUserVO(
  id: String = this@toUserVO.id.toString(),
  name: String = this@toUserVO.username,
  gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() }
): UserVO = UserVO(id=id,name=name,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserVO.toUserEntity(
  id: Long = this@toUserEntity.id.toLong(),
  username: String = this@toUserEntity.name,
  password: String = &#34;&#34;,
  gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() }
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)
</code></pre><h2 id=相关-api-说明>相关 API 说明<a hidden class=anchor aria-hidden=true href=#相关-api-说明>#</a></h2><p>转换规则</p><ul><li>如果转换至 String 类型，原类型不匹配时会调用 <code>toString()</code></li><li>如果转换至基础数据类型，转换字段缺失时会使用默认类型</li><li>如果转换至允许为 null 类型，原类型不匹配时会使用默认值 null</li><li>如果转换至引用类型（String 除外）或者找不到映射需要在转换方法显式赋值</li></ul><h1 id=下一步>下一步<a hidden class=anchor aria-hidden=true href=#下一步>#</a></h1><ul><li>代码重构，新增测试用例</li><li>支持引用类型默认值</li><li>支持嵌套对象</li><li>支持 Java</li><li>已知 BUG 修复</li><li>支持映射失败字段获取原类型的构造函数参数默认值，或者成员变量默认值（目前 Kotlin KAPT 已支持获取<a href=https://youtrack.jetbrains.com/issue/KT-30164>成员变量默认值</a>，暂不支持获取<a href=https://youtrack.jetbrains.com/issue/KT-29355>函数参数默认值</a>）</li></ul><h1 id=已知-bug>已知 BUG<a hidden class=anchor aria-hidden=true href=#已知-bug>#</a></h1><ul><li>相同 name 在 @Konvertable 冲突</li><li>@Konvertable 参数合法性校验以及友好报错</li><li>KonvertBy 目前使用 Class 报错或者使用 Companion 报错</li></ul><h1 id=最后>最后<a hidden class=anchor aria-hidden=true href=#最后>#</a></h1><p>Konverter 源码在 <a href=https://github.com/lexcao/konverter>GitHub</a></p><p>相关的样例代码 <a href=https://github.com/lexcao/konverter-demo>GitHub</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://lexcao.io/zh/posts/kotlin-equality-diving/><span class=title>« 上一页</span><br><span>Kotlin 奇怪的相等现象探究</span>
</a><a class=next href=https://lexcao.io/zh/posts/async-within-async/><span class=title>下一页 »</span><br><span>一次线程死锁排查记录</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://lexcao.io/zh/>The Coding Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>