<!doctype html><html lang=zh dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>使用 KAPT 生成 Kotlin Data Class 转换器 | The Coding Notes</title>
<meta name=keywords content>
<meta name=description content="背景 Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词
 持久化对象，即实体 PO(Persistent Object) 传输对象 DTO(Data Transfer Object) 业务对象 BO(Business Object) 展示对象 VO(View Object) 等等…… 这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：  1. 接收请求体 CreateOrderRequest 2. 根据 OrderQuery 构造查询对象查询订单 3. 构造 OrderEntity 进行持久化操作 4. 构造 OrderBO 进行下游消费 5. 返回响应体 CreateOrderResponse 可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。
在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。 所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。
 注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现
 是什么 通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。 主要有两个注解：
 @Konvertable 生成裁剪的实体以及对应的转换方法 @Konvert 单独针对某个类生成转换方法  废话不多说来看怎么使用。">
<meta name=author content="Lex Cao">
<link rel=canonical href=https://lexcao.io/zh/posts/konverter/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.954da09bd8e837a4043689612475b7cc6722c94243f0373fc0f972f02186a597.css integrity="sha256-lU2gm9joN6QENolhJHW3zGciyUJD8Dc/wPly8CGGpZc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lexcao.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://lexcao.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://lexcao.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://lexcao.io/apple-touch-icon.png>
<link rel=mask-icon href=https://lexcao.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.87.0">
<link rel=alternate hreflang=en href=https://lexcao.io/posts/konverter/>
<link rel=alternate hreflang=zh href=https://lexcao.io/zh/posts/konverter/>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DDVMDVDZMH"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-DDVMDVDZMH',{anonymize_ip:!1})}</script>
<meta property="og:title" content="使用 KAPT 生成 Kotlin Data Class 转换器">
<meta property="og:description" content="背景 Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词
 持久化对象，即实体 PO(Persistent Object) 传输对象 DTO(Data Transfer Object) 业务对象 BO(Business Object) 展示对象 VO(View Object) 等等…… 这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：  1. 接收请求体 CreateOrderRequest 2. 根据 OrderQuery 构造查询对象查询订单 3. 构造 OrderEntity 进行持久化操作 4. 构造 OrderBO 进行下游消费 5. 返回响应体 CreateOrderResponse 可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。
在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。 所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。
 注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现
 是什么 通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。 主要有两个注解：
 @Konvertable 生成裁剪的实体以及对应的转换方法 @Konvert 单独针对某个类生成转换方法  废话不多说来看怎么使用。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://lexcao.io/zh/posts/konverter/"><meta property="og:image" content="https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&fit=crop&w=720&q=80"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-04-13T00:00:00+00:00">
<meta property="article:modified_time" content="2020-04-13T00:00:00+00:00"><meta property="og:site_name" content="The Coding Notes">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&fit=crop&w=720&q=80">
<meta name=twitter:title content="使用 KAPT 生成 Kotlin Data Class 转换器">
<meta name=twitter:description content="背景 Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词
 持久化对象，即实体 PO(Persistent Object) 传输对象 DTO(Data Transfer Object) 业务对象 BO(Business Object) 展示对象 VO(View Object) 等等…… 这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：  1. 接收请求体 CreateOrderRequest 2. 根据 OrderQuery 构造查询对象查询订单 3. 构造 OrderEntity 进行持久化操作 4. 构造 OrderBO 进行下游消费 5. 返回响应体 CreateOrderResponse 可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。
在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。 所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。
 注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现
 是什么 通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。 主要有两个注解：
 @Konvertable 生成裁剪的实体以及对应的转换方法 @Konvert 单独针对某个类生成转换方法  废话不多说来看怎么使用。">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"使用 KAPT 生成 Kotlin Data Class 转换器","item":"https://lexcao.io/zh/posts/konverter/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用 KAPT 生成 Kotlin Data Class 转换器","name":"使用 KAPT 生成 Kotlin Data Class 转换器","description":"背景 Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词\n 持久化对象，即实体 PO(Persistent Object) 传输对象 DTO(Data Transfer Object) 业务对象 BO(Business Object) 展示对象 VO(View Object) 等等…… 这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：  1. 接收请求体 CreateOrderRequest 2. 根据 OrderQuery 构造查询对象查询订单 3. 构造 OrderEntity 进行持久化操作 4. 构造 OrderBO 进行下游消费 5. 返回响应体 CreateOrderResponse 可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。\n在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。 所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。\n 注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现\n 是什么 通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。 主要有两个注解：\n @Konvertable 生成裁剪的实体以及对应的转换方法 @Konvert 单独针对某个类生成转换方法  废话不多说来看怎么使用。","keywords":[],"articleBody":"背景 Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词\n 持久化对象，即实体 PO(Persistent Object) 传输对象 DTO(Data Transfer Object) 业务对象 BO(Business Object) 展示对象 VO(View Object) 等等…… 这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：  1. 接收请求体 CreateOrderRequest 2. 根据 OrderQuery 构造查询对象查询订单 3. 构造 OrderEntity 进行持久化操作 4. 构造 OrderBO 进行下游消费 5. 返回响应体 CreateOrderResponse 可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。\n在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。 所以 Konverter 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。\n 注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现\n 是什么 通过 KAPT(Kotlin Annotation Processing Tool 注解处理以及 Kotlin Poet 代码生成，实现自动生成对实体的相关裁剪的对象。 主要有两个注解：\n @Konvertable 生成裁剪的实体以及对应的转换方法 @Konvert 单独针对某个类生成转换方法  废话不多说来看怎么使用。\n怎么用 1. 引入依赖 // for build.gradle.kts repositories { maven(\"https://jitpack.io\") } dependencies { kapt(\"com.github.lexcao:konverter:master-SNAPSHOT\") implementation(\"com.github.lexcao:konverter-annotation:master-SNAPSHOT\") } // for build.gradle repositories { maven { url 'https://jitpack.io' } } dependencies { kapt 'com.github.lexcao:konverter:master-SNAPSHOT' implementation 'com.github.lexcao:konverter-annotation:master-SNAPSHOT' } 2. 在需要转换的类上加上注解 @Konvertable( To(name = \"LoginDTO\", pick = [\"username\", \"password\"]), To(name = \"UserListDTO\", omit = [\"password\"]) ) @Konvert(to = UserVO::class) data class UserEntity( val id: Long, @Konvert.Field(\"name\") val username: String, val password: String, @Konvert.By(GenderEnumConverter::class) val gender: Int ) 3. 生成的代码如下： // @Konvertable /** * Auto generated code by @Konvertable */ data class LoginDTO( val username: String, val password: String ) /** * Auto generated code by @Konvertable */ data class UserListDTO( val id: Long, val username: String, val gender: Int ) /** * Auto generated code by @Konvert */ fun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String = this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password) /** * Auto generated code by @Konvert */ fun LoginDTO.toUserEntity( id: Long = 0L, username: String = this@toUserEntity.username, password: String = this@toUserEntity.password, gender: Int = 0 ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun UserEntity.toUserListDTO( id: Long = this@toUserListDTO.id, username: String = this@toUserListDTO.username, gender: Int = this@toUserListDTO.gender ): UserListDTO = UserListDTO(id=id,username=username,gender=gender) /** * Auto generated code by @Konvert */ fun UserListDTO.toUserEntity( id: Long = this@toUserEntity.id, username: String = this@toUserEntity.username, password: String = \"\", gender: Int = this@toUserEntity.gender ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun UserEntity.toRegisterDTO( username: String = this@toRegisterDTO.username, password: String = this@toRegisterDTO.password, gender: Int = this@toRegisterDTO.gender ): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender) /** * Auto generated code by @Konvert */ fun RegisterDTO.toUserEntity( id: Long = 0L, username: String = this@toUserEntity.username, password: String = this@toUserEntity.password, gender: Int = this@toUserEntity.gender ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) // @Konvert // 转换为如下对象 data class UserVO( val id: String, val name: String, val gender: GenderEnum ) enum class GenderEnum { MALE, FEMALE; } object GenderEnumConverter : Konvert.KonvertBy{ override fun Int.forward(): GenderEnum { return GenderEnum.values()[this] } override fun GenderEnum.backward(): Int { return this.ordinal } } // 生成的代码 ** * Auto generated code by @Konvert */ fun UserEntity.toUserVO( id: String = this@toUserVO.id.toString(), name: String = this@toUserVO.username, gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() } ): UserVO = UserVO(id=id,name=name,gender=gender) /** * Auto generated code by @Konvert */ fun UserVO.toUserEntity( id: Long = this@toUserEntity.id.toLong(), username: String = this@toUserEntity.name, password: String = \"\", gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() } ): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender) 相关 API 说明 转换规则\n 如果转换至 String 类型，原类型不匹配时会调用 toString() 如果转换至基础数据类型，转换字段缺失时会使用默认类型 如果转换至允许为 null 类型，原类型不匹配时会使用默认值 null 如果转换至引用类型（String 除外）或者找不到映射需要在转换方法显式赋值  下一步  代码重构，新增测试用例 支持引用类型默认值 支持嵌套对象 支持 Java 已知 BUG 修复 支持映射失败字段获取原类型的构造函数参数默认值，或者成员变量默认值（目前 Kotlin KAPT 已支持获取成员变量默认值，暂不支持获取函数参数默认值）  已知 BUG  相同 name 在 @Konvertable 冲突 @Konvertable 参数合法性校验以及友好报错 KonvertBy 目前使用 Class 报错或者使用 Companion 报错  最后 Konverter 源码在 GitHub\n相关的样例代码 GitHub\n","wordCount":"504","inLanguage":"zh","datePublished":"2020-04-13T00:00:00Z","dateModified":"2020-04-13T00:00:00Z","author":{"@type":"Person","name":"Lex Cao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lexcao.io/zh/posts/konverter/"},"publisher":{"@type":"Organization","name":"The Coding Notes","logo":{"@type":"ImageObject","url":"https://lexcao.io/favicon.ico"}}}</script>
<noscript>
<iframe src="//www.googletagmanager.com/ns.html?id=GTM-KJ277ZJ" height=0 width=0 style=display:none;visibility:hidden></iframe>
</noscript>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://lexcao.io/zh/ accesskey=h title="代码笔记 (Alt + H)">代码笔记</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
<ul class=lang-switch><li>|</li>
<li>
<a href=https://lexcao.io/ title=English aria-label=English>English</a>
</li>
</ul>
</span>
</div>
<ul id=menu>
<li>
<a href=https://lexcao.io/zh/search/ title="搜索 (Alt + /)" accesskey=/>
<span>搜索</span>
</a>
</li>
<li>
<a href=https://lexcao.io/zh/archives/ title=归档>
<span>归档</span>
</a>
</li>
<li>
<a href=https://lexcao.io/zh/tags/ title=标签>
<span>标签</span>
</a>
</li>
<li>
<a href=https://lexcao.io/zh/projects/ title=项目>
<span>项目</span>
</a>
</li>
<li>
<a href=https://lexcao.io/zh/about/ title=关于>
<span>关于</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://lexcao.io/zh/>主页</a></div>
<h1 class=post-title>
使用 KAPT 生成 Kotlin Data Class 转换器
</h1>
<div class=post-meta>2020 April 13&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;Lex Cao&nbsp;|&nbsp;
<ul class=i18n_list>语言:
<li>
<a href=https://lexcao.io/posts/konverter/>English</a>
</li>
</ul>
</div>
</header> <div class=toc>
<details>
<summary accesskey=c title="(Alt + C)">
<div class=details>目录</div>
</summary>
<div class=inner><ul>
<li>
<a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a></li>
<li>
<a href=#%e6%98%af%e4%bb%80%e4%b9%88 aria-label=是什么>是什么</a></li>
<li>
<a href=#%e6%80%8e%e4%b9%88%e7%94%a8 aria-label=怎么用>怎么用</a><ul>
<li>
<a href=#1-%e5%bc%95%e5%85%a5%e4%be%9d%e8%b5%96 aria-label="1. 引入依赖">1. 引入依赖</a></li>
<li>
<a href=#2-%e5%9c%a8%e9%9c%80%e8%a6%81%e8%bd%ac%e6%8d%a2%e7%9a%84%e7%b1%bb%e4%b8%8a%e5%8a%a0%e4%b8%8a%e6%b3%a8%e8%a7%a3 aria-label="2. 在需要转换的类上加上注解">2. 在需要转换的类上加上注解</a></li>
<li>
<a href=#3-%e7%94%9f%e6%88%90%e7%9a%84%e4%bb%a3%e7%a0%81%e5%a6%82%e4%b8%8b aria-label="3. 生成的代码如下：">3. 生成的代码如下：</a></li>
<li>
<a href=#%e7%9b%b8%e5%85%b3-api-%e8%af%b4%e6%98%8e aria-label="相关 API 说明">相关 API 说明</a></li></ul>
</li>
<li>
<a href=#%e4%b8%8b%e4%b8%80%e6%ad%a5 aria-label=下一步>下一步</a></li>
<li>
<a href=#%e5%b7%b2%e7%9f%a5-bug aria-label="已知 BUG">已知 BUG</a></li>
<li>
<a href=#%e6%9c%80%e5%90%8e aria-label=最后>最后</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><h1 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h1>
<p>Web 后台开发中，对于一个实体的操作会衍生出多个类似的对象进行操作（避免直接使用实体），由此出现相关名词</p>
<ul>
<li>持久化对象，即实体 PO(<em>Persistent Object</em>)</li>
<li>传输对象 DTO(<em>Data Transfer Object</em>)</li>
<li>业务对象 BO(<em>Business Object</em>)</li>
<li>展示对象 VO(<em>View Object</em>)</li>
<li>等等……
这些对象大多数直接从实体里面裁剪几个字段，比如，在一次创建订单请求中以订单实体（OrderEntity）为例，经历如下流程：</li>
</ul>
<pre><code>1. 接收请求体 CreateOrderRequest
2. 根据 OrderQuery 构造查询对象查询订单
3. 构造 OrderEntity 进行持久化操作
4. 构造 OrderBO 进行下游消费
5. 返回响应体 CreateOrderResponse
</code></pre><p>可见，从 OrderEntity 衍生出 4 个对象，仅仅是对订单的实体的部分裁剪，但是要编写很多重复的代码（复制也行）。当然，如果是新增字段的话可以使用继承解决。</p>
<p>在 Kotlin Web 后台开发中，data class 的语法特性带来很多优势，但还是避免不了创建类似的重复对象。
所以 <code>Konverter</code> 诞生于此，解决实体对象裁剪问题。还有另一个功能那就是自动生成两个实体间的转换方法。</p>
<blockquote>
<p>注意：目前只支持 Kotlin，并且生成的转换方法是通过扩展函数实现</p>
</blockquote>
<h1 id=是什么>是什么<a hidden class=anchor aria-hidden=true href=#是什么>#</a></h1>
<p>通过 <a href=https://kotlinlang.org/docs/reference/kapt.html%5D><em>KAPT(Kotlin Annotation Processing Tool</em></a> 注解处理以及 <a href=https://github.com/square/kotlinpoet><em>Kotlin Poet</em></a> 代码生成，实现自动生成对实体的相关裁剪的对象。
主要有两个注解：</p>
<ul>
<li><code>@Konvertable</code> 生成裁剪的实体以及对应的转换方法</li>
<li><code>@Konvert</code> 单独针对某个类生成转换方法</li>
</ul>
<p>废话不多说来看怎么使用。</p>
<h1 id=怎么用>怎么用<a hidden class=anchor aria-hidden=true href=#怎么用>#</a></h1>
<h2 id=1-引入依赖>1. 引入依赖<a hidden class=anchor aria-hidden=true href=#1-引入依赖>#</a></h2>
<pre><code>// for build.gradle.kts
repositories {
    maven(&quot;https://jitpack.io&quot;)
}

dependencies {
    kapt(&quot;com.github.lexcao:konverter:master-SNAPSHOT&quot;)
    implementation(&quot;com.github.lexcao:konverter-annotation:master-SNAPSHOT&quot;)
}

// for build.gradle
repositories {
    maven { url 'https://jitpack.io' }
}

dependencies {
    kapt 'com.github.lexcao:konverter:master-SNAPSHOT'
    implementation 'com.github.lexcao:konverter-annotation:master-SNAPSHOT'
}
</code></pre><h2 id=2-在需要转换的类上加上注解>2. 在需要转换的类上加上注解<a hidden class=anchor aria-hidden=true href=#2-在需要转换的类上加上注解>#</a></h2>
<pre><code>@Konvertable(
    To(name = &quot;LoginDTO&quot;, pick = [&quot;username&quot;, &quot;password&quot;]),
    To(name = &quot;UserListDTO&quot;, omit = [&quot;password&quot;])
)
@Konvert(to = UserVO::class)
data class UserEntity(
    val id: Long,
    @Konvert.Field(&quot;name&quot;)
    val username: String,
    val password: String,
    @Konvert.By(GenderEnumConverter::class)
    val gender: Int
)
</code></pre><h2 id=3-生成的代码如下>3. 生成的代码如下：<a hidden class=anchor aria-hidden=true href=#3-生成的代码如下>#</a></h2>
<pre><code>// @Konvertable
/**
 *  Auto generated code by @Konvertable
 */
data class LoginDTO(
  val username: String,
  val password: String
)

/**
 *  Auto generated code by @Konvertable
 */
data class UserListDTO(
  val id: Long,
  val username: String,
  val gender: Int
)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toLoginDTO(username: String = this@toLoginDTO.username, password: String =
    this@toLoginDTO.password): LoginDTO = LoginDTO(username=username,password=password)

/**
 *  Auto generated code by @Konvert
 */
fun LoginDTO.toUserEntity(
  id: Long = 0L,
  username: String = this@toUserEntity.username,
  password: String = this@toUserEntity.password,
  gender: Int = 0
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toUserListDTO(
  id: Long = this@toUserListDTO.id,
  username: String = this@toUserListDTO.username,
  gender: Int = this@toUserListDTO.gender
): UserListDTO = UserListDTO(id=id,username=username,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserListDTO.toUserEntity(
  id: Long = this@toUserEntity.id,
  username: String = this@toUserEntity.username,
  password: String = &quot;&quot;,
  gender: Int = this@toUserEntity.gender
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toRegisterDTO(
  username: String = this@toRegisterDTO.username,
  password: String = this@toRegisterDTO.password,
  gender: Int = this@toRegisterDTO.gender
): RegisterDTO = RegisterDTO(username=username,password=password,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun RegisterDTO.toUserEntity(
  id: Long = 0L,
  username: String = this@toUserEntity.username,
  password: String = this@toUserEntity.password,
  gender: Int = this@toUserEntity.gender
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)
</code></pre><pre><code>// @Konvert
// 转换为如下对象
data class UserVO(
    val id: String,
    val name: String,
    val gender: GenderEnum
)

enum class GenderEnum {
    MALE, FEMALE;
}

object GenderEnumConverter : Konvert.KonvertBy&lt;Int, GenderEnum&gt; {
    override fun Int.forward(): GenderEnum {
        return GenderEnum.values()[this]
    }

    override fun GenderEnum.backward(): Int {
        return this.ordinal
    }
}

// 生成的代码
**
 *  Auto generated code by @Konvert
 */
fun UserEntity.toUserVO(
  id: String = this@toUserVO.id.toString(),
  name: String = this@toUserVO.username,
  gender: GenderEnum = with(GenderEnumConverter) { this@toUserVO.gender.forward() }
): UserVO = UserVO(id=id,name=name,gender=gender)

/**
 *  Auto generated code by @Konvert
 */
fun UserVO.toUserEntity(
  id: Long = this@toUserEntity.id.toLong(),
  username: String = this@toUserEntity.name,
  password: String = &quot;&quot;,
  gender: Int = with(GenderEnumConverter) { this@toUserEntity.gender.backward() }
): UserEntity = UserEntity(id=id,username=username,password=password,gender=gender)
</code></pre><h2 id=相关-api-说明>相关 API 说明<a hidden class=anchor aria-hidden=true href=#相关-api-说明>#</a></h2>
<p>转换规则</p>
<ul>
<li>如果转换至 String 类型，原类型不匹配时会调用 <code>toString()</code></li>
<li>如果转换至基础数据类型，转换字段缺失时会使用默认类型</li>
<li>如果转换至允许为 null 类型，原类型不匹配时会使用默认值 null</li>
<li>如果转换至引用类型（String 除外）或者找不到映射需要在转换方法显式赋值</li>
</ul>
<h1 id=下一步>下一步<a hidden class=anchor aria-hidden=true href=#下一步>#</a></h1>
<ul>
<li>代码重构，新增测试用例</li>
<li>支持引用类型默认值</li>
<li>支持嵌套对象</li>
<li>支持 Java</li>
<li>已知 BUG 修复</li>
<li>支持映射失败字段获取原类型的构造函数参数默认值，或者成员变量默认值（目前 Kotlin KAPT 已支持获取<a href=https://youtrack.jetbrains.com/issue/KT-30164>成员变量默认值</a>，暂不支持获取<a href=https://youtrack.jetbrains.com/issue/KT-29355>函数参数默认值</a>）</li>
</ul>
<h1 id=已知-bug>已知 BUG<a hidden class=anchor aria-hidden=true href=#已知-bug>#</a></h1>
<ul>
<li>相同 name 在 @Konvertable 冲突</li>
<li>@Konvertable 参数合法性校验以及友好报错</li>
<li>KonvertBy 目前使用 Class 报错或者使用 Companion 报错</li>
</ul>
<h1 id=最后>最后<a hidden class=anchor aria-hidden=true href=#最后>#</a></h1>
<p>Konverter 源码在 <a href=https://github.com/lexcao/konverter>GitHub</a></p>
<p>相关的样例代码 <a href=https://github.com/lexcao/konverter-demo>GitHub</a></p>
</div>
<footer class=post-footer>
<nav class=paginav>
<a class=prev href=https://lexcao.io/zh/posts/kotlin-equality-diving/>
<span class=title>« 上一页</span>
<br>
<span>Kotlin 奇怪的相等现象探究</span>
</a>
<a class=next href=https://lexcao.io/zh/posts/async-within-async/>
<span class=title>下一页 »</span>
<br>
<span>一次线程死锁排查记录</span>
</a>
</nav>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://lexcao.io/zh/>The Coding Notes</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='复制';function d(){a.innerText='已复制！',setTimeout(()=>{a.innerText='复制'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>