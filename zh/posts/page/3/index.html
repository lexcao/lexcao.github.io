<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>博文 | The Coding Notes</title>
<meta name=keywords content><meta name=description content="博文 - The Coding Notes"><meta name=author content="Lex Cao"><link rel=canonical href=https://lexcao.io/zh/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.0633f72569546c04f177152a4fc857757796b843f92bb1208cf7114db62b1d94.css integrity="sha256-BjP3JWlUbATxdxUqT8hXdXeWuEP5K7EgjPcRTbYrHZQ=" rel="preload stylesheet" as=style><link rel=icon href=https://lexcao.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lexcao.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lexcao.io/favicon-32x32.png><link rel=apple-touch-icon href=https://lexcao.io/apple-touch-icon.png><link rel=mask-icon href=https://lexcao.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://lexcao.io/zh/posts/index.xml><link rel=alternate hreflang=en href=https://lexcao.io/posts/><link rel=alternate hreflang=zh href=https://lexcao.io/zh/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-DDVMDVDZMH"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DDVMDVDZMH")}</script><meta property="og:title" content="博文"><meta property="og:description" content="Share / Summary / Record"><meta property="og:type" content="website"><meta property="og:url" content="https://lexcao.io/zh/posts/"><meta property="og:image" content="https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&amp;fit=crop&amp;w=720&amp;q=80"><meta property="og:site_name" content="The Coding Notes"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&amp;fit=crop&amp;w=720&amp;q=80"><meta name=twitter:title content="博文"><meta name=twitter:description content="Share / Summary / Record"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"博文","item":"https://lexcao.io/zh/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://lexcao.io/zh/ accesskey=h title="代码笔记 (Alt + H)">代码笔记</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://lexcao.io/ title=English aria-label=English>English</a></li></ul></div></div><ul id=menu><li><a href=https://lexcao.io/zh/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://lexcao.io/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://lexcao.io/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://lexcao.io/zh/projects/ title=项目><span>项目</span></a></li><li><a href=https://lexcao.io/zh/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://lexcao.io/zh/>主页</a></div><h1>博文</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>一次线程死锁排查记录</h2></header><div class=entry-content><p>背景 某次发版之后，线上服务低概率出现某台实例接口响应超时，具体表现为：
/health 接口超时报警； 线程死锁，Tomcat 线程池吃满； 服务完全无响应。 保留下当前 heap dump 和 thread stack 后，临时重启服务器恢复正常。
# heap dump $ jmap -dump:format=b,file=dump.hprof [pid] # thread stack jstack [pid] > stack.txt 接下来简单记录一下排查结果。 （此文为回忆所写，当时排查的思考细节和过程已省略）
排查 heap dump 使用工具 Eclipse + MAT
安装 # 安装 eclipse $ brew cask install eclipse-java # 安装 eclipse MAT $ brew cask install mat # 是的，这个就是 eclipse-mat 相关连接 Eclipse
Eclipse MAT
使用 把 heap dump 文件 dump.hprof 导入到 MAT。
发现有一个名称为 Spring-Async-Scheduler 异步队列占用特别大。【TODO 图片】
...</p></div><footer class=entry-footer><span title='2020-03-21 00:00:00 +0000 UTC'>三月 21, 2020</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Lex Cao</footer><a class=entry-link aria-label="post link to 一次线程死锁排查记录" href=https://lexcao.io/zh/posts/async-within-async/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Reactive 概览</h2></header><div class=entry-content><p>Reactive Streams Reactive Streams 在 Netflix 、Pivotal 和 Lightbend 工程师于 2013 年底发起这项计划。
Reactive Streams 是一项提议，为无阻塞背压的异步流提供一个标准。这包括针对运行时环境（JVM 和 JavaScript）以及网络协议上的工作。
你可以在 Reactive Streams 官网网站阅读这个原始规范。
你也可以在 这里 阅读它的中文翻译。
无阻塞背压的异步流处理 Reactive Streams 由以下组成：
异步； 流式； 无阻塞； 背压（回压）。 以下是 Java 接口，你可以在 GitHub 阅读更详细内容。
public interface Publisher&lt;T> { public void subscribe(Subscriber&lt;? super T> s); } public interface Subscriber&lt;T> { public void onSubscribe(Subscription s); public void onNext(T t); public void onError(Throwable t); public void onComplete(); } public interface Subscription { public void request(long n); public void cancel(); } public interface Processor&lt;T, R> extends Subscriber&lt;T>, Publisher&lt;R> { } Reactive Extensions 用于可观察流的异步编程 API。
ReactiveX 是来自观察者模式、迭代器模式以及函数式编程的最佳创意组合。
...</p></div><footer class=entry-footer><span title='2019-11-29 00:00:00 +0000 UTC'>十一月 29, 2019</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Lex Cao</footer><a class=entry-link aria-label="post link to Reactive 概览" href=https://lexcao.io/zh/posts/reactive-overview/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Reactive Streams 规范翻译</h2></header><div class=entry-content><p>翻译自 Reactive Streams
Reactive Streams 注：Reactive Streams 直译为响应式流，这里保留英文原词。
Reactive Streams 是一项提议，旨在为具有无阻塞背压的异步处理流提供标准。这包括针对运行环境（JVM 和 JavaScript）以及网络协议的努力。
Reactive Streams 是为了提供一个无阻塞背压异步流式处理的标准的一个提议。
JDK9 java.util.concurrent.Flow 在 JDK 9 的 java.util.concurrent.Flow 中可用的接口，分别为 1 ：1 语义上各自对应于 Reactive Streams。这意味着将会有一个迁移期，库（Libraries）将采用 JDK 中的新类型，但是由于库的完全语义等效以及 Reactive Streams &lt;-> Flow 适配器库和直接与 JDK Flow 类型兼容的 TCK，因此这个迁移期预计会很短。
如果你有兴趣了解有关 JVM Reactive Streams，请阅读此 文章
问题 在异步系统中，处理流数据（尤其是数量未先确定的的“实时”数据）需要特别注意。最突出的问题是，需要控制资源消耗，这样快速数据源不会压垮流目的地。为了在并行网络主机或一台多核机器上并行地使用计算资源，需要异步。
Reactive Streams 的主要目标是管理跨异步边界的流数据交换（考虑将元素传递到另一个线程或线程池），同时确保接收方不强制缓存任意数量的数据。换句话说，背压是此模型中不可或缺的一部分，以使在线程之间进行调节的队列收到限制。如果背压的通信是同步的，则异步处理的好处将被抵消（另请看 Reactive Manifesto），因此必须注意对 Reactive Streams 实现的所有方面进行完全无阻塞和异步行为授权。
本说明书旨在允许创建许多符合要求的实现，这些实现通过遵守规则将能够平滑地互相操作，并在流应用程序的整个处理图中保留上述好处和特性。
范围 Reactive Streams 的范围是找接口、方法和协议的最小集，这些接口、方法和协议将描述实现目标——无阻塞背压的异步处理流，所需要的操作和实体。
端用户 DSLs（领域特定语言）或者协议绑定 API（应用编程接口）有目的地被排除在范围之外，以鼓励和支持可能使用不同编程语言的不同实现，以尽可能地遵循其平台的习惯用法。
我们预计，接受这个 Reactive Streams 规范以及它的实现经验将共同导向广泛的集成，例如，包括将来 JDK 版本中的 Java 平台支持或者在将来的网页浏览器中网络协议的支持。
工作组 基本含义 基本含义定义了如何通过背压来调节流中元素的传输。元素的传输方式，传输过程中的表现形式或者背压的信号发送方式均不属于本规范的一部分。
...</p></div><footer class=entry-footer><span title='2019-11-17 00:00:00 +0000 UTC'>十一月 17, 2019</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Lex Cao</footer><a class=entry-link aria-label="post link to Reactive Streams 规范翻译" href=https://lexcao.io/zh/posts/reactive-streams/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>选择一个英文名字</h2></header><div class=entry-content><p>简介 最近我在寻找一个方法给自己取一个英文名字，然后我发现这篇文章，如何选择一个英文名字。该文章在选择一个英文名字提出了一个行之有效的方法，我用该方法制作了一个应用来帮助选择一个英文名字。
你可以在 这里 尝试一下。
我会在下面展开讲一下那篇文章和这个应用。
文章所说 以下是文章原文。
Do not try to be creative in picking an English name.
Avoid:
Do not try to pick a fun or cute-sounding name from a movie, television, or video game character Do not pick a name that you think sounds cool or trendy, because Americans will think it sounds stupid Do not pick a name because your friends think it sounds cute, because your friends are not the Americans you have to interact with in the future Do not translate some positive-sounding word in your language into English and make that into your name Do:
...</p></div><footer class=entry-footer><span title='2019-11-10 00:00:00 +0000 UTC'>十一月 10, 2019</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;Lex Cao</footer><a class=entry-link aria-label="post link to 选择一个英文名字" href=https://lexcao.io/zh/posts/choose-english-name/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Jekyll / Hugo / Hexo 比较</h2></header><div class=entry-content><p>选择一个合适的静态网站生成器比较难，尤其是当你第一次想要搭建一个博客网站的时候。这是我第一次搭建一个博客并且没有足够的时间去尝试所有常见的生成器，我选择了 Jekyll 作为第一次搭建使用的生成器，尽管它可能不是最好的一个。我准备以后再尝试其他生成器。
这是我从 Google 找到的一些简要的描述，希望它能对你选择什么生成器开始搭建网站有帮助。
我从 GitHub 选择了以下三个静态博客生成器进行比较
Jekyll Hugo Hexo 什么是静态网站生成器 HTML 文件； 没有服务端处理或者数据库交互； 比动态网站更安全； 利于使用 CDN 进行扩展； 缓存会带来比动态网页更高的效率； 请求超快速。 Jekyll 使用语言 Ruby； GitHub 支持； 使用 GitHub Pages 免费部署。 优势 免费且开源； RubyGems 支持构建主题为 gems 方便分发； 简单便捷使用； 强大的 GitHub Pages 支持； 开箱即用的合适的默认极简主题。 劣势 当网站内容不断增加后，构建速度会明显变慢。
功能 Liquid 模版引擎； 基于 Gem 主题； Markdown 和 YAML 类型支持； Sass 预处理 CSS 支持； 官方插件支持 CoffeeScript。 Hugo 使用语言 Go. 优势 免费开源； 速度非常快，对构建速度做了优化； 内置支持很多功能： 动态 API 请求的内容； 无限制内容类型； shortcakes， 一个灵活的 Markdown 替代； 国际化； 别名重定向； 分页。 预制的 Go 模版和模式； 无需依赖（不用安装 Go，因为它是编译好的二进制）； 功能强大的内容模型。 劣势 主题使用 Go 模版，所以需要熟悉 Go； 没有内置默认主题； 缺少扩展性和插件（因为 Go 是编译型语言）。 功能 Go 模版； 国际化; 支持动态 API。 Hexo 使用 Node.js. 优势 相当快速； 在 GitHub Pages 部署简单； 中文支持（可能是劣势对于非中文用户）； 中文社区。 劣势 没有英文。 功能 EJS 模版引擎; 支持 中文; 对于 HTML + CSS + Javascript 非常友好。 我正在使用 Jekyll
...</p></div><footer class=entry-footer><span title='2019-10-30 00:00:00 +0000 UTC'>十月 30, 2019</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;Lex Cao</footer><a class=entry-link aria-label="post link to Jekyll / Hugo / Hexo 比较" href=https://lexcao.io/zh/posts/jekyll-hugo-hexo/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://lexcao.io/zh/posts/page/2/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://lexcao.io/zh/posts/page/4/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://lexcao.io/zh/>The Coding Notes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>