<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kotlin 奇怪的相等现象探究 | The Coding Notes</title><meta name=keywords content><meta name=description content="最近遇到一个平时没怎么关注的 Kotlin 相等问题，决定记录一下探究过程。
事由 以下代码片段 Kotlin 版本 1.3.72。
还原问题代码，已去除业务逻辑部分，仅保留关键代码，片段如下：
// 有一个状态枚举 enum class MyState {  OK, CANCELED }  // 某个处理函数会返回 nullable MyState fun processing(): MyState? { 	// 假设当前某种情况下返回 取消 这个状态  return MyState.CANCELED }  // 在处理状态时 fun handleState() { 	// 此时编译器推断出类型为 State?  val state = processing()  if (state == CANCELED) {  // 当处理 CANCELED 以下代码没有执行  println(&#34;Handle <CANCELED> state&#34;)  } } 当处理 CANCELED 代码没有执行，原因在于***「import」***。"><meta name=author content="Lex Cao"><link rel=canonical href=https://lexcao.io/zh/posts/kotlin-equality-diving/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b1540977aafa12664148f5c3a53472ca37129bcd9cbbdf6f6336462e0e1e9ecb.css integrity="sha256-sVQJd6r6EmZBSPXDpTRyyjcSm82cu99vYzZGLg4enss=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://lexcao.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://lexcao.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://lexcao.io/favicon-32x32.png><link rel=apple-touch-icon href=https://lexcao.io/apple-touch-icon.png><link rel=mask-icon href=https://lexcao.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.98.0"><link rel=alternate hreflang=en href=https://lexcao.io/posts/kotlin-equality-diving/><link rel=alternate hreflang=zh href=https://lexcao.io/zh/posts/kotlin-equality-diving/><script async src="https://www.googletagmanager.com/gtag/js?id=G-DDVMDVDZMH"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DDVMDVDZMH",{anonymize_ip:!1})}</script><meta property="og:title" content="Kotlin 奇怪的相等现象探究"><meta property="og:description" content="最近遇到一个平时没怎么关注的 Kotlin 相等问题，决定记录一下探究过程。
事由 以下代码片段 Kotlin 版本 1.3.72。
还原问题代码，已去除业务逻辑部分，仅保留关键代码，片段如下：
// 有一个状态枚举 enum class MyState {  OK, CANCELED }  // 某个处理函数会返回 nullable MyState fun processing(): MyState? { 	// 假设当前某种情况下返回 取消 这个状态  return MyState.CANCELED }  // 在处理状态时 fun handleState() { 	// 此时编译器推断出类型为 State?  val state = processing()  if (state == CANCELED) {  // 当处理 CANCELED 以下代码没有执行  println(&#34;Handle <CANCELED> state&#34;)  } } 当处理 CANCELED 代码没有执行，原因在于***「import」***。"><meta property="og:type" content="article"><meta property="og:url" content="https://lexcao.io/zh/posts/kotlin-equality-diving/"><meta property="og:image" content="https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&fit=crop&w=720&q=80"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-21T00:00:00+00:00"><meta property="article:modified_time" content="2020-04-21T00:00:00+00:00"><meta property="og:site_name" content="The Coding Notes"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&fit=crop&w=720&q=80"><meta name=twitter:title content="Kotlin 奇怪的相等现象探究"><meta name=twitter:description content="最近遇到一个平时没怎么关注的 Kotlin 相等问题，决定记录一下探究过程。
事由 以下代码片段 Kotlin 版本 1.3.72。
还原问题代码，已去除业务逻辑部分，仅保留关键代码，片段如下：
// 有一个状态枚举 enum class MyState {  OK, CANCELED }  // 某个处理函数会返回 nullable MyState fun processing(): MyState? { 	// 假设当前某种情况下返回 取消 这个状态  return MyState.CANCELED }  // 在处理状态时 fun handleState() { 	// 此时编译器推断出类型为 State?  val state = processing()  if (state == CANCELED) {  // 当处理 CANCELED 以下代码没有执行  println(&#34;Handle <CANCELED> state&#34;)  } } 当处理 CANCELED 代码没有执行，原因在于***「import」***。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Kotlin 奇怪的相等现象探究","item":"https://lexcao.io/zh/posts/kotlin-equality-diving/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kotlin 奇怪的相等现象探究","name":"Kotlin 奇怪的相等现象探究","description":"最近遇到一个平时没怎么关注的 Kotlin 相等问题，决定记录一下探究过程。\n事由 以下代码片段 Kotlin 版本 1.3.72。\n还原问题代码，已去除业务逻辑部分，仅保留关键代码，片段如下：\n// 有一个状态枚举 enum class MyState {  OK, CANCELED }  // 某个处理函数会返回 nullable MyState fun processing(): MyState? { \t// 假设当前某种情况下返回 取消 这个状态  return MyState.CANCELED }  // 在处理状态时 fun handleState() { \t// 此时编译器推断出类型为 State?  val state = processing()  if (state == CANCELED) {  // 当处理 CANCELED 以下代码没有执行  println(\u0026#34;Handle \u0026lt;CANCELED\u0026gt; state\u0026#34;)  } } 当处理 CANCELED 代码没有执行，原因在于***「import」***。","keywords":[],"articleBody":"最近遇到一个平时没怎么关注的 Kotlin 相等问题，决定记录一下探究过程。\n事由 以下代码片段 Kotlin 版本 1.3.72。\n还原问题代码，已去除业务逻辑部分，仅保留关键代码，片段如下：\n// 有一个状态枚举 enum class MyState {  OK, CANCELED }  // 某个处理函数会返回 nullable MyState fun processing(): MyState? { \t// 假设当前某种情况下返回 取消 这个状态  return MyState.CANCELED }  // 在处理状态时 fun handleState() { \t// 此时编译器推断出类型为 State?  val state = processing()  if (state == CANCELED) {  // 当处理 CANCELED 以下代码没有执行  println(\"Handle  state\")  } } 当处理 CANCELED 代码没有执行，原因在于***「import」***。\nimport javax.print.attribute.standard.JobState.CANCELED // 此处使用静态导入引入了一个其他包中同名的一个静态变量，该变量声明如下 // public static final JobState CANCELED = new JobState (7); 解决方法：\n// 删除上面的静态引包，换成我们的 MyState if (state == MyState.CANCELED) { ... } 👏拍拍手，这个 BUG 改起来真容易。又可以愉快地摸鱼了呢。\n😠等等，作为静态语言面对如此诡异地类型不匹配为什么能够通过编译？\n🤔思考 ❓问题点：\n 🤐 Kotlin 枚举类对比 Java 的一个静态变量，直觉上感觉类型不匹配的情况，为什么能够通过编译？  ❓❓❓头上的问号变多了：\n Kotlin 中其他类型会出现这种类似的情况吗？ Kotlin 编译器具体怎么处理枚举类型的？ Java 会出现这种情况吗？（应该不会）  在 Stack Overflow 和 YouTrack 搜了一圈，没有找到想要的信息。可能是搜索关键字不对😢。\n为了探个究竟，通过以下实验研究 Kotlin 编译器类型不匹配行为。\n「点击跳转到结果部分」\n🔬实验 第一步 实验预期 先看下各自的相等（equality）语法说明：\nJava 中，\n == 比较的是两个对象的引用，也就是内存地址。内存地址相同的前提是两个对象必须是同一种类型； equals() 比较的是两个对象的内容。  Kotlin 中，\n In Kotlin there are two types of equality: Structural equality (a check for equals()).\n a == b = a?.equals(b) ?: (b === null)  Referential equality (two references point to the same object);\n a === b = a and b point to the same object  — kotlin equality\n以下是简单翻译：\nKotlin 中有两种类型的相等：\n结构相等（对 equals() 的检查）\n a == b = a?.equals(b) ?: (b === null)  引用相等（两个引用指向同一对象）\n a === b = a 和 b 指向同一对像   简单来说，\n Java 中的 == 对应 Kotlin ===； Kotlin 中的 == 包含 Java equals 和 ==。  先设置一个预期：\nJava 中的相等，\n equals() 成功通过编译，程序正常运行；  方法入参是 Object，不同类型相比不会报错。   == 不能编译；  引用相同前提需要对象相同。    Kotlin 中的相等，\n === 不能编译；  与 Java 的 == 行为一致，引用相同前提需要对象相同。   == 不能编译；  a?.equals(b) ?: (b === null) 这里 equals 入参是 Any? 能够通过编译，但是后面会对比对象引用，凭直觉来看，有对比引用的话，如果类型不一致，不能编译。    第二步 收集变量 通过上面复现出的问题梳理出以下变量：\n   variable values     条件判断语句 Kotlin: if / when | Java: if / switch   表达式对象 Kotlin: class / enum class / object Java: class / enum / static field   表达式声明 K - K / J - J / J - K    第三步 初步筛选 对于条件判断语句，\n Kotlin 的 if 和 when 的行为一致，所以这里可以只使用 if； Java 中 switch 仅支持 enum / String / primitive ，再加上对于 enum 有严格类型校验（语法层面，当 switch(enum) case 语句就处于该 enum 的上下文，只能使用该 enum 中定义的值。不考虑，同样只使用 if。  if (condition) {} 对于相等判断，\n Java 使用 == 和 equals()； Kotlin 仅使用 == （=== 行为与 Java 中 == 一致，故省略）。  对于表达式对象，每个实验对象定义 a / b ，b 用于同类型时备用。\n   表达式对象 Java Kotlin     class MyJavaClassA / MyJavaClassB MyKotlinClassA / MyKotlinClassB   enum RetentionPolicy / ElementType AnnotationRetention / AnnotationTarget   object / static JobState / JobStateReason MyKotlinObjectA / MyKotlinObjectB    public class MyJavaClassA {} // MyJavaClassA.java public class MyJavaClassB {} // MyJavaClassB.java class MyKotlinClassA // MyKotlinClassA.kt class MyKotlinClassB // MyKotlinClassB.kt object MyKotlinObject // MyKotlinObjectA object MyKotlinObject // MyKotlinObjectB // RetentionPolicy : java.lang.annotation.RetentionPolicy // ElementType : java.lang.annotation.ElementType // AnnotationRetention : kotlin.annotation.AnnotationRetention // AnnotationTarget : kotlin.annotation.AnnotationTarget // JobState : javax.print.attribute.standard.JobState // JobStateReason : javax.print.attribute.standard.JobStateReason 对于表达式声明，还需要新增一个 Kotlin 中 nullable 类型\n// 总共有以下几类 J - J K - K K? - K? J - K J - K? K - K? 第四步 验证框架 // java 验证代码 public class JavaGenerated { void if_JavaClass_To_JavaClass(MyJavaClassB a) { if (a.equals(new MyJavaClassA())) { } else if (a == new MyJavaClassA()) { } } } // kotlin 验证代码 class KotlinGenerated { fun if_JavaClass_To_JavaClass(a: MyJavaClassB) { if (a == MyJavaClassA()) { } } } 第五步 编码验证 有了上面的模版之后，就可以根据变量开始编码验证。\n面对多种的变量组合的情况，手动编写大量的模版代码非常的劳累。\n所以利用工具，使用 JavaPoet 和 KotlinPoet 来生成代码。\n(花了一天来写自动生成代码逻辑，完成后感到一阵空虚，为什么要花那么多的时间折腾，手动复制粘贴早写完了。)\n😭这里大致说以下生成的思路：\n1. 分别枚举出需要测试的三种类型，JavaCase 和 KotlinCase 2. JavaCase 和 KotlinCase 中相两两组合 得到 java-kotlin 3. 根据 java-kotlin 再次组合 5 种情况 * J 2 J * J 2 K * K 2 K * K? 2 K * K? 2 J 4. 根据 java-kotlin-pairs 生成对应的 KotlinIf 和 JavaIf 方法 5. 根据方法，通过 JavaPoet 和 KotlinPoet 代码 生成后的代码挺多的，感兴趣的去看，这两个文件：\n JavaGenerated.java KotlinGenerated.kt  第六步 观察结果  环境如下\n Java Version 1.8.0_172 Kotlin Version 1.3.72 IDEA Version 2020.1   这里结果大致分为两类：\n [error] ，不能编译。编译器告警，在 IDEA 中红色波浪线标出； [warning] ，能够编译。IDEA 告警，以黄色背景高亮。  JavaGenerated.java 完全符合预期，\n == 不能编译； equals() 能够编译，另外 IDEA 给出友好提醒。     type == equals     Class [error] Operator ‘==’ cannot be applied [warning] inconvertible types   Static [error] Operator ‘==’ cannot be applied [warning] inconvertible types   Enum [error] Operator ‘==’ cannot be applied [warning] condition is always false    KotlinGenerated.kt 部分符合预期，\n === 不能编译； == 对于 Kotlin 的 Class / Static 不能编译。     type ==     Class [error] EQUALITY_NOT_APPLICABLE,Operator ‘==’ cannot be applied   Static [error] EQUALITY_NOT_APPLICABLE,Operator ‘==’ cannot be applied   Enum [warning] INCOMPATIBLE_ENUM_COMPARISON,Comparison of incompatible enums is always unsuccessful    不符合预期，\n Java Class / Static 可以编译； Enum 可以编译。  下面是相关代码：\nfun if_JavaClass_To_JavaClass(a: MyJavaClassB) {  if (a == MyJavaClassA()) {  } }  fun if_JavaStatic_To_JavaStatic(a: JobStateReason) {  if (a == JobState.CANCELED) {  } }  fun if_NullableKotlinEnum_To_JavaStatic(a: AnnotationRetention?) {  if (a == JobState.CANCELED) {  } } 以上情况可以归纳为：\n Java 对象类型(Class/Static)，能通过编译；  JavaClass_To_JavaClass JavaStatic_To_JavaStatic   可空的 Kotlin 枚举类型对应 Java 静态类型，能通过编译；  NullableKotlinEnum_To_JavaStatic    大致梳理出以下疑问点： 2. Class / Static 的对比为什么比 Java 的 equals 更严格？ 3. 为什么 Enum 的对比可以通过编译，没有像上面那么严格？ 4. 使用两个不同的 Java 的对象对比，为什么可以通过编译？ 5. nullable 的枚举类为什么可以与 Java 的静态类型对比？\n第七步 探究原因  再回顾一下 Kotlin 官方文档中对相等（equality）的定义：\na == b = a?.equals(b) ?: (b === null) a === b = a and b point to the same object 1. Class / Static 的对比为什么比 Java 的 equals 更严格？ （目前没有想清楚原因）TODO ：这里应该去看 Kotlin 编译器在处理 EQUALITY_NOT_APPLICABLE 这个报错。\n2. 为什么 Enum 的对比可以通过编译，没有像上面那么严格？ 在 Java 中 enum 其实是语法糖，最终会被编译为范型类。\nabstract class EnumE extends EnumE { ... } Kotlin 不例外，enum class 也是语法糖，最终会被编译为范型类。\nabstract class Enum { ... } 当两个枚举对比的时候，相当与是同一个类的不同范型，所以能够通过编译，不会出现类型不匹配问题。\n这里，IDEA 告警 INCOMPATIBLE_ENUM_COMPARISON 给出友好提示。\n3. 使用两个不同的 Java 的对象对比，为什么可以通过编译？ Kotlin 中有严格的 Nullable / Notnull 语法。\n当与 Java 的类进行互相调用时，由于 Java 中的 Null 信息不确定，编译器无法推断出 Java 类的具体 Null 信息(默认视为 Nullable)。 可以在 IDEA 的智能类型推断中看到 ! 的标识。 （在 Java 中显式使用 JetBrains 提供的 @Nullable / @NotNull 这两个注解，可以让 Kotlin 编译器正确推断出 Null 信息） 【TODO，提供 IDEA 截图更好】\n所以两个 Nullable 类型的进行比较的时候，会走到 b === null 这个判断，不会报错，能够编译。\n4. Kotlin nullable 的枚举类为什么可以与 Java 的静态类型对比？ 进行上述前置探索，终于到这次问题的终点。结合上面的结论，总结如下：\n 枚举类编译后是同一个 Enum 类； Java 的静态类型 Null 信息未知； 两个 Nullable 类型进行对比，会走到 b === null 判断，不会报错，能够编译。  // 给 Java 的类明确的 Null 信息 // IDEA 出现友好警告 [INCOMPATIBLE_ENUM_COMPARISON] fun if_NullableKotlinEnum_To_JavaStatic(a: AnnotationRetention?) {  // 使用 !! 告诉编译器，明确 Null 信息是 Notnull  if (a == JobState.CANCELED!!) {  // [INCOMPATIBLE_ENUM_COMPARISON] Comparison of incompatible enums  // 'AnnotationRetention?' and 'JobState' is always unsuccessful  } } 👀总结  整个探求真相的过程还是很有趣的； 最后知道真相后，还是自己太菜了，基础知识没有完全掌握； 深入探究了 Kotlin 和 Java 的相等和枚举相关的内容； 下一步：趁着这股好奇心，去了解 Kotlin 编译器的相等类型判断源码。  🔗相关链接  GitHub Source Code Kotlin Equality Docs JavaPoet KotlinPoet JavaGenerated.java KotlinGenerated.kt  ","wordCount":"939","inLanguage":"zh","datePublished":"2020-04-21T00:00:00Z","dateModified":"2020-04-21T00:00:00Z","author":{"@type":"Person","name":"Lex Cao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://lexcao.io/zh/posts/kotlin-equality-diving/"},"publisher":{"@type":"Organization","name":"The Coding Notes","logo":{"@type":"ImageObject","url":"https://lexcao.io/favicon.ico"}}}</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-KJ277ZJ" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://lexcao.io/zh/ accesskey=h title="代码笔记 (Alt + H)">代码笔记</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://lexcao.io/ title=English aria-label=English>English</a></li></ul></span></div><ul id=menu><li><a href=https://lexcao.io/zh/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li><li><a href=https://lexcao.io/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://lexcao.io/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://lexcao.io/zh/projects/ title=项目><span>项目</span></a></li><li><a href=https://lexcao.io/zh/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://lexcao.io/zh/>主页</a></div><h1 class=post-title>Kotlin 奇怪的相等现象探究</h1><div class=post-meta>2020 April 21&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;Lex Cao&nbsp;|&nbsp;<ul class=i18n_list>语言:<li><a href=https://lexcao.io/posts/kotlin-equality-diving/>English</a></li></ul></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>目录</div></summary><div class=inner><ul><li><a href=#%e4%ba%8b%e7%94%b1 aria-label=事由>事由</a></li><li><a href=#%e6%80%9d%e8%80%83 aria-label=🤔思考>🤔思考</a></li><li><a href=#%e5%ae%9e%e9%aa%8c aria-label=🔬实验>🔬实验</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e6%ad%a5-%e5%ae%9e%e9%aa%8c%e9%a2%84%e6%9c%9f aria-label="第一步 实验预期">第一步 实验预期</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e6%ad%a5-%e6%94%b6%e9%9b%86%e5%8f%98%e9%87%8f aria-label="第二步 收集变量">第二步 收集变量</a></li><li><a href=#%e7%ac%ac%e4%b8%89%e6%ad%a5-%e5%88%9d%e6%ad%a5%e7%ad%9b%e9%80%89 aria-label="第三步 初步筛选">第三步 初步筛选</a></li><li><a href=#%e7%ac%ac%e5%9b%9b%e6%ad%a5-%e9%aa%8c%e8%af%81%e6%a1%86%e6%9e%b6 aria-label="第四步 验证框架">第四步 验证框架</a></li><li><a href=#%e7%ac%ac%e4%ba%94%e6%ad%a5-%e7%bc%96%e7%a0%81%e9%aa%8c%e8%af%81 aria-label="第五步 编码验证">第五步 编码验证</a></li><li><a href=#%e7%ac%ac%e5%85%ad%e6%ad%a5-%e8%a7%82%e5%af%9f%e7%bb%93%e6%9e%9c aria-label="第六步 观察结果">第六步 观察结果</a><ul><li><a href=#javageneratedjava aria-label=JavaGenerated.java>JavaGenerated.java</a><ul><li><a href=#kotlingeneratedkt aria-label=KotlinGenerated.kt>KotlinGenerated.kt</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%83%e6%ad%a5-%e6%8e%a2%e7%a9%b6%e5%8e%9f%e5%9b%a0-a-nameconclusion- aria-label="第七步 探究原因 ">第七步 探究原因</a><ul><li><a href=#1-class--static-%e7%9a%84%e5%af%b9%e6%af%94%e4%b8%ba%e4%bb%80%e4%b9%88%e6%af%94-java-%e7%9a%84-equals-%e6%9b%b4%e4%b8%a5%e6%a0%bc aria-label="1. Class / Static 的对比为什么比 Java 的 equals 更严格？">1. Class / Static 的对比为什么比 Java 的 equals 更严格？</a></li><li><a href=#2-%e4%b8%ba%e4%bb%80%e4%b9%88-enum-%e7%9a%84%e5%af%b9%e6%af%94%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e7%bc%96%e8%af%91%e6%b2%a1%e6%9c%89%e5%83%8f%e4%b8%8a%e9%9d%a2%e9%82%a3%e4%b9%88%e4%b8%a5%e6%a0%bc aria-label="2. 为什么 Enum 的对比可以通过编译，没有像上面那么严格？">2. 为什么 Enum 的对比可以通过编译，没有像上面那么严格？</a></li><li><a href=#3-%e4%bd%bf%e7%94%a8%e4%b8%a4%e4%b8%aa%e4%b8%8d%e5%90%8c%e7%9a%84-java-%e7%9a%84%e5%af%b9%e8%b1%a1%e5%af%b9%e6%af%94%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87%e7%bc%96%e8%af%91 aria-label="3. 使用两个不同的 Java 的对象对比，为什么可以通过编译？">3. 使用两个不同的 Java 的对象对比，为什么可以通过编译？</a></li><li><a href=#4-kotlin-nullable-%e7%9a%84%e6%9e%9a%e4%b8%be%e7%b1%bb%e4%b8%ba%e4%bb%80%e4%b9%88%e5%8f%af%e4%bb%a5%e4%b8%8e-java-%e7%9a%84%e9%9d%99%e6%80%81%e7%b1%bb%e5%9e%8b%e5%af%b9%e6%af%94 aria-label="4. Kotlin nullable 的枚举类为什么可以与 Java 的静态类型对比？">4. Kotlin nullable 的枚举类为什么可以与 Java 的静态类型对比？</a></li></ul></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=👀总结>👀总结</a></li><li><a href=#%e7%9b%b8%e5%85%b3%e9%93%be%e6%8e%a5 aria-label=🔗相关链接>🔗相关链接</a></li></ul></div></details></div><div class=post-content><p>最近遇到一个平时没怎么关注的 Kotlin 相等问题，决定记录一下探究过程。</p><h1 id=事由>事由<a hidden class=anchor aria-hidden=true href=#事由>#</a></h1><p>以下代码片段 Kotlin 版本 <code>1.3.72</code>。</p><p>还原问题代码，已去除业务逻辑部分，仅保留关键代码，片段如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// 有一个状态枚举
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyState</span> {
</span></span><span style=display:flex><span>    OK, CANCELED
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 某个处理函数会返回 nullable MyState
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>processing</span>(): MyState? {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 假设当前某种情况下返回 取消 这个状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> MyState.CANCELED
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在处理状态时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>handleState</span>() {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 此时编译器推断出类型为 State?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>val</span> state = processing()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (state <span style=color:#f92672>==</span> CANCELED) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当处理 CANCELED 以下代码没有执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        println(<span style=color:#e6db74>&#34;Handle &lt;CANCELED&gt; state&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当处理 CANCELED 代码没有执行，原因在于***「import」***。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> javax.print.attribute.standard.JobState.CANCELED
</span></span><span style=display:flex><span><span style=color:#75715e>// 此处使用静态导入引入了一个其他包中同名的一个静态变量，该变量声明如下
</span></span></span><span style=display:flex><span><span style=color:#75715e>// public static final JobState CANCELED = new JobState (7);
</span></span></span></code></pre></div><p>解决方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// 删除上面的静态引包，换成我们的 MyState
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (state <span style=color:#f92672>==</span> MyState.CANCELED) { <span style=color:#f92672>..</span>. }
</span></span></code></pre></div><p>👏拍拍手，这个 BUG 改起来真容易。又可以愉快地摸鱼了呢。</p><p>😠等等，作为静态语言面对如此诡异地类型不匹配为什么能够通过编译？</p><h1 id=思考>🤔思考<a hidden class=anchor aria-hidden=true href=#思考>#</a></h1><p>❓问题点：</p><ul><li>🤐 Kotlin 枚举类对比 Java 的一个静态变量，直觉上感觉类型不匹配的情况，为什么能够通过编译？</li></ul><p>❓❓❓头上的问号变多了：</p><ul><li>Kotlin 中其他类型会出现这种类似的情况吗？</li><li>Kotlin 编译器具体怎么处理枚举类型的？</li><li>Java 会出现这种情况吗？（应该不会）</li></ul><p>在 Stack Overflow 和 YouTrack 搜了一圈，没有找到想要的信息。
可能是搜索关键字不对😢。</p><p>为了探个究竟，通过以下实验研究 Kotlin 编译器类型不匹配行为。</p><p><a href=#conclusion>「点击跳转到结果部分」</a></p><h1 id=实验>🔬实验<a hidden class=anchor aria-hidden=true href=#实验>#</a></h1><h2 id=第一步-实验预期>第一步 实验预期<a hidden class=anchor aria-hidden=true href=#第一步-实验预期>#</a></h2><p>先看下各自的相等（<em><strong>equality</strong></em>）语法说明：</p><p>Java 中，</p><ul><li><code>==</code> 比较的是两个对象的引用，也就是内存地址。内存地址相同的前提是两个对象必须是同一种类型；</li><li><code>equals()</code> 比较的是两个对象的内容。</li></ul><p>Kotlin 中，</p><blockquote><p>In Kotlin there are two types of equality:
Structural equality (a check for equals()).</p><ul><li><code>a == b</code> => a?.equals(b) ?: (b === null)</li></ul><p>Referential equality (two references point to the same object);</p><ul><li><code>a === b</code> => a and b point to the same object</li></ul><p>&mdash; <a href=https://kotlinlang.org/docs/reference/equality.html>kotlin equality</a></p><p>以下是简单翻译：</p><p>Kotlin 中有两种类型的相等：</p><p>结构相等（对 equals() 的检查）</p><ul><li><code>a == b</code> => <code>a?.equals(b) ?: (b === null)</code></li></ul><p>引用相等（两个引用指向同一对象）</p><ul><li><code>a === b</code> => a 和 b 指向同一对像</li></ul></blockquote><p>简单来说，</p><ul><li>Java 中的 <code>==</code> 对应 Kotlin <code>===</code>；</li><li>Kotlin 中的 <code>==</code> 包含 Java <code>equals</code> 和 <code>==</code>。</li></ul><p>先设置一个预期：</p><p>Java 中的相等，</p><ul><li><code>equals()</code> 成功通过编译，程序正常运行；<ul><li>方法入参是 <code>Object</code>，不同类型相比不会报错。</li></ul></li><li><code>==</code> 不能编译；<ul><li>引用相同前提需要对象相同。</li></ul></li></ul><p>Kotlin 中的相等，</p><ul><li><code>===</code> 不能编译；<ul><li>与 Java 的 <code>==</code> 行为一致，引用相同前提需要对象相同。</li></ul></li><li><code>==</code> 不能编译；<ul><li><code>a?.equals(b) ?: (b === null)</code> 这里 <code>equals</code> 入参是 <code>Any?</code> 能够通过编译，但是后面会对比对象引用，凭直觉来看，有对比引用的话，如果类型不一致，不能编译。</li></ul></li></ul><h2 id=第二步-收集变量>第二步 收集变量<a hidden class=anchor aria-hidden=true href=#第二步-收集变量>#</a></h2><p>通过上面复现出的问题梳理出以下变量：</p><table><thead><tr><th>variable</th><th>values</th></tr></thead><tbody><tr><td>条件判断语句</td><td>Kotlin: if / when | Java: if / switch</td></tr><tr><td>表达式对象</td><td>Kotlin: class / enum class / object Java: class / enum / static field</td></tr><tr><td>表达式声明</td><td>K - K / J - J / J - K</td></tr></tbody></table><h2 id=第三步-初步筛选>第三步 初步筛选<a hidden class=anchor aria-hidden=true href=#第三步-初步筛选>#</a></h2><p>对于条件判断语句，</p><ul><li>Kotlin 的 if 和 when 的行为一致，所以这里可以只使用 if；</li><li>Java 中 switch 仅支持 enum / String / primitive ，再加上对于 enum 有严格类型校验（语法层面，当 <code>switch(enum)</code> case 语句就处于该 enum 的上下文，只能使用该 enum 中定义的值。不考虑，同样只使用 if。</li></ul><pre tabindex=0><code>if (condition) {}
</code></pre><p>对于相等判断，</p><ul><li>Java 使用 <code>==</code> 和 <code>equals()</code>；</li><li>Kotlin 仅使用 <code>==</code> （<code>===</code> 行为与 Java 中 <code>==</code> 一致，故省略）。</li></ul><p>对于表达式对象，每个实验对象定义 a / b ，b 用于同类型时备用。</p><table><thead><tr><th>表达式对象</th><th>Java</th><th>Kotlin</th></tr></thead><tbody><tr><td>class</td><td>MyJavaClassA / MyJavaClassB</td><td>MyKotlinClassA / MyKotlinClassB</td></tr><tr><td>enum</td><td>RetentionPolicy / ElementType</td><td>AnnotationRetention / AnnotationTarget</td></tr><tr><td>object / static</td><td>JobState / JobStateReason</td><td>MyKotlinObjectA / MyKotlinObjectB</td></tr></tbody></table><pre tabindex=0><code>public class MyJavaClassA {} // MyJavaClassA.java

public class MyJavaClassB {} // MyJavaClassB.java

class MyKotlinClassA // MyKotlinClassA.kt

class MyKotlinClassB // MyKotlinClassB.kt

object MyKotlinObject // MyKotlinObjectA

object MyKotlinObject // MyKotlinObjectB

// RetentionPolicy      : java.lang.annotation.RetentionPolicy
// ElementType          : java.lang.annotation.ElementType
// AnnotationRetention  : kotlin.annotation.AnnotationRetention
// AnnotationTarget     : kotlin.annotation.AnnotationTarget
// JobState             : javax.print.attribute.standard.JobState
// JobStateReason       : javax.print.attribute.standard.JobStateReason
</code></pre><p>对于表达式声明，还需要新增一个 Kotlin 中 nullable 类型</p><pre tabindex=0><code>// 总共有以下几类
J - J
K - K
K? - K?

J - K
J - K?
K - K?
</code></pre><h2 id=第四步-验证框架>第四步 验证框架<a hidden class=anchor aria-hidden=true href=#第四步-验证框架>#</a></h2><pre tabindex=0><code>// java 验证代码
public class JavaGenerated {
		void if_JavaClass_To_JavaClass(MyJavaClassB a) {
    		if (a.equals(new MyJavaClassA())) {
    		} else if (a == new MyJavaClassA()) {
    		}
  	}
}

// kotlin 验证代码
class KotlinGenerated {
  	fun if_JavaClass_To_JavaClass(a: MyJavaClassB) {
    		if (a == MyJavaClassA()) {
    		}
  	}
}
</code></pre><h2 id=第五步-编码验证>第五步 编码验证<a hidden class=anchor aria-hidden=true href=#第五步-编码验证>#</a></h2><p>有了上面的模版之后，就可以根据变量开始编码验证。</p><p>面对多种的变量组合的情况，手动编写大量的模版代码非常的劳累。</p><p>所以利用工具，使用 <a href=https://github.com/square/javapoet><em>JavaPoet</em></a> 和 <a href=https://github.com/square/kotlinpoet><em>KotlinPoet</em></a> 来生成代码。</p><p>(花了一天来写自动生成代码逻辑，完成后感到一阵空虚，为什么要花那么多的时间折腾，手动复制粘贴早写完了。)</p><p>😭这里大致说以下生成的思路：</p><pre tabindex=0><code>1. 分别枚举出需要测试的三种类型，JavaCase 和 KotlinCase
2. JavaCase 和 KotlinCase 中相两两组合 得到 java-kotlin
3. 根据 java-kotlin 再次组合 5 种情况
    * J 2 J
    * J 2 K
    * K 2 K
    * K? 2 K
    * K? 2 J
4. 根据 java-kotlin-pairs 生成对应的 KotlinIf 和 JavaIf 方法
5. 根据方法，通过 JavaPoet 和 KotlinPoet 代码
</code></pre><p>生成后的代码挺多的，感兴趣的去看，这两个文件：</p><ul><li><a href=https://github.com/lexcao/kotlin-equality/blob/generated/src/main/java/io/github/lexcao/equality/generated/JavaGenerated.java><em>JavaGenerated.java</em></a></li><li><a href=https://github.com/lexcao/kotlin-equality/blob/generated/src/main/kotlin/io/github/lexcao/equality/generated/KotlinGenerated.kt><em>KotlinGenerated.kt</em></a></li></ul><h2 id=第六步-观察结果>第六步 观察结果<a hidden class=anchor aria-hidden=true href=#第六步-观察结果>#</a></h2><blockquote><p>环境如下</p><ul><li>Java Version 1.8.0_172</li><li>Kotlin Version 1.3.72</li><li>IDEA Version 2020.1</li></ul></blockquote><p>这里结果大致分为两类：</p><ul><li><strong>[error]</strong> ，不能编译。编译器告警，在 IDEA 中红色波浪线标出；</li><li><strong>[warning]</strong> ，能够编译。IDEA 告警，以黄色背景高亮。</li></ul><h3 id=javageneratedjava>JavaGenerated.java<a hidden class=anchor aria-hidden=true href=#javageneratedjava>#</a></h3><p>完全符合预期，</p><ul><li><code>==</code> 不能编译；</li><li><code>equals()</code> 能够编译，另外 IDEA 给出友好提醒。</li></ul><table><thead><tr><th>type</th><th>==</th><th>equals</th></tr></thead><tbody><tr><td>Class</td><td><strong>[error]</strong> Operator &lsquo;==&rsquo; cannot be applied</td><td><strong>[warning]</strong> inconvertible types</td></tr><tr><td>Static</td><td><strong>[error]</strong> Operator &lsquo;==&rsquo; cannot be applied</td><td><strong>[warning]</strong> inconvertible types</td></tr><tr><td>Enum</td><td><strong>[error]</strong> Operator &lsquo;==&rsquo; cannot be applied</td><td><strong>[warning]</strong> condition is always false</td></tr></tbody></table><h4 id=kotlingeneratedkt>KotlinGenerated.kt<a hidden class=anchor aria-hidden=true href=#kotlingeneratedkt>#</a></h4><p>部分符合预期，</p><ul><li><code>===</code> 不能编译；</li><li><code>==</code> 对于 Kotlin 的 Class / Static 不能编译。</li></ul><table><thead><tr><th>type</th><th>==</th></tr></thead><tbody><tr><td>Class</td><td><strong>[error]</strong> EQUALITY_NOT_APPLICABLE,Operator &lsquo;==&rsquo; cannot be applied</td></tr><tr><td>Static</td><td><strong>[error]</strong> EQUALITY_NOT_APPLICABLE,Operator &lsquo;==&rsquo; cannot be applied</td></tr><tr><td>Enum</td><td><strong>[warning]</strong> INCOMPATIBLE_ENUM_COMPARISON,Comparison of incompatible enums is always unsuccessful</td></tr></tbody></table><p>不符合预期，</p><ul><li>Java Class / Static 可以编译；</li><li>Enum 可以编译。</li></ul><p>下面是相关代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>if</span>_JavaClass_To_JavaClass(a: MyJavaClassB) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> MyJavaClassA()) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>if</span>_JavaStatic_To_JavaStatic(a: JobStateReason) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> JobState.CANCELED) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>if</span>_NullableKotlinEnum_To_JavaStatic(a: AnnotationRetention?) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> JobState.CANCELED) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以上情况可以归纳为：</p><ul><li>Java 对象类型(Class/Static)，能通过编译；<ul><li>JavaClass_To_JavaClass</li><li>JavaStatic_To_JavaStatic</li></ul></li><li>可空的 Kotlin 枚举类型对应 Java 静态类型，能通过编译；<ul><li>NullableKotlinEnum_To_JavaStatic</li></ul></li></ul><p>大致梳理出以下疑问点：
2. Class / Static 的对比为什么比 Java 的 equals 更严格？
3. 为什么 Enum 的对比可以通过编译，没有像上面那么严格？
4. 使用两个不同的 Java 的对象对比，为什么可以通过编译？
5. nullable 的枚举类为什么可以与 Java 的静态类型对比？</p><h2 id=第七步-探究原因-a-nameconclusion->第七步 探究原因 <a hidden class=anchor aria-hidden=true href=#第七步-探究原因-a-nameconclusion->#</a></h2><p>再回顾一下 Kotlin 官方文档中对相等（<em><strong>equality</strong></em>）的定义：</p><pre tabindex=0><code>a == b =&gt; a?.equals(b) ?: (b === null)
a === b =&gt; a and b point to the same object
</code></pre><h3 id=1-class--static-的对比为什么比-java-的-equals-更严格>1. Class / Static 的对比为什么比 Java 的 equals 更严格？<a hidden class=anchor aria-hidden=true href=#1-class--static-的对比为什么比-java-的-equals-更严格>#</a></h3><p>（目前没有想清楚原因）TODO ：这里应该去看 Kotlin 编译器在处理 <code>EQUALITY_NOT_APPLICABLE</code> 这个报错。</p><h3 id=2-为什么-enum-的对比可以通过编译没有像上面那么严格>2. 为什么 Enum 的对比可以通过编译，没有像上面那么严格？<a hidden class=anchor aria-hidden=true href=#2-为什么-enum-的对比可以通过编译没有像上面那么严格>#</a></h3><p>在 Java 中 <code>enum</code> 其实是语法糖，最终会被编译为范型类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Enum</span><span style=color:#f92672>&lt;</span>E <span style=color:#66d9ef>extends</span> Enum<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Kotlin 不例外，<code>enum class</code> 也是语法糖，最终会被编译为范型类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Enum</span>&lt;E : Enum&lt;E&gt;&gt; { <span style=color:#f92672>..</span>. }
</span></span></code></pre></div><p>当两个枚举对比的时候，相当与是同一个类的不同范型，所以能够通过编译，不会出现类型不匹配问题。</p><p>这里，IDEA 告警 <code>INCOMPATIBLE_ENUM_COMPARISON</code> 给出友好提示。</p><h3 id=3-使用两个不同的-java-的对象对比为什么可以通过编译>3. 使用两个不同的 Java 的对象对比，为什么可以通过编译？<a hidden class=anchor aria-hidden=true href=#3-使用两个不同的-java-的对象对比为什么可以通过编译>#</a></h3><p>Kotlin 中有严格的 <code>Nullable / Notnull</code> 语法。</p><p>当与 Java 的类进行互相调用时，由于 Java 中的 <code>Null</code> 信息不确定，编译器无法推断出 Java 类的具体 <code>Null</code> 信息(默认视为 <code>Nullable</code>)。
可以在 IDEA 的智能类型推断中看到 <code>!</code> 的标识。
（在 Java 中显式使用 JetBrains 提供的 <code>@Nullable / @NotNull</code> 这两个注解，可以让 Kotlin 编译器正确推断出 <code>Null</code> 信息）
【TODO，提供 IDEA 截图更好】</p><p>所以两个 <code>Nullable</code> 类型的进行比较的时候，会走到 <code>b === null</code> 这个判断，不会报错，能够编译。</p><h3 id=4-kotlin-nullable-的枚举类为什么可以与-java-的静态类型对比>4. Kotlin nullable 的枚举类为什么可以与 Java 的静态类型对比？<a hidden class=anchor aria-hidden=true href=#4-kotlin-nullable-的枚举类为什么可以与-java-的静态类型对比>#</a></h3><p>进行上述前置探索，终于到这次问题的终点。结合上面的结论，总结如下：</p><ol><li>枚举类编译后是同一个 <code>Enum</code> 类；</li><li>Java 的静态类型 <code>Null</code> 信息未知；</li><li>两个 <code>Nullable</code> 类型进行对比，会走到 <code>b === null</code> 判断，不会报错，能够编译。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// 给 Java 的类明确的 Null 信息
</span></span></span><span style=display:flex><span><span style=color:#75715e>// IDEA 出现友好警告 [INCOMPATIBLE_ENUM_COMPARISON]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>if</span>_NullableKotlinEnum_To_JavaStatic(a: AnnotationRetention?) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 !! 告诉编译器，明确 Null 信息是 Notnull
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> JobState.CANCELED<span style=color:#f92672>!!</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// [INCOMPATIBLE_ENUM_COMPARISON] Comparison of incompatible enums 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// &#39;AnnotationRetention?&#39; and &#39;JobState&#39; is always unsuccessful
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=总结>👀总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><ul><li>整个探求真相的过程还是很有趣的；</li><li>最后知道真相后，还是自己太菜了，基础知识没有完全掌握；</li><li>深入探究了 Kotlin 和 Java 的相等和枚举相关的内容；</li><li>下一步：趁着这股好奇心，去了解 Kotlin 编译器的相等类型判断源码。</li></ul><h1 id=相关链接>🔗相关链接<a hidden class=anchor aria-hidden=true href=#相关链接>#</a></h1><ul><li><a href=https://github.com/lexcao/kotlin-java-equality-palyground><em><strong>GitHub Source Code</strong></em></a></li><li><a href=https://kotlinlang.org/docs/reference/equality.html><em><strong>Kotlin Equality Docs</strong></em></a></li><li><a href=https://github.com/square/javapoet><em>JavaPoet</em></a></li><li><a href=https://github.com/square/kotlinpoet><em>KotlinPoet</em></a></li><li><a href=https://github.com/lexcao/kotlin-equality/blob/generated/src/main/java/io/github/lexcao/equality/generated/JavaGenerated.java><em>JavaGenerated.java</em></a></li><li><a href=https://github.com/lexcao/kotlin-equality/blob/generated/src/main/kotlin/io/github/lexcao/equality/generated/KotlinGenerated.kt><em>KotlinGenerated.kt</em></a></li></ul></div><footer class=post-footer><nav class=paginav><a class=prev href=https://lexcao.io/zh/posts/spring-data-jpa-join-table/><span class=title>« 上一页</span><br><span>Spring Data JPA 多条件动态连表查询</span></a>
<a class=next href=https://lexcao.io/zh/posts/konverter/><span class=title>下一页 »</span><br><span>使用 KAPT 生成 Kotlin Data Class 转换器</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://lexcao.io/zh/>The Coding Notes</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="复制";function s(){e.innerText="已复制！",setTimeout(()=>{e.innerText="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>