<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on The Coding Notes</title>
    <link>https://lexcao.io/zh/tags/java/</link>
    <description>Recent content in Java on The Coding Notes</description>
    <image>
      <url>https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&fit=crop&w=720&q=80</url>
      <link>https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&fit=crop&w=720&q=80</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 03 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://lexcao.io/zh/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kotlin/Java TDD 开发流程记录</title>
      <link>https://lexcao.io/zh/posts/kotlin-java-tdd-example/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lexcao.io/zh/posts/kotlin-java-tdd-example/</guid>
      <description>通过使用 Kotlin / Java 中 Junit5 和 Mockito 测试框架，在预约功能中演示 TDD 开发流程。
TDD 介绍 TDD（Test-Driven Development） 是一种开发流程，中文是「测试驱动开发」。用一句白话形容，就是「先写测试再开发」。先写测试除了能确保测试程式的撰写，还有一个好处：有助于在开发初期厘清程式介面如何设计。详细理论知识可以前往 Wiki 了解，这里不再过多介绍。
 测试驱动开发 Test Driven Development  TDD 开发流程（5步） 术语说明：
 红灯 - Failure - 测试用例失败 绿灯 - Success - 测试用例成功 重构 - Refactor - 重构功能代码  具体步骤：
 选定一个功能，编写测试用例 执行测试，得到【红灯】 编写满足测试用例的功能代码 再次执行，得到【绿灯】 【重构】代码  小结：
对于每一个功能，在【红灯】-【绿灯】-【重构】间来回循环往复，不断得到完善。
前置工作 代码说明  使用 Kotlin 语言（会有相对应的 Java 代码） 使用到的测试框架  Running: JUnit5 Mock: MockK / Mockito Assertion: Kotest / AssertJ   只涉及 TDD 的具体流程，不涉及单元测试如何编写（可以看 SpringBoot 单元测试各层）  功能介绍 假设一个用户预约的场景。</description>
    </item>
    
    <item>
      <title>Spring Data JPA 多条件动态连表查询</title>
      <link>https://lexcao.io/zh/posts/spring-data-jpa-join-table/</link>
      <pubDate>Sun, 04 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://lexcao.io/zh/posts/spring-data-jpa-join-table/</guid>
      <description>痛点 项目中使用 Spring Data JPA 作为 ORM 框架的时候，实体映射非常方便。Spring Data Repository 的顶层抽象完全解决单实体的查询，面对单实体的复杂查询，也能使用 JpaSpecificationExecutor&amp;lt;T&amp;gt; 构造 Specification&amp;lt;T&amp;gt; 轻松应对。
而对于后台管理报表查询需求来说，需要进行连表多条件动态查询的时候，就显得无从下手。因为它并不像 MyBatis 一样能够在 XML 文件中写出动态 SQL 语句。
尽管可以使用 EntityManager 动态拼接原生 SQL 语句，但是该方法返回值为 ResultSet ，也就是说查出来的实体映射关系需要手动映射（😢这样不太优雅，已经定义出实体，还需要自己去映射）。
所以，本文的目的是，在现有实体关系的基础上，结合 Specification&amp;lt;T&amp;gt; 记录下 Spring Data JPA 多条件动态连表查询操作，以及其中的踩坑和优化。
基础操作 那么，让我们开始进入代码操作。【本文所有代码在此】
前置说明 相关依赖  Java 11 SpringBoot 2.4.2  build.gradle
plugins {  id &amp;#39;org.springframework.boot&amp;#39; version &amp;#39;2.4.2&amp;#39;  id &amp;#39;io.spring.dependency-management&amp;#39; version &amp;#39;1.0.11.RELEASE&amp;#39;  id &amp;#39;java&amp;#39; }  dependencies {  implementation &amp;#39;org.springframework.boot:spring-boot-starter-data-jpa&amp;#39;  compileOnly &amp;#39;org.</description>
    </item>
    
    <item>
      <title>一次线程死锁排查记录</title>
      <link>https://lexcao.io/zh/posts/async-within-async/</link>
      <pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lexcao.io/zh/posts/async-within-async/</guid>
      <description>背景 某次发版之后，线上服务低概率出现某台实例接口响应超时，具体表现为：
 /health 接口超时报警； 线程死锁，Tomcat 线程池吃满； 服务完全无响应。  保留下当前 heap dump 和 thread stack 后，临时重启服务器恢复正常。
# heap dump $ jmap -dump:format=b,file=dump.hprof [pid] # thread stack jstack [pid] &amp;gt; stack.txt 接下来简单记录一下排查结果。 （此文为回忆所写，当时排查的思考细节和过程已省略）
排查 heap dump 使用工具 Eclipse + MAT
安装 # 安装 eclipse $ brew cask install eclipse-java # 安装 eclipse MAT $ brew cask install mat # 是的，这个就是 eclipse-mat 相关连接   Eclipse
  Eclipse MAT
  使用   把 heap dump 文件 dump.</description>
    </item>
    
  </channel>
</rss>
