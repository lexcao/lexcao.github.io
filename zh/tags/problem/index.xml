<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Problem on The Coding Notes</title>
    <link>https://lexcao.io/zh/tags/problem/</link>
    <description>Recent content in Problem on The Coding Notes</description>
    <image>
      <url>https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&fit=crop&w=720&q=80</url>
      <link>https://images.unsplash.com/photo-1510843572979-e4b9e790fdd7?auto=format&fit=crop&w=720&q=80</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 21 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://lexcao.io/zh/tags/problem/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>一次线程死锁排查记录</title>
      <link>https://lexcao.io/zh/posts/async-within-async/</link>
      <pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://lexcao.io/zh/posts/async-within-async/</guid>
      <description>背景 某次发版之后，线上服务低概率出现某台实例接口响应超时，具体表现为：
/health 接口超时报警； 线程死锁，Tomcat 线程池吃满； 服务完全无响应。 保留下当前 heap dump 和 thread stack 后，临时重启服务器恢复正常。
# heap dump $ jmap -dump:format=b,file=dump.hprof [pid] # thread stack jstack [pid] &amp;gt; stack.txt 接下来简单记录一下排查结果。 （此文为回忆所写，当时排查的思考细节和过程已省略）
排查 heap dump 使用工具 Eclipse + MAT
安装 # 安装 eclipse $ brew cask install eclipse-java # 安装 eclipse MAT $ brew cask install mat # 是的，这个就是 eclipse-mat 相关连接 Eclipse
Eclipse MAT
使用 把 heap dump 文件 dump.hprof 导入到 MAT。</description>
    </item>
    
  </channel>
</rss>
